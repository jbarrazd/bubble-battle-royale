{"version":3,"mappings":"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","names":["DeviceDetection","static","capabilities","constructor","this","detectCapabilities","getInstance","instance","ua","navigator","userAgent","toLowerCase","isTouch","window","maxTouchPoints","isMobile","test","isTablet","isDesktop","screenWidth","innerWidth","screenHeight","innerHeight","isLandscape","isPortrait","canvas","document","createElement","gl","getContext","hasWebGL","maxTextureSize","getParameter","MAX_TEXTURE_SIZE","hasWebAudio","AudioContext","webkitAudioContext","hasAudioTag","canPlayType","pixelRatio","devicePixelRatio","audioSupport","webAudio","audioTag","getCapabilities","updateOrientation","getQualityPreset","shouldReduceMotion","matchMedia","matches","getOptimalResolution","width","Math","min","height","floor","HD_SCALE","GAME_CONSTANTS","MAX_WIDTH","MAX_HEIGHT","COLORS","UI_SUCCESS","UI_TEXT","SceneKeys","GameEvents","SceneManager","game","currentScene","previousScene","transitionInProgress","eventEmitter","Phaser","Events","EventEmitter","Error","transitionTo","sceneName","data","scene","getScene","currentSceneInstance","isActive","fadeOutScene","switchScene","callback","cameras","main","fadeOut","once","stop","sceneData","transitionFrom","start","bringToTop","newScene","fadeIn","emit","SCENE_READY","getCurrentScene","getPreviousScene","isTransitioning","restartCurrentScene","pauseCurrentScene","pause","resumeCurrentScene","resume","launchParallelScene","run","stopParallelScene","on","event","off","setCurrentScene","PerformanceMonitor","fps","frameTime","lastTime","deltaTime","frameCount","fpsUpdateInterval","lastFpsUpdate","frames","maxFrameSamples","warningThreshold","criticalThreshold","consecutiveLowFrames","performance","now","setEventEmitter","emitter","update","time","currentTime","round","max","getFPS","getFrameTime","getDeltaTime","getMetrics","drawCalls","memoryUsage","getMemoryUsage","shouldReduceQuality","getAverageFPS","shouldIncreaseQuality","length","avgFrameTime","reduce","a","b","memory","usedJSHeapSize","reset","getPerformanceScore","avgFps","score","logMetrics","BootScene","Scene","sceneManager","deviceDetection","performanceMonitor","super","key","BOOT","init","_data","events","setupDeviceListeners","checkDeviceCapabilities","preload","loadingText","add","text","centerX","centerY","fontFamily","fontSize","color","align","setOrigin","progressBar","graphics","progressBox","x","y","fillStyle","fillRect","load","value","clear","destroy","create","setupGlobalEventListeners","PRELOAD","error","_delta","addEventListener","handleOrientationChange","hidden","handleGamePause","handleGameResume","showErrorMessage","scale","resize","sound","pauseAll","resumeAll","severity","handleCriticalPerformance","message","errorText","wordWrap","rectangle","setDepth","ASSET_KEYS","LOGO","BACKGROUND","PLANET","BUBBLE_PLANET","UFO","BUBBLE_SHOOT","BUBBLE_ATTACH","BUBBLES_DROP","COMBO_3","COMBO_4","COMBO_5_PLUS","COMBO_CELEBRATION","ARSENAL_PICKUP","SUCCESS_OBJECTIVE","VICTORY","UFO_SOUND","UFO_ARRIVES","CHEST_ARRIVAL","DEFEAT","BACKGROUND_MUSIC","AssetLoader","manifest","loadedCount","totalCount","images","url","type","audio","atlases","json","calculateTotalAssets","loadAssets","onProgress","file","loadImages","loadAudio","loadAtlases","loadJSON","forEach","item","textures","exists","image","cache","jsonUrl","replace","atlas","getProgress","getTotalAssets","getLoadedAssets","PreloadScene","assetLoader","percentText","assetText","createLoadingUI","setupLoadingListeners","createPlaceholderAssets","progress","updateProgress","cleanupLoadingUI","delayedCall","LOADING_COMPLETE","MENU","progressBarX","progressBarWidth","progressBarY","createLoadingAnimation","bubbleColors","i","bubble","circle","tweens","targets","duration","ease","yoyo","repeat","delay","setText","percent","progressBarHeight","make","fillCircle","generateTexture","MenuScene","buttons","titleText","versionText","fpsText","createBackground","createTitle","createMenuButtons","createVersionInfo","createFPSDisplay","addAnimations","_time","loop","actualFps","setTint","bg","setDisplaySize","Between","alpha","stroke","strokeThickness","scaleX","scaleY","action","startGame","startPractice","openSettings","showAbout","index","button","createButton","push","setAlpha","setScale","container","setStrokeStyle","setInteractive","useHandCursor","buttonText","setFillStyle","particles","lifespan","speedY","end","quantity","frequency","tint","onComplete","THEME_SELECT","showMessage","overlay","messageBox","messageText","closeButton","BackgroundSystem","config","gradientGraphics","gradientTexture","parallaxLayers","particleEmitters","ambientElements","animationTimers","themes","ocean","colors","accent","name","particleType","secondaryParticles","sunset","forest","space","aurora","currentTheme","theme","quality","enableParticles","enableAnimation","createGradientBackground","createParallaxLayers","createAmbientParticles","createAnimatedElements","startAnimations","gradientHeight","color1","color2","ratio","blendedColor","blendColors","addNoiseTexture","layerCount","layer","elementCount","j","element","createThemeElement","layerIndex","firefly","from","to","bgLeaf","ellipse","RND","pick","setAngle","angle","pillar","setBlendMode","BlendModes","ADD","drawLeaf","size","points","fillPoints","particleCount","createThemeParticle","particle","startX","startY","FloatBetween","sin","Date","recycleParticle","createFireflyPath","leafSize","fallDuration","starSize","starX","starY","active","curtainX","curtainWidth","curtainColor","colorPhase","shimmerTimer","addEvent","onUpdate","tween","fromColor","toColor","blended","Display","Color","Interpolate","ColorWithColor","IntegerToColor","GetColor","r","g","moveFirefly","newX","newY","boundedX","Clamp","boundedY","filter","e","createSecondaryEffect","sparkleTimer","clusterX","smallBubble","spark","dust","sparkle","star","createBackgroundPlanet","createShootingStarTimer","earthX","earthY","startScale","endScale","earth","createFloatingBubblesBetweenPlanets","createShootingStar","createNextStar","shootingContainer","segment","head","endX","endY","updateEvent","updateParallax","bind","startGradientAnimation","speed","hueShift","gradientTimer","shifted","shiftHue","noiseGraphics","r1","g1","b1","r2","g2","b2","degrees","l","d","s","h","hue2rgb","p","q","t","setTheme","setQuality","timer","ThemeSelectScene","backgroundSystem","selectedTheme","themeContainers","confirmButton","previewBackground","description","icon","createThemeCards","createConfirmButton","setupKeyboardControls","selectTheme","cardWidth","cardHeight","createThemeCard","fillRoundedRect","lineStyle","strokeRoundedRect","glow","setVisible","setData","iconX","nameText","descText","dotsStartX","dot","dotSize","Geom","Rectangle","Contains","buttonY","buttonWidth","buttonHeight","getData","registry","set","input","keyboard","GAME","shutdown","BubbleColor","ArenaZone","ARENA_CONFIG","playerZoneHeight","opponentZoneHeight","objectiveZoneHeight","bubbleSize","objectiveSize","launcherOffset","BUBBLE_CONFIG","SIZE","POOL_SIZE","ANIMATION_DURATION","GRID_CONFIG","DANGER_ZONE_CONFIG","PLAYER_OFFSET","OPPONENT_OFFSET","PULSE_DURATION","ZONE_COLORS","Z_LAYERS","BubbleGrid","hexSize","gridMap","Map","initializeGrid","getKey","hexToPixel","hex","rowHeight","sqrt","colWidth","xOffset","abs","pixelToHex","pixel","adjustedX","roundHex","rq","rr","rs","qDiff","rDiff","sDiff","getNeighbors","directions","map","dir","getDistance","getRing","center","radius","results","getSpiral","maxRadius","ring","isValidPosition","has","getGridBounds","minQ","maxQ","minR","maxR","getAllBubbles","getBubbleAt","getBubblesInRadius","Bubble","GameObjects","Container","bubbleSprite","innerGradient","highlightSprite","secondaryHighlight","shadowSprite","rimLight","patternSprite","gridPosition","isSpecial","pooled","shooter","idleAnimation","getDarkerColor","getLighterColor","setSize","existing","addIdleAnimation","setGridPosition","getGridPosition","setShooter","getShooter","getColor","setColor","clearTint","setSpecial","special","addGlow","removeGlow","getIsSpecial","addAt","glowElement","getAt","killTweensOf","removeAt","addColorblindPattern","RED","lineBetween","BLUE","GREEN","offset","YELLOW","PURPLE","x1","y1","x2","y2","pop","returnToPool","createPopParticles","colorIndex","PI","random","rotationSpeed","cos","flash1","setPosition","isPooled","getRandomColor","ScoreEventType","ScoreEventManager","modules","eventQueue","processing","totalPlayerScore","totalOpponentScore","MAX_QUEUE_SIZE","PROCESS_INTERVAL","scoreUpdateCallbacks","visualEffectCallbacks","initializeDefaultModules","startProcessing","registerModule","BubbleMatchModule","OrphanDropModule","ChainComboModule","module","get","sort","priority","queueEvent","context","timestamp","processed","shift","processQueue","callbackScope","eventsToProcess","processEvent","finalResult","canProcess","result","calculateScore","finalScore","visualEffectLevel","isPlayer","notifyScoreUpdate","notifyVisualEffect","position","onScoreUpdate","onVisualEffect","cb","getPlayerScore","getOpponentScore","BASE_POINTS","matchSize","basePoints","multiplier","displayText","effectLevel","bubbleColor","comboMultiplier","dropCount","metadata","totalPoints","ceil","chainCount","lastChainTime","CHAIN_TIMEOUT","isChain","PowerUpType","MysteryBubble","powerUpIcon","currentPowerUp","powerUpCycleTimer","glowEffect","iconBg","powerUpSequence","RAINBOW","BOMB","LIGHTNING","FREEZE","LASER","MULTIPLIER","sequenceIndex","powerUpIcons","SHIELD","MAGNET","createMysteryVisuals","startPowerUpCycle","list","updateGlowEffect","updatePowerUpDisplay","cycleFunction","cyclePowerUp","getCurrentPowerUp","isMysteryBubble","collectPowerUp","isPlayerShot","floatingIcon","powerUpText","flash","owner","Launcher","launcherPlatform","bubbleChamber","queuePanel","effectsLayer","platformGraphics","chamberGraphics","queueBackground","queueLabel","stateIndicator","readyIndicator","queueContainer","nextBubbleFrame","nextBubbleGraphics","secondBubbleGraphics","arsenalSlots","weaponRing","energyConduits","activePowerUp","arsenalContainer","chargingTween","zone","currentAngle","loadedBubble","nextBubbleColors","isAiming","isOpponent","launcherState","powerLevel","BUBBLE_POSITION_Y","QUEUE_POSITION_Y","ARSENAL_POSITIONS_PLAYER","ARSENAL_POSITIONS_OPPONENT","SLOT_SIZE","OPPONENT","createExceptionalLauncher","createIntegratedArsenal","updateTheme","startEnhancedIdleAnimations","setupArsenalListeners","setupMobileTouchArea","createLauncherPlatform","createBubbleChamber","createEnhancedQueueSystem","createStateIndicators","createEffectsLayer","updateAllVisuals","renderLauncherPlatform","renderBubbleChamber","renderEnhancedQueue","renderStateIndicators","renderGlowEffects","topY","bottomY","columnWidth","fillGradientStyle","platform","top","bottom","chamber","highlight","rim","outerTop","outerBottom","strokeCircle","innerRim","innerRadius","renderEnhancedQueueBubbles","aiming","pulse","createNextBubble","createSecondBubble","bubbleGraphics","drawQueueBubble","rotation","resetQueueBubbles","bubbleTheme","getBubbleColors","primary","dark","light","drawSmallQueueBubble","loaded","getExceptionalTheme","base","secondary","darkenColor","shadow","innerTop","innerBottom","depth","queue","panelTop","panelBottom","panelBorder","panelGlow","factor","paused","touchArea","pointer","ripple","setHighlight","setAimAngle","visualAngle","PLAYER","getAimAngle","getAimDirection","rad","DegToRad","Vector2","showAiming","show","animateShoot","createEnhancedLaunchEffects","animateEnhancedLaunch","setTimeout","setState","state","updateStateIndicator","chargeColor","startPowerCharge","renderPowerIndicator","releasePowerCharge","power","powerColor","enabled","loadBubble","remove","updateArsenalTheme","getLoadedBubble","clearLoadedBubble","updateQueueColors","recoilIntensity","shakeIntensity","recoilDistance","shake","effectY","effectIntensity","flashSize","distance","sparkX","sparkY","sparkleSize","slot","background","drawArsenalSlotBackground","createArsenalChamber","pos","createArsenalSlot","chamberY","chamberHeight","chamberWidth","chamberX","inner","panelX","detail","tubeStartX","tubeEndX","tubeHeight","tubeY","lineY","setLineDash","setShadow","countText","device","touch","keyHint","createKeyHintBadge","touchPadding","activateArsenalSlot","baseScale","powerUpType","count","halfSize","innerR","outerR","arc","strokePath","fillEllipse","badge","badgeColor","addPowerUpToArsenal","find","showPowerUpCollectionEffect","showEmptySlotFeedback","activatePowerUp","showPowerUpActivation","startSlotCooldown","renderEnergyConduit","burst","px","py","collectFlash","progressArc","getValue","beginPath","Objective","chestBody","chestLid","chestLock","shield","health","maxHealth","shielded","starBurstTimer","peekTimer","outerGlow","middleGlow","chestSize","detail1","detail2","detail3","sparkleCount","offsetX","Utils","Array","GetRandom","shimmer","setShielded","showVulnerable","hit","damage","createVictoryParticles","vx","vy","getHealth","getMaxHealth","isVulnerable","isShielded","playVictoryAnimation","Arc","particleTimer","InputManager","currentPosition","sensitivity","isEnabled","setupInput","activePointer","onPointerMove","onPointerDown","onPointerUp","targetX","targetY","_pointer","getPosition","getPointerPosition","getAngleFrom","fromX","fromY","dx","dy","atan2","RadToDeg","getAngleFromWithConstraints","minAngle","maxAngle","constrainedMin","constrainedMax","setEnabled","isPointerActive","setSensitivity","TrajectoryPreview","launcher","dots","dotPool","currentBubbleColor","DOT_COUNT","DOT_SIZE","DOT_SPACING","PREVIEW_PERCENTAGE","MAX_PREVIEW_DISTANCE","SHOOT_SPEED","animationTime","isVisible","bounds","createDotPool","calculateTrajectory","hide","radians","magnitude","maxDots","dotIndex","totalDistance","left","right","fadeStart","targetAlpha","delta","waveOffset","wave","animatedAlpha","sizeWave","colorProgress","baseColor","red","green","blue","ShootingSystem","inputManager","playerLauncher","opponentLauncher","projectiles","currentBubble","availableColors","canShoot","cooldownTime","shootSpeed","cooldownBar","cooldownBarBg","trajectoryPreview","gridAttachmentSystem","bubbleGrid","generateNextBubbleColors","setupShooting","onShoot","onAIShoot","createCooldownIndicator","loadNextBubble","setOpponentLauncher","launcherY","startCooldownAnimation","barX","barY","randomColor","currentColor","newColor","direction","velocity","shotBubbleColor","aiBubble","projectile","isAI","checkProjectileCollisions","visible","hitBubble","checkCollision","attachPos","findAttachmentPosition","pixelPos","Distance","attachToGrid","checkWallCollision","splice","proj1","proj2","len","nx","ny","overlap","impulse","isReady","getProjectileCount","GridAttachmentSystem","gridBubbles","attachmentInProgress","attachmentQueue","matchDetectionSystem","spatialGrid","gridPositions","setMatchDetectionSystem","addGridBubble","includes","updateSpatialGrid","removeGridBubble","indexOf","projectilePos","collisionRadius","centerPixel","isPositionOccupied","virtualBubble","nearbyBubbles","getNearbyBubbles","gridBubble","gridSize","cellX","cellY","nearby","cellBubbles","hitHexPos","angleDeg","neighborOffsets","bestNeighbor","minAngleDiff","neighbor","angleDiff","findBestAvailablePosition","targetHex","ringPositions","bestPos","minDistance","Infinity","hexPos","some","hexToKey","threshold","cleanupMisalignedBubbles","createAttachmentEffect","async","finalPixelPos","checkForMatches","checkDisconnectedBubbles","next","newBubble","toRemove","disconnected","findDisconnectedGroups","allDisconnected","bubbles","applyBidirectionalGravity","OBJECTIVE","visited","Set","connected","centerHex","anchors","centerBubble","getBubbleAtPosition","neighborHex","getZoneForBubble","anchor","floodFill","neighborBubble","objectiveTop","objectiveBottom","fallingUp","fallingDown","animateFallingBubbles","outOfBounds","oldPos","delete","horizontalDrift","getGridBubbles","clearGrid","debugDrawConnections","hasGridPosition","gridKey","MatchDetectionSystem","minimumMatchSize","isProcessing","totalScore","combo","lastMatchTime","comboTimeout","attachedBubble","findColorMatches","avgX","avgY","worldPos","getWorldTransformMatrix","tx","ty","isAIMatch","highlightMatches","Promise","resolve","updateCombo","positions","removeMatches","checkFloatingBubbles","startBubble","targetColor","current","colorMatches","neighbors","getNeighborBubbles","hexNeighbors","sum","getPopAnimationStyle","promises","promise","createParticles","explosionAngle","explosionDistance","all","upwardBubbles","downwardBubbles","bonusPerBubble","totalOrphanBonus","isAIBonus","isOrphanBonus","showOrphanBonus","bonus","adjustedY","bonusContainer","dropText","fontStyle","pointsText","createDropParticles","zoneMultiplier","getZone","getScore","AIDifficulty","AIOpponentSystem","shootTimer","difficulty","isOnCooldown","COOLDOWN_TIME","onShootingComplete","setDifficulty","scheduleNextShot","thinkingTime","performShot","target","calculateBestShot","bubbleToShoot","sameColorBubbles","closestBubbles","bestTarget","objectiveShot","checkObjectiveShot","allTargets","isObjectiveExposed","blockingBubbles","unshift","targetBubble","angles","calculateAngleToTarget","targetPos","isTrajectoryLikelyClear","countPotentialMatch","potentialFalls","nearObjective","baseScore","fallBonus","useWallBounce","totalValue","reasoning","bounceTargets","findWallBounceTargets","slice","findStraightShotTarget","allBubbles","safeAngles","getColorName","findTargetsViaWallBounce","attachPoints","getAttachmentPoints","point","wouldConnect","countConnectedBubbles","mirrorX","leftBounceAngle","mirrorX2","rightBounceAngle","findBestWallBounce","leftMirrorX","leftAngle","bouncePoint","tan","rightMirrorX","rightAngle","offsets","isTrajectoryClear","testX","testY","stepDist","children","child","MYSTERY","getClosestBubbles","limit","distA","distB","targetDist","checkX","checkY","quickCountPotentialMatch","shootColor","toCheck","matchCount","predictFallsFromShot","supportingNeighbors","n","other","EnhancedScoreDisplay","playerScore","opponentScore","playerScoreText","opponentScoreText","playerNameText","opponentNameText","playerDisplayScore","opponentDisplayScore","playerTargetScore","opponentTargetScore","playerLeadIndicator","opponentLeadIndicator","currentLeader","playerContainer","opponentContainer","createPlayerDisplay","createOpponentDisplay","containerHeight","containerWidth","updatePlayerScore","newScore","instant","formatScore","pulseScore","updateLeaderIndicator","updateOpponentScore","scoreText","toLocaleString","newLeader","animateLeader","indicator","ComboManager","currentCombo","comboContainers","COMBO_CONFIGS","tier","minBubbles","CHAIN_BONUS","createComboDisplay","comboContainer","comboText","comboConfig","getComboConfig","chainBonus","showCombo","addComboBackground","displayColor","setFontSize","setStyle","createParticleEffect","createImpactFlash","addComboStars","starCount","createFireExplosion","createExplosionEffect","createColorBurst","particleSize","speedRange","shadeVariation","particleColor","ValueToColor","finalColor","createGlowEffect","explosionColor","streak","setRotation","fireGradient","dist","fireParticle","starBurst","fireColors","c","shockwave","fireColor","flame","fireText","colorFlash","getCurrentCombo","getMultiplier","VictoryScreen","onReplay","onMenu","backdrop","panelBg","banner","victoryGlow","victoryText","star1","createStar","star2","star3","scoreBg","scoreLabel","scoreValue","statsText","playAgainBtn","menuBtn","scoreCounter","toString","createConfetti","bgColor","hoverColor","label","confettiTimer","shape","DefeatScreen","onRetry","defeatText","encourageText","motivationalMsg","motivationText","retryBtn","createFloatingBubbles","isPrimary","FloatingTextEffect","gameObject","deactivate","activate","targetScale","ParticleBurstEffect","MAX_PARTICLES","intensity","speedBase","setRadius","RingExplosionEffect","EffectPool","pools","activeEffects","POOL_SIZES","floating_text","particle_burst","ring_explosion","star_burst","combo_display","initializePools","createPool","factory","pool","getEffect","effect","oldest","showFloatingText","showParticleBurst","showRingExplosion","showComboEffect","comboLevel","UnifiedFeedbackSystem","effectPool","feedbackQueue","activeFeedbacks","MIN_VERTICAL_SPACING","MIN_HORIZONTAL_SPACING","FEEDBACK_DURATION","queueFeedback","f","endTime","itemsToProcess","showFeedback","calculateOffset","finalPosition","showEffectsForLevel","offsetY","conflictCount","createSparkleEffect","createPopEffect","addScreenShake","addCameraFlash","createFireEffect","colorObj","ExceptionCode","AimingMode","AimingModeSystem","currentMode","aimingGraphics","trajectoryLine","cursorSprite","modeIndicator","trajectoryPoints","MAX_BOUNCES","TRAJECTORY_STEPS","setMode","mode","powerUp","clearGraphics","createModeIndicator","updateCursorStyle","updateAiming","pointerX","pointerY","launcherX","drawNormalCrosshair","drawBasicTrajectory","drawRainbowCrosshair","drawLaserSight","drawBombRadius","drawBallisticArc","drawSelectionCursor","drawFreezeArea","drawTripleArrow","moveTo","lineTo","nextAngle","lastPoint","maxHeight","Linear","Point","sx","sy","baseAngle","drawArrowHead","angleLeft","angleRight","steps","t1","t2","extended","bounces","maxSteps","modeNames","crosshair","rainbow_sphere","extended_line","explosion_radius","ballistic_arc","selection_cursor","snowflake_area","triple_arrow","style","cursor","getTargetingInfo","trajectory","RainbowEffect","rainbowBubble","visualElements","aimingMode","rainbowText","shotsRemaining","applyRainbowEffect","NORMAL","LaserSightEffect","remainingShots","createShotCounter","counter","BombEffect","targetMode","BOMB_BALLISTIC","prepareBallistic","BOMB_NORMAL","prepareNormalBomb","bombGlow","glowRadius","glowTimer","sparkContainer","sparkTimer","bombCore","bombText","blur","fill","explodeAt","shockRadius","shockTimer","explosionContainer","debrisContainer","debris","smokeContainer","smoke","miniFlash","LightningEffect","selectionHandler","lightningText","destroyWithLightning","lightning","currentX","currentY","nextX","nextY","FreezeEffect","frozenBubbles","frostOverlay","physics","createFrostOverlay","freezeText","snowflake","MultiShotEffect","MULTI","multiText","PowerUpActivationSystem","effects","activeEffect","aimingModeSystem","setupEventListeners","showActivationFeedback","powerUpNames","PaintSplatterSystem","splatters","minDropletSize","maxDropletSize","minDroplets","maxDroplets","minSpread","maxSpread","fadeStartDelay","fadeDuration","initialAlpha","colorVariation","maxSplatters","cleanupBatchSize","scaleWithCombo","comboScaleFactor","maxComboScale","DEFAULT_CONFIG","updateConfig","getConfig","handleBubbleExplosion","dropletsPerBubble","calculateDropletsPerBubble","createSplatterAtPosition","createSplatter","bubbleCount","totalDroplets","extraDroplets","dropletCount","createDroplet","spreadMultiplier","dropletX","dropletY","sizeMultiplier","variedColor","applyColorVariation","shapeType","save","translateCanvas","rotateCanvas","restore","closePath","fillPath","pointAngle","pointDist","oldSplatter","variation","darkness","newR","newG","newB","cam","isNaN","isFinite","getSplatterCount","setQualityPreset","preset","ArenaSystem","HARD","objective","bubblePool","zones","debugGraphics","debugEnabled","shootingSystem","aiOpponent","isSinglePlayer","enhancedScoreDisplay","comboManager","scoreEventManager","unifiedFeedbackSystem","playerPowerUpInventory","opponentPowerUpInventory","powerUpActivation","aiScore","gameOver","victoryScreen","defeatScreen","isRestarting","playerDangerLine","opponentDangerLine","dangerWarningActive","paintSplatterSystem","dangerCheckCounter","DANGER_CHECK_INTERVAL","shieldCheckCounter","SHIELD_CHECK_INTERVAL","cachedShieldState","aimingCheckCounter","AIMING_CHECK_INTERVAL","lastAimAngle","initializeZones","createBubblePool","setupArena","singlePlayer","currentDifficulty","actualDifficulty","createLaunchers","createObjective","createInitialBubbles","createZoneVisuals","checkVictoryCondition","checkChestHit","toggleDebug","changeAIDifficulty","EASY","MEDIUM","playerZone","opponentZone","createUFODelivery","ufo","ufoArrivalSound","ufoSound","volume","rate","play","trailParticles","follow","followOffset","blendMode","emitting","engineGlow","speedX","animateTractorBeam","departParticles","explode","onStart","beamStartY","beamHeight","beamContainer","beamBase","beamParticles","spiralParticles","beamPulse","spiralAngle","setParticleSpeed","chestGlow","midPoint","allPositions","totalBubbles","targetMysteryCount","mysteryPerSide","mysteryPositions","side","sideCount","maxAttempts","attempts","isPlayerSide","mysteryBubble","playerSideMysteryCount","opponentSideMysteryCount","getBubbleFromPool","updateObjectiveShield","returnBubbleToPool","showDebugOverlay","hideDebugOverlay","toUpperCase","backgroundColor","drawHexGrid","strokePoints","Text","hasAdjacentBubbles","getZoneBounds","getBubbles","getObjective","getPlayerLauncher","getOpponentLauncher","updateLauncherAiming","checkDangerZoneProximity","launcherPos","showDifficultyNotification","notification","ORPHAN_DROP","baseValue","BUBBLE_MATCH","SPECIAL_BONUS","playerWins","obj","triggerGameOver","playerDangerY","opponentDangerY","expectedPos","wasAIShot","restartGame","returnToMenu","fade","winner","removeAll","restart","phaserError","location","href","split","reload","e2","history","go","nearDanger","playerDistance","activateDangerWarning","opponentDistance","deactivateDangerWarning","dangerLine","getPaintSplatterSystem","setGraphicsQuality","RealSoundSystem","sounds","muted","masterVolume","volumes","shoot","attach","celebration","arsenal","victory","initializeSounds","audioCache","Object","values","playShootSound","playSound","playAttachSound","playBubblesDropSound","playComboSound","soundKey","playMatchSound","playArsenalPickupSound","playSuccessObjectiveSound","playVictorySound","playDefeatSound","playPowerUpSound","playClickSound","playBackgroundMusic","existingMusic","music","toggleMute","mute","setMasterVolume","testAllSounds","getInfo","soundsLoaded","totalSounds","TweenOptimizer","activeTweens","tweenGroups","frameCounter","createOptimizedTween","id","props","options","group","existingTween","getGroupTween","canShareTween","addTargetToTween","stagger","tweenConfig","throttleUpdate","tweenData","linkedConfig","groupIds","firstId","removeTween","ids","pauseGroup","resumeGroup","getStats","tweensPerGroup","totalTweens","groups","GameScene","arenaSystem","soundSystem","backgroundMusic","lastFPSUpdate","isPaused","tweenOptimizer","isCapacitor","Capacitor","setBackgroundColor","createSoundSystem","createBackgroundMusic","createArena","createUI","setupInputHandlers","setupSoundEvents","padding","setScrollFactor","togglePause","testBubblePop","randomBubble","showPauseOverlay","hidePauseOverlay","pauseText","resumeText","updateFPSDisplay","elapsed","CapacitorException","code","createCapacitor","win","capCustomPlatform","CapacitorCustomPlatform","cap","Plugins","getPlatform","_a","_b","androidBridge","webkit","messageHandlers","bridge","getPlatformId","getPluginHeader","pluginName","PluginHeaders","registeredPlugins","convertFileSrc","filePath","handleError","err","console","isNativePlatform","isPluginAvailable","plugin","platforms","registerPlugin","jsImplementations","registeredPlugin","proxy","pluginHeader","jsImplementation","createPluginMethodWrapper","prop","wrapper","args","loadPluginImplementation","then","impl","fn","Unimplemented","methodHeader","methods","m","rtype","nativePromise","nativeCallback","createPluginMethod","defineProperty","writable","configurable","addListener","removeListener","addListenerNative","eventName","call","callbackId","Proxy","_","keys","Exception","DEBUG","isLoggingEnabled","initCapacitorGlobal","globalThis","self","global","WebPlugin","listeners","retainedEventArguments","windowListeners","listenerFunc","firstListener","windowListener","registered","addWindowListener","sendRetainedArgumentsForEvent","removeAllListeners","listener","removeWindowListener","notifyListeners","retainUntilConsumed","hasListeners","registerWindowListener","windowEventName","pluginEventName","handler","unimplemented","msg","unavailable","Unavailable","handle","removeEventListener","arg","encode","str","encodeURIComponent","decodeURIComponent","escape","decode","CapacitorCookiesPluginWeb","getCookies","cookies","cookie","cookieMap","trim","setCookie","encodedKey","encodedValue","expires","path","domain","reject","deleteCookie","clearCookies","toUTCString","clearAllCookies","web","buildRequestInit","extra","output","assign","method","headers","originalKeys","k","toLocaleLowerCase","acc","normalizeHttpHeaders","body","params","URLSearchParams","entries","FormData","form","append","Headers","JSON","stringify","CapacitorHttpPluginWeb","request","requestInit","webFetchExtra","urlParams","shouldEncode","accumulator","entry","isArray","substr","buildUrlParams","shouldEncodeUrlParams","response","fetch","contentType","blob","responseType","ok","reader","FileReader","onload","base64String","onerror","readAsDataURL","readBlobAsBase64","status","post","put","patch","Style","Animation","StatusBar","KeyboardStyle","KeyboardResize","Keyboard","App","__vitePreload","import","AppWeb","Performance","maximizePerformance","success","getDeviceCapabilities","model","systemVersion","processorCount","hardwareConcurrency","physicalMemory","thermalState","lowPowerMode","batteryLevel","supportsProMotion","CapacitorOptimizations","initialize","hideStatusBar","configureKeyboard","handleAppStateChanges","disableOverscroll","optimizeWebView","requestHighPerformance","maximizeDevicePerformance","setResizeMode","setAccessoryBarVisible","onAppResume","onAppPause","overflow","touches","preventDefault","passive","userSelect","webkitUserSelect","webkitTapHighlightColor","transform","webkitTransform","webkitTouchCallout","viewport","querySelector","setAttribute","wakeLock","catch","audioContext","suspend","release","optimizer","setupErrorHandling","waitForDOM","createGame","hideLoadingScreen","readyState","scenes","resolution","WEBGL","parent","Scale","FIT","autoCenter","CENTER_BOTH","default","arcade","gravity","debug","forceSetTimeOut","render","antialias","pixelArt","roundPixels","transparent","clearBeforeRender","preserveDrawingBuffer","premultipliedAlpha","failIfMajorPerformanceCaveat","powerPreference","batchSize","maxLights","maxTextures","mipmapFilter","desynchronized","autoMobilePipeline","multiTexture","antialiasSamples","stencil","webGLTimeout","forceWebGL1","activePointers","smoothFactor","windowEvents","disableVisibilityChange","createGameConfig","Game","setupGameEventListeners","loadingElement","getElementById","transition","opacity","display","innerHTML","getGame"],"sources":["../../src/utils/DeviceDetection.ts","../../src/config/GameConfig.ts","../../src/types/GameTypes.ts","../../src/systems/core/SceneManager.ts","../../src/utils/PerformanceMonitor.ts","../../src/scenes/BootScene.ts","../../src/config/AssetManifest.ts","../../src/scenes/PreloadScene.ts","../../src/scenes/MenuScene.ts","../../src/systems/visual/BackgroundSystem.ts","../../src/scenes/ThemeSelectScene.ts","../../src/types/ArenaTypes.ts","../../src/config/ArenaConfig.ts","../../src/systems/gameplay/BubbleGrid.ts","../../src/gameObjects/Bubble.ts","../../src/systems/scoring/ScoreEventManager.ts","../../src/systems/powerups/PowerUpManager.ts","../../src/gameObjects/MysteryBubble.ts","../../src/gameObjects/Launcher.ts","../../src/gameObjects/Objective.ts","../../src/systems/input/InputManager.ts","../../src/systems/gameplay/TrajectoryPreview.ts","../../src/systems/gameplay/ShootingSystem.ts","../../src/systems/gameplay/GridAttachmentSystem.ts","../../src/systems/gameplay/MatchDetectionSystem.ts","../../src/systems/gameplay/AIOpponentSystem.ts","../../src/ui/EnhancedScoreDisplay.ts","../../src/systems/gameplay/ComboManager.ts","../../src/ui/VictoryScreen.ts","../../src/ui/DefeatScreen.ts","../../src/systems/scoring/EffectPool.ts","../../src/systems/scoring/UnifiedFeedbackSystem.ts","../../src/systems/powerups/AimingModeSystem.ts","../../node_modules/@capacitor/core/dist/index.js","../../src/systems/powerups/PowerUpEffectsLibrary.ts","../../src/systems/powerups/PowerUpActivationSystem.ts","../../src/systems/visual/PaintSplatterSystem.ts","../../src/systems/gameplay/ArenaSystem.ts","../../src/systems/audio/RealSoundSystem.ts","../../src/systems/visual/TweenOptimizer.ts","../../src/scenes/GameScene.ts","../../node_modules/@capacitor/status-bar/dist/esm/definitions.js","../../node_modules/@capacitor/status-bar/dist/esm/index.js","../../node_modules/@capacitor/keyboard/dist/esm/definitions.js","../../node_modules/@capacitor/keyboard/dist/esm/index.js","../../node_modules/@capacitor/app/dist/esm/index.js","../../src/utils/performancePlugin.ts","../../src/utils/capacitorOptimizations.ts","../../src/main.ts"],"sourcesContent":["import { IDeviceCapabilities } from '@/types/GameTypes';\n\nexport class DeviceDetection {\n    private static instance: DeviceDetection;\n    private capabilities: IDeviceCapabilities;\n\n    private constructor() {\n        this.capabilities = this.detectCapabilities();\n    }\n\n    public static getInstance(): DeviceDetection {\n        if (!DeviceDetection.instance) {\n            DeviceDetection.instance = new DeviceDetection();\n        }\n        return DeviceDetection.instance;\n    }\n\n    private detectCapabilities(): IDeviceCapabilities {\n        const ua = navigator.userAgent.toLowerCase();\n        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        \n        const isMobile = /android|webos|iphone|ipod|blackberry|iemobile|opera mini/i.test(ua);\n        const isTablet = /ipad|android(?!.*mobile)/i.test(ua);\n        const isDesktop = !isMobile && !isTablet;\n        \n        const screenWidth = window.innerWidth;\n        const screenHeight = window.innerHeight;\n        const isLandscape = screenWidth > screenHeight;\n        const isPortrait = !isLandscape;\n        \n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n        const hasWebGL = !!gl;\n        \n        let maxTextureSize = 2048;\n        if (gl && hasWebGL) {\n            maxTextureSize = (gl as WebGLRenderingContext).getParameter((gl as WebGLRenderingContext).MAX_TEXTURE_SIZE);\n        }\n        \n        const AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n        const hasWebAudio = !!AudioContext;\n        const hasAudioTag = !!document.createElement('audio').canPlayType;\n        \n        return {\n            isTouch,\n            isMobile,\n            isTablet,\n            isDesktop,\n            pixelRatio: window.devicePixelRatio || 1,\n            screenWidth,\n            screenHeight,\n            isLandscape,\n            isPortrait,\n            hasWebGL,\n            maxTextureSize,\n            audioSupport: {\n                webAudio: hasWebAudio,\n                audioTag: hasAudioTag\n            }\n        };\n    }\n\n    public getCapabilities(): IDeviceCapabilities {\n        return { ...this.capabilities };\n    }\n\n    public updateOrientation(): void {\n        const screenWidth = window.innerWidth;\n        const screenHeight = window.innerHeight;\n        this.capabilities.screenWidth = screenWidth;\n        this.capabilities.screenHeight = screenHeight;\n        this.capabilities.isLandscape = screenWidth > screenHeight;\n        this.capabilities.isPortrait = !this.capabilities.isLandscape;\n    }\n\n    public getQualityPreset(): 'low' | 'medium' | 'high' {\n        const { isMobile, pixelRatio, maxTextureSize } = this.capabilities;\n        \n        if (isMobile && pixelRatio > 2 && maxTextureSize >= 4096) {\n            return 'high';\n        } else if (isMobile || maxTextureSize < 2048) {\n            return 'low';\n        } else {\n            return 'medium';\n        }\n    }\n\n    public shouldReduceMotion(): boolean {\n        return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n    }\n\n    public getOptimalResolution(): { width: number; height: number } {\n        const HD_SCALE = 2;  // Keep HD quality\n        const baseWidth = 375 * HD_SCALE;  // 750 HD\n        const baseHeight = 667 * HD_SCALE;  // 1334 HD\n        const maxWidth = 414 * HD_SCALE;    // 828 HD\n        const maxHeight = 896 * HD_SCALE;   // 1792 HD\n        \n        const { screenWidth, screenHeight, pixelRatio } = this.capabilities;\n        \n        let width = Math.min(screenWidth, maxWidth);\n        let height = Math.min(screenHeight, maxHeight);\n        \n        // Use HD resolution for all devices\n        width = Math.min(width * HD_SCALE, maxWidth);\n        height = Math.min(height * HD_SCALE, maxHeight);\n        \n        return { width: Math.floor(width), height: Math.floor(height) };\n    }\n}","import Phaser from 'phaser';\nimport { IGameConfig } from '@/types/GameTypes';\nimport { DeviceDetection } from '@utils/DeviceDetection';\n\nexport function createGameConfig(scenes: any[]): IGameConfig {\n    const device = DeviceDetection.getInstance();\n    const resolution = device.getOptimalResolution();\n    \n    // Detect if running on iOS/Capacitor\n    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);\n    const isCapacitor = (window as any).Capacitor !== undefined;\n    const isMobile = device.getCapabilities().isMobile || isIOS || isCapacitor;\n    \n    // PERFORMANCE: Use device pixel ratio for better performance on Capacitor\n    // This renders at native resolution instead of forcing 2x\n    const pixelRatio = (isCapacitor && window.devicePixelRatio) ? window.devicePixelRatio : 1;\n    \n    return {\n        // Force WebGL for consistent rendering across all platforms\n        type: Phaser.WEBGL,\n        parent: 'game',\n        backgroundColor: '#1a1a2e',\n        width: resolution.width,\n        height: resolution.height,\n        scale: {\n            mode: Phaser.Scale.FIT,\n            autoCenter: Phaser.Scale.CENTER_BOTH,\n            width: resolution.width,\n            height: resolution.height\n        },\n        physics: {\n            default: 'arcade',\n            arcade: {\n                gravity: { x: 0, y: 0 },\n                debug: false,\n                // iOS-optimized physics with interpolation\n            }\n        },\n        fps: {\n            target: 120,  // Target 120 FPS on all platforms\n            forceSetTimeOut: false  // Use RAF for better performance\n        },\n        render: {\n            // PERFORMANCE: Optimize for iOS\n            antialias: false,  // Disable for better performance\n            pixelArt: false,\n            roundPixels: false,  // Better performance\n            transparent: false,\n            clearBeforeRender: true,\n            preserveDrawingBuffer: false,\n            premultipliedAlpha: true,\n            failIfMajorPerformanceCaveat: false,\n            powerPreference: 'high-performance',  // Request high-performance GPU\n            batchSize: 4096,  // Increased for 120 FPS target\n            // Ultra HD resolution for premium quality\n            // Using higher resolution for sharper graphics\n            resolution: Math.min(window.devicePixelRatio || 1, 3),\n            maxLights: 1,  // Minimum required for shader compilation\n            maxTextures: -1,\n            mipmapFilter: 'LINEAR',\n            // CRITICAL iOS PERFORMANCE\n            desynchronized: true,  // Better performance for 120 FPS\n            autoMobilePipeline: false,  // Disable auto pipeline for consistency\n            multiTexture: true,  // Enable for better batching at 120 FPS\n            // WebGL specific settings\n            antialiasSamples: 0,  // No MSAA for performance\n            depth: false,  // We don't need depth buffer\n            stencil: false,  // We don't need stencil buffer\n            // iOS specific WebGL optimizations\n            webGLTimeout: 0,  // Disable WebGL timeout\n            forceWebGL1: false  // Use WebGL2 if available\n        },\n        scene: scenes,\n        // iOS-specific optimizations\n        input: {\n            activePointers: 2,  // Support multi-touch\n            smoothFactor: 0,\n            windowEvents: false  // Prevent window event conflicts\n        },\n        // Disable features that impact performance\n        disableVisibilityChange: false,\n        banner: false\n    };\n}\n\n// HD_SCALE: Factor to scale everything for Ultra HD quality\nexport const HD_SCALE = 2.5; // Ultra HD quality restored\n\nexport const GAME_CONSTANTS = {\n    BASE_WIDTH: 375 * HD_SCALE,  // 750 for HD\n    BASE_HEIGHT: 667 * HD_SCALE,  // 1334 for HD\n    MAX_WIDTH: 414 * HD_SCALE,    // 828 for HD\n    MAX_HEIGHT: 896 * HD_SCALE,   // 1792 for HD\n    TARGET_FPS: 120,\n    HD_SCALE: HD_SCALE,  // Export scale factor\n    \n    BUBBLE_SIZE: 32 * HD_SCALE,  // 64 for HD\n    BUBBLE_SPEED: 800 * HD_SCALE,  // 1600 for HD\n    GRID_ROWS: 12,\n    GRID_COLS: 11,\n    \n    COLORS: {\n        BACKGROUND: '#1a1a2e',\n        UI_PRIMARY: '#f39c12',\n        UI_SECONDARY: '#3498db',\n        UI_SUCCESS: '#2ecc71',\n        UI_DANGER: '#e74c3c',\n        UI_TEXT: '#ffffff',\n        UI_TEXT_DARK: '#2c3e50'\n    },\n    \n    ANIMATIONS: {\n        BUBBLE_POP_DURATION: 200,\n        SCENE_TRANSITION_DURATION: 300,\n        UI_TRANSITION_DURATION: 200,\n        COMBO_DISPLAY_DURATION: 1000\n    },\n    \n    AUDIO: {\n        MASTER_VOLUME: 0.7,\n        SFX_VOLUME: 0.8,\n        MUSIC_VOLUME: 0.5\n    },\n    \n    NETWORKING: {\n        SYNC_RATE: 100,\n        TIMEOUT: 10000,\n        RECONNECT_ATTEMPTS: 3\n    }\n};\n\nexport const QUALITY_PRESETS = {\n    low: {\n        particleCount: 10,\n        particleScale: 0.5,\n        shadowsEnabled: false,\n        postProcessing: false,\n        textureQuality: 0.5,\n        maxDrawCalls: 50\n    },\n    medium: {\n        particleCount: 25,\n        particleScale: 0.75,\n        shadowsEnabled: false,\n        postProcessing: false,\n        textureQuality: 0.75,\n        maxDrawCalls: 100\n    },\n    high: {\n        particleCount: 50,\n        particleScale: 1,\n        shadowsEnabled: true,\n        postProcessing: true,\n        textureQuality: 1,\n        maxDrawCalls: 200\n    }\n};","import { Scene } from 'phaser';\n\nexport interface IGameConfig {\n    width: number;\n    height: number;\n    type: number;\n    parent: string;\n    backgroundColor: string;\n    scale: {\n        mode: Phaser.Scale.ScaleModes;\n        autoCenter: Phaser.Scale.Center;\n        width: number;\n        height: number;\n    };\n    physics: {\n        default: string;\n        arcade: {\n            gravity: { x: number; y: number };\n            debug: boolean;\n        };\n    };\n    fps?: {\n        target: number;\n        forceSetTimeOut: boolean;\n    };\n    render?: any;\n    input?: any;\n    scene: Scene[];\n}\n\nexport interface ISceneData {\n    transitionFrom?: string;\n    transitionDuration?: number;\n    data?: Record<string, unknown>;\n}\n\nexport interface IDeviceCapabilities {\n    isTouch: boolean;\n    isMobile: boolean;\n    isTablet: boolean;\n    isDesktop: boolean;\n    pixelRatio: number;\n    screenWidth: number;\n    screenHeight: number;\n    isLandscape: boolean;\n    isPortrait: boolean;\n    hasWebGL: boolean;\n    maxTextureSize: number;\n    audioSupport: {\n        webAudio: boolean;\n        audioTag: boolean;\n    };\n}\n\nexport interface IPerformanceMetrics {\n    fps: number;\n    frameTime: number;\n    deltaTime: number;\n    drawCalls: number;\n    memoryUsage: number | undefined;\n}\n\nexport interface IAssetManifestItem {\n    key: string;\n    url: string;\n    type: 'image' | 'audio' | 'json' | 'atlas' | 'spritesheet' | 'tilemapJSON';\n    data?: Record<string, unknown>;\n}\n\nexport interface IAssetManifest {\n    images: IAssetManifestItem[];\n    audio: IAssetManifestItem[];\n    atlases: IAssetManifestItem[];\n    json: IAssetManifestItem[];\n}\n\nexport enum SceneKeys {\n    BOOT = 'BootScene',\n    PRELOAD = 'PreloadScene',\n    MENU = 'MenuScene',\n    THEME_SELECT = 'ThemeSelectScene',\n    GAME = 'GameScene',\n    VICTORY = 'VictoryScene',\n    SHOP = 'ShopScene'\n}\n\nexport enum GameEvents {\n    SCENE_READY = 'scene-ready',\n    SCENE_TRANSITION = 'scene-transition',\n    PERFORMANCE_WARNING = 'performance-warning',\n    ASSET_LOADED = 'asset-loaded',\n    LOADING_COMPLETE = 'loading-complete',\n    QUALITY_CHANGED = 'quality-changed'\n}\n\nexport interface IGameSettings {\n    soundEnabled: boolean;\n    musicEnabled: boolean;\n    vibrationEnabled: boolean;\n    quality: 'low' | 'medium' | 'high' | 'auto';\n    language: string;\n}\n\nexport interface IGameState {\n    currentScene: string;\n    previousScene: string;\n    isTransitioning: boolean;\n    settings: IGameSettings;\n    performance: IPerformanceMetrics;\n}","import { Scene } from 'phaser';\nimport { GameEvents, ISceneData } from '@/types/GameTypes';\n\nexport class SceneManager {\n    private static instance: SceneManager;\n    private game: Phaser.Game;\n    private currentScene: string = '';\n    private previousScene: string = '';\n    private transitionInProgress: boolean = false;\n    private eventEmitter: Phaser.Events.EventEmitter;\n\n    private constructor(game: Phaser.Game) {\n        this.game = game;\n        this.eventEmitter = new Phaser.Events.EventEmitter();\n    }\n\n    public static getInstance(game?: Phaser.Game): SceneManager {\n        if (!SceneManager.instance) {\n            if (!game) {\n                throw new Error('SceneManager must be initialized with a game instance');\n            }\n            SceneManager.instance = new SceneManager(game);\n        }\n        return SceneManager.instance;\n    }\n\n    public transitionTo(sceneName: string, data?: ISceneData): void {\n        if (this.transitionInProgress) {\n            console.warn('Scene transition already in progress');\n            return;\n        }\n\n        if (!this.game.scene.getScene(sceneName)) {\n            console.error(`Scene \"${sceneName}\" not found`);\n            return;\n        }\n\n        console.log(`SceneManager: Starting transition from ${this.currentScene} to ${sceneName}`);\n        this.transitionInProgress = true;\n        this.previousScene = this.currentScene;\n        \n        const currentSceneInstance = this.game.scene.getScene(this.currentScene);\n        \n        if (currentSceneInstance && currentSceneInstance.scene.isActive()) {\n            this.fadeOutScene(currentSceneInstance as Scene, () => {\n                this.switchScene(sceneName, data);\n            });\n        } else {\n            this.switchScene(sceneName, data);\n        }\n    }\n\n    private fadeOutScene(scene: Scene, callback: () => void): void {\n        const duration = 300;\n        \n        if (scene.cameras && scene.cameras.main) {\n            scene.cameras.main.fadeOut(duration, 0, 0, 0);\n            scene.cameras.main.once('camerafadeoutcomplete', callback);\n        } else {\n            callback();\n        }\n    }\n\n    private switchScene(sceneName: string, data?: ISceneData): void {\n        console.log(`SceneManager: Switching from ${this.currentScene} to ${sceneName}`);\n        \n        if (this.currentScene && this.currentScene !== '') {\n            console.log(`SceneManager: Stopping scene ${this.currentScene}`);\n            // First stop the scene\n            this.game.scene.stop(this.currentScene);\n        }\n\n        const sceneData = {\n            ...data,\n            transitionFrom: this.previousScene\n        };\n\n        console.log(`SceneManager: Starting ${sceneName}`);\n        this.game.scene.start(sceneName, sceneData);\n        \n        // Ensure new scene is on top\n        this.game.scene.bringToTop(sceneName);\n        \n        this.currentScene = sceneName;\n        \n        const newScene = this.game.scene.getScene(sceneName) as Scene;\n        if (newScene && newScene.cameras && newScene.cameras.main) {\n            newScene.cameras.main.fadeIn(300, 0, 0, 0);\n            newScene.cameras.main.once('camerafadeincomplete', () => {\n                console.log(`SceneManager: Transition to ${sceneName} complete`);\n                this.transitionInProgress = false;\n                this.eventEmitter.emit(GameEvents.SCENE_READY, {\n                    scene: sceneName,\n                    previousScene: this.previousScene\n                });\n            });\n        } else {\n            console.log(`SceneManager: Transition to ${sceneName} complete (no fade)`);\n            this.transitionInProgress = false;\n            this.eventEmitter.emit(GameEvents.SCENE_READY, {\n                scene: sceneName,\n                previousScene: this.previousScene\n            });\n        }\n    }\n\n    public getCurrentScene(): string {\n        return this.currentScene;\n    }\n\n    public getPreviousScene(): string {\n        return this.previousScene;\n    }\n\n    public isTransitioning(): boolean {\n        return this.transitionInProgress;\n    }\n\n    public restartCurrentScene(data?: ISceneData): void {\n        if (this.currentScene) {\n            const scene = this.game.scene.getScene(this.currentScene);\n            if (scene) {\n                this.game.scene.stop(this.currentScene);\n                this.game.scene.start(this.currentScene, data);\n            }\n        }\n    }\n\n    public pauseCurrentScene(): void {\n        if (this.currentScene) {\n            this.game.scene.pause(this.currentScene);\n        }\n    }\n\n    public resumeCurrentScene(): void {\n        if (this.currentScene) {\n            this.game.scene.resume(this.currentScene);\n        }\n    }\n\n    public launchParallelScene(sceneName: string, data?: ISceneData): void {\n        if (!this.game.scene.getScene(sceneName)) {\n            console.error(`Scene \"${sceneName}\" not found`);\n            return;\n        }\n\n        this.game.scene.run(sceneName, data);\n    }\n\n    public stopParallelScene(sceneName: string): void {\n        if (this.game.scene.isActive(sceneName)) {\n            this.game.scene.stop(sceneName);\n        }\n    }\n\n    public on(event: string, callback: (...args: any[]) => void): void {\n        this.eventEmitter.on(event, callback);\n    }\n\n    public off(event: string, callback: (...args: any[]) => void): void {\n        this.eventEmitter.off(event, callback);\n    }\n\n    public once(event: string, callback: (...args: any[]) => void): void {\n        this.eventEmitter.once(event, callback);\n    }\n\n    public setCurrentScene(sceneName: string): void {\n        this.currentScene = sceneName;\n    }\n}","import { IPerformanceMetrics, GameEvents } from '@/types/GameTypes';\n\nexport class PerformanceMonitor {\n    private fps: number = 60;\n    private frameTime: number = 0;\n    private lastTime: number = 0;\n    private deltaTime: number = 0;\n    private frameCount: number = 0;\n    private fpsUpdateInterval: number = 500;\n    private lastFpsUpdate: number = 0;\n    private frames: number[] = [];\n    private maxFrameSamples: number = 60;\n    private warningThreshold: number = 30;\n    private criticalThreshold: number = 20;\n    private consecutiveLowFrames: number = 0;\n    private eventEmitter: Phaser.Events.EventEmitter | null = null;\n\n    constructor() {\n        this.lastTime = performance.now();\n        this.lastFpsUpdate = this.lastTime;\n    }\n\n    public setEventEmitter(emitter: Phaser.Events.EventEmitter): void {\n        this.eventEmitter = emitter;\n    }\n\n    public update(time: number): void {\n        const currentTime = time || performance.now();\n        this.deltaTime = currentTime - this.lastTime;\n        \n        // Simple FPS calculation every 500ms\n        if (currentTime - this.lastFpsUpdate >= this.fpsUpdateInterval) {\n            this.fps = Math.round(1000 / Math.max(16.67, this.deltaTime));\n            this.lastFpsUpdate = currentTime;\n        }\n        \n        this.lastTime = currentTime;\n    }\n\n    public getFPS(): number {\n        return this.fps;\n    }\n\n    public getFrameTime(): number {\n        return this.frameTime;\n    }\n\n    public getDeltaTime(): number {\n        return this.deltaTime;\n    }\n\n    public getMetrics(): IPerformanceMetrics {\n        return {\n            fps: this.fps,\n            frameTime: this.frameTime,\n            deltaTime: this.deltaTime,\n            drawCalls: 0,\n            memoryUsage: this.getMemoryUsage()\n        };\n    }\n\n    public shouldReduceQuality(): boolean {\n        const avgFps = this.getAverageFPS();\n        return avgFps < this.warningThreshold && this.consecutiveLowFrames > 5;\n    }\n\n    public shouldIncreaseQuality(): boolean {\n        const avgFps = this.getAverageFPS();\n        return avgFps >= 58 && this.consecutiveLowFrames === 0;\n    }\n\n    private getAverageFPS(): number {\n        if (this.frames.length === 0) return 60;\n        const avgFrameTime = this.frames.reduce((a, b) => a + b, 0) / this.frames.length;\n        return Math.round(1000 / avgFrameTime);\n    }\n\n    private getMemoryUsage(): number | undefined {\n        if ('memory' in performance) {\n            const memory = (performance as any).memory;\n            if (memory && memory.usedJSHeapSize) {\n                return Math.round(memory.usedJSHeapSize / 1048576);\n            }\n        }\n        return undefined;\n    }\n\n    public reset(): void {\n        this.fps = 60;\n        this.frameTime = 0;\n        this.lastTime = performance.now();\n        this.deltaTime = 0;\n        this.frameCount = 0;\n        this.lastFpsUpdate = this.lastTime;\n        this.frames = [];\n        this.consecutiveLowFrames = 0;\n    }\n\n    public getPerformanceScore(): number {\n        const avgFps = this.getAverageFPS();\n        const score = Math.min(100, (avgFps / 60) * 100);\n        return Math.round(score);\n    }\n\n    public logMetrics(): void {\n        const metrics = this.getMetrics();\n        console.log(\n            `FPS: ${metrics.fps} | ` +\n            `Frame Time: ${metrics.frameTime.toFixed(2)}ms | ` +\n            `Memory: ${metrics.memoryUsage || 'N/A'}MB | ` \n          // `Score: ${this.getPerformanceScore()}%`\n        );\n    }\n}","import { Scene } from 'phaser';\nimport { SceneKeys, ISceneData } from '@/types/GameTypes';\nimport { SceneManager } from '@systems/core/SceneManager';\nimport { DeviceDetection } from '@utils/DeviceDetection';\nimport { PerformanceMonitor } from '@utils/PerformanceMonitor';\nimport { GAME_CONSTANTS, HD_SCALE } from '@config/GameConfig';\n\nexport class BootScene extends Scene {\n    private sceneManager!: SceneManager;\n    private deviceDetection!: DeviceDetection;\n    private performanceMonitor!: PerformanceMonitor;\n\n    constructor() {\n        super({ key: SceneKeys.BOOT });\n    }\n\n    public init(_data: ISceneData): void {\n        console.log('BootScene: Initializing game systems...');\n        \n        this.deviceDetection = DeviceDetection.getInstance();\n        this.performanceMonitor = new PerformanceMonitor();\n        this.sceneManager = SceneManager.getInstance(this.game);\n        \n        this.performanceMonitor.setEventEmitter(this.game.events);\n        \n        this.setupDeviceListeners();\n        this.checkDeviceCapabilities();\n    }\n\n    public preload(): void {\n        const loadingText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            'Initializing...',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: `${12 * HD_SCALE}px`,\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        const progressBar = this.add.graphics();\n        const progressBox = this.add.graphics();\n        const width = 160 * HD_SCALE;\n        const height = 25 * HD_SCALE;\n        const x = this.cameras.main.centerX - width / 2;\n        const y = this.cameras.main.centerY + (20 * HD_SCALE);\n\n        progressBox.fillStyle(0x222222, 0.8);\n        progressBox.fillRect(x, y, width, height);\n\n        this.load.on('progress', (value: number) => {\n            progressBar.clear();\n            progressBar.fillStyle(0xffffff, 1);\n            progressBar.fillRect(x + (5 * HD_SCALE), y + (5 * HD_SCALE), (width - (10 * HD_SCALE)) * value, height - (10 * HD_SCALE));\n        });\n\n        this.load.on('complete', () => {\n            progressBar.destroy();\n            progressBox.destroy();\n            loadingText.destroy();\n        });\n    }\n\n    public create(): void {\n        console.log('BootScene: System initialization complete');\n        \n        const capabilities = this.deviceDetection.getCapabilities();\n        console.log('Device Capabilities:', capabilities);\n        \n        const qualityPreset = this.deviceDetection.getQualityPreset();\n        console.log(`Quality Preset: ${qualityPreset}`);\n        \n        this.setupGlobalEventListeners();\n        \n        // Set current scene first\n        this.sceneManager.setCurrentScene(SceneKeys.BOOT);\n        \n        // Then transition to PreloadScene\n        console.log('BootScene: About to transition to PRELOAD');\n        console.log('BootScene: SceneManager instance exists:', !!this.sceneManager);\n        console.log('BootScene: Available scenes:', this.game.scene.keys);\n        \n        try {\n            this.sceneManager.transitionTo(SceneKeys.PRELOAD);\n            console.log('BootScene: Transition to PRELOAD initiated successfully');\n        } catch (error) {\n            console.error('BootScene: Error transitioning to PRELOAD:', error);\n            // Fallback to direct scene start\n            this.scene.start(SceneKeys.PRELOAD);\n        }\n    }\n\n    public override update(time: number, _delta: number): void {\n        this.performanceMonitor.update(time);\n    }\n\n    private setupDeviceListeners(): void {\n        window.addEventListener('resize', () => {\n            this.deviceDetection.updateOrientation();\n            this.handleOrientationChange();\n        });\n\n        window.addEventListener('orientationchange', () => {\n            this.deviceDetection.updateOrientation();\n            this.handleOrientationChange();\n        });\n\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                this.handleGamePause();\n            } else {\n                this.handleGameResume();\n            }\n        });\n    }\n\n    private checkDeviceCapabilities(): void {\n        const capabilities = this.deviceDetection.getCapabilities();\n        \n        if (!capabilities.hasWebGL) {\n            console.error('WebGL not supported on this device');\n            this.showErrorMessage('WebGL is required to play this game');\n            return;\n        }\n\n        if (capabilities.isLandscape && capabilities.isMobile) {\n            console.warn('Device is in landscape mode');\n        }\n\n        if (capabilities.maxTextureSize < 2048) {\n            console.warn('Device has limited texture size support');\n        }\n    }\n\n    private handleOrientationChange(): void {\n        const capabilities = this.deviceDetection.getCapabilities();\n        \n        if (capabilities.isMobile && capabilities.isLandscape) {\n            console.log('Please rotate device to portrait mode');\n        }\n        \n        const width = Math.min(capabilities.screenWidth, GAME_CONSTANTS.MAX_WIDTH);\n        const height = Math.min(capabilities.screenHeight, GAME_CONSTANTS.MAX_HEIGHT);\n        \n        this.scale.resize(width, height);\n    }\n\n    private handleGamePause(): void {\n        console.log('Game paused (tab inactive)');\n        this.sceneManager.pauseCurrentScene();\n        this.sound.pauseAll();\n    }\n\n    private handleGameResume(): void {\n        console.log('Game resumed (tab active)');\n        this.sceneManager.resumeCurrentScene();\n        this.sound.resumeAll();\n    }\n\n    private setupGlobalEventListeners(): void {\n        this.game.events.on('performance-warning', (data: { fps: number; severity: string }) => {\n            console.warn(`Performance warning: FPS ${data.fps} (${data.severity})`);\n            \n            if (data.severity === 'critical') {\n                this.handleCriticalPerformance();\n            }\n        });\n\n        this.game.events.on('scene-ready', (data: { scene: string; previousScene: string }) => {\n            console.log(`Scene ready: ${data.scene} (from ${data.previousScene})`);\n        });\n    }\n\n    private handleCriticalPerformance(): void {\n        console.error('Critical performance issue detected');\n    }\n\n    private showErrorMessage(message: string): void {\n        const errorText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            message,\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: `${10 * HD_SCALE}px`,\n                color: '#ff0000',\n                align: 'center',\n                wordWrap: { width: 150 * HD_SCALE }\n            }\n        ).setOrigin(0.5);\n\n        this.add.rectangle(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            errorText.width + (20 * HD_SCALE),\n            errorText.height + (20 * HD_SCALE),\n            0x000000,\n            0.8\n        ).setOrigin(0.5);\n\n        errorText.setDepth(1);\n    }\n}","import { IAssetManifest, IAssetManifestItem } from '@/types/GameTypes';\n\nexport const ASSET_KEYS = {\n    IMAGES: {\n        LOGO: 'logo',\n        BUBBLE: 'bubble',\n        BACKGROUND: 'background',\n        BUTTON: 'button',\n        PARTICLE: 'particle',\n        PLANET: 'planet',\n        BUBBLE_PLANET: 'bubble_planet',\n        UFO: 'ufo'\n    },\n    AUDIO: {\n        BUBBLE_SHOOT: 'bubble-shoot',\n        BUBBLE_ATTACH: 'bubble-attach',\n        BUBBLES_DROP: 'bubbles-drop',\n        COMBO_3: 'combo-3',\n        COMBO_4: 'combo-4',\n        COMBO_5_PLUS: 'combo-5-plus',\n        COMBO_CELEBRATION: 'combo-celebration',\n        ARSENAL_PICKUP: 'arsenal-pickup',\n        SUCCESS_OBJECTIVE: 'success-objective',\n        VICTORY: 'victory',\n        UFO_SOUND: 'ufo-sound',\n        UFO_ARRIVES: 'ufo-arrives',\n        CHEST_ARRIVAL: 'chest-arrival',\n        DEFEAT: 'defeat',\n        BACKGROUND_MUSIC: 'background-music'\n    },\n    ATLASES: {\n        UI: 'ui_atlas',\n        BUBBLES: 'bubbles_atlas',\n        EFFECTS: 'effects_atlas'\n    },\n    JSON: {\n        LEVELS: 'levels',\n        PARTICLE_CONFIGS: 'particle_configs',\n        LOCALIZATION: 'localization'\n    }\n};\n\nexport function createAssetManifest(): IAssetManifest {\n    const manifest: IAssetManifest = {\n        images: [\n            {\n                key: ASSET_KEYS.IMAGES.LOGO,\n                url: 'assets/images/logo-placeholder.png',\n                type: 'image',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.IMAGES.BACKGROUND,\n                url: 'assets/images/background-placeholder.png',\n                type: 'image',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.IMAGES.PLANET,\n                url: 'assets/sprites/planeta.png',\n                type: 'image',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.IMAGES.UFO,\n                url: 'assets/sprites/ufo.png',\n                type: 'image',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.IMAGES.BUBBLE_PLANET,\n                url: 'assets/sprites/bubble_planet.png',\n                type: 'image',\n                data: {}\n            }\n        ],\n        audio: [\n            {\n                key: ASSET_KEYS.AUDIO.BUBBLE_SHOOT,\n                url: 'assets/sounds/bubble-shoot.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.BUBBLE_ATTACH,\n                url: 'assets/sounds/bubbles-attach.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.BUBBLES_DROP,\n                url: 'assets/sounds/bubbles-drop.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.COMBO_3,\n                url: 'assets/sounds/combo-3.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.COMBO_4,\n                url: 'assets/sounds/combo-4.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.COMBO_5_PLUS,\n                url: 'assets/sounds/combo-5-plus.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.COMBO_CELEBRATION,\n                url: 'assets/sounds/combo-celebration.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.ARSENAL_PICKUP,\n                url: 'assets/sounds/arsenal-pickup.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.SUCCESS_OBJECTIVE,\n                url: 'assets/sounds/success-objective.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.VICTORY,\n                url: 'assets/sounds/victory.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.UFO_SOUND,\n                url: 'assets/audio/ufo-sound.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.UFO_ARRIVES,\n                url: 'assets/audio/ufo-arrives.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.CHEST_ARRIVAL,\n                url: 'assets/audio/chest-arrival.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.DEFEAT,\n                url: 'assets/sounds/defeat.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.BACKGROUND_MUSIC,\n                url: 'assets/sounds/background-music.mp3',\n                type: 'audio',\n                data: {}\n            }\n        ],\n        atlases: [],\n        json: []\n    };\n\n    return manifest;\n}\n\nexport class AssetLoader {\n    private scene: Phaser.Scene;\n    private manifest: IAssetManifest;\n    private loadedCount: number = 0;\n    private totalCount: number = 0;\n\n    constructor(scene: Phaser.Scene) {\n        this.scene = scene;\n        this.manifest = createAssetManifest();\n        this.calculateTotalAssets();\n    }\n\n    private calculateTotalAssets(): void {\n        this.totalCount = \n            this.manifest.images.length +\n            this.manifest.audio.length +\n            this.manifest.atlases.length +\n            this.manifest.json.length;\n    }\n\n    public loadAssets(onProgress?: (progress: number) => void): void {\n        if (onProgress) {\n            this.scene.load.on('progress', (value: number) => {\n                onProgress(value);\n            });\n        }\n\n        this.scene.load.on('fileprogress', (file: Phaser.Loader.File) => {\n            console.log(`Loading: ${file.key}`);\n        });\n\n        this.loadImages();\n        this.loadAudio();\n        this.loadAtlases();\n        this.loadJSON();\n\n        this.scene.load.on('complete', () => {\n            console.log('All assets loaded');\n        });\n    }\n\n    private loadImages(): void {\n        this.manifest.images.forEach((item: IAssetManifestItem) => {\n            if (this.scene.textures.exists(item.key)) {\n                console.log(`Image ${item.key} already loaded`);\n                return;\n            }\n            this.scene.load.image(item.key, item.url);\n        });\n    }\n\n    private loadAudio(): void {\n        this.manifest.audio.forEach((item: IAssetManifestItem) => {\n            if (this.scene.cache.audio.exists(item.key)) {\n                console.log(`Audio ${item.key} already loaded`);\n                return;\n            }\n            this.scene.load.audio(item.key, item.url);\n        });\n    }\n\n    private loadAtlases(): void {\n        this.manifest.atlases.forEach((item: IAssetManifestItem) => {\n            if (this.scene.textures.exists(item.key)) {\n                console.log(`Atlas ${item.key} already loaded`);\n                return;\n            }\n            const jsonUrl = item.url.replace('.png', '.json');\n            this.scene.load.atlas(item.key, item.url, jsonUrl);\n        });\n    }\n\n    private loadJSON(): void {\n        this.manifest.json.forEach((item: IAssetManifestItem) => {\n            if (this.scene.cache.json.exists(item.key)) {\n                console.log(`JSON ${item.key} already loaded`);\n                return;\n            }\n            this.scene.load.json(item.key, item.url);\n        });\n    }\n\n    public getProgress(): number {\n        return this.loadedCount / Math.max(1, this.totalCount);\n    }\n\n    public getTotalAssets(): number {\n        return this.totalCount;\n    }\n\n    public getLoadedAssets(): number {\n        return this.loadedCount;\n    }\n}","import { Scene } from 'phaser';\nimport { SceneKeys, ISceneData, GameEvents } from '@/types/GameTypes';\nimport { SceneManager } from '@systems/core/SceneManager';\nimport { AssetLoader, ASSET_KEYS } from '@config/AssetManifest';\nimport { GAME_CONSTANTS } from '@config/GameConfig';\nimport { PerformanceMonitor } from '@utils/PerformanceMonitor';\n\nexport class PreloadScene extends Scene {\n    private sceneManager!: SceneManager;\n    private assetLoader!: AssetLoader;\n    private performanceMonitor!: PerformanceMonitor;\n    private loadingText!: Phaser.GameObjects.Text;\n    private progressBar!: Phaser.GameObjects.Graphics;\n    private progressBox!: Phaser.GameObjects.Graphics;\n    private percentText!: Phaser.GameObjects.Text;\n    private assetText!: Phaser.GameObjects.Text;\n\n    constructor() {\n        super({ key: SceneKeys.PRELOAD });\n    }\n\n    public init(_data: ISceneData): void {\n        console.log('PreloadScene: Starting asset loading...');\n        this.sceneManager = SceneManager.getInstance();\n        this.performanceMonitor = new PerformanceMonitor();\n        this.assetLoader = new AssetLoader(this);\n    }\n\n    public preload(): void {\n        this.createLoadingUI();\n        this.setupLoadingListeners();\n        \n        this.createPlaceholderAssets();\n        \n        this.assetLoader.loadAssets((progress: number) => {\n            this.updateProgress(progress);\n        });\n    }\n\n    public create(): void {\n        console.log('PreloadScene: All assets loaded');\n        \n        this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY + 100,\n            'Assets Loaded!',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '20px',\n                color: GAME_CONSTANTS.COLORS.UI_SUCCESS,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        this.cleanupLoadingUI();\n\n        // Wait a moment before transitioning\n        this.time.delayedCall(500, () => {\n            console.log('PreloadScene: Transitioning to MenuScene');\n            this.game.events.emit(GameEvents.LOADING_COMPLETE);\n            this.sceneManager.setCurrentScene(SceneKeys.PRELOAD);\n            this.sceneManager.transitionTo(SceneKeys.MENU);\n            console.log('PreloadScene: MenuScene transition initiated');\n        });\n    }\n\n    public override update(time: number, _delta: number): void {\n        this.performanceMonitor.update(time);\n    }\n\n    private createLoadingUI(): void {\n        const centerX = this.cameras.main.centerX;\n        const centerY = this.cameras.main.centerY;\n\n        this.add.text(\n            centerX,\n            centerY - 100,\n            'Bubble Battle Royale',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '32px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        this.loadingText = this.add.text(\n            centerX,\n            centerY - 40,\n            'Loading...',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '20px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        const progressBarWidth = 320;\n        const progressBarHeight = 50;\n        const progressBarX = centerX - progressBarWidth / 2;\n        const progressBarY = centerY;\n\n        this.progressBox = this.add.graphics();\n        this.progressBox.fillStyle(0x222222, 0.8);\n        this.progressBox.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);\n\n        this.progressBar = this.add.graphics();\n\n        this.percentText = this.add.text(\n            centerX,\n            centerY + 25,\n            '0%',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '18px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        this.assetText = this.add.text(\n            centerX,\n            centerY + 70,\n            '',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '14px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        this.createLoadingAnimation();\n    }\n\n    private createLoadingAnimation(): void {\n        const bubbleColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];\n        const bubbles: Phaser.GameObjects.Arc[] = [];\n        const centerX = this.cameras.main.centerX;\n        const centerY = this.cameras.main.centerY + 150;\n        const spacing = 40;\n\n        for (let i = 0; i < 5; i++) {\n            const bubble = this.add.circle(\n                centerX + (i - 2) * spacing,\n                centerY,\n                15,\n                bubbleColors[i],\n                1\n            );\n            bubbles.push(bubble);\n\n            this.tweens.add({\n                targets: bubble,\n                y: centerY - 20,\n                duration: 500,\n                ease: 'Sine.easeInOut',\n                yoyo: true,\n                repeat: -1,\n                delay: i * 100\n            });\n        }\n    }\n\n    private setupLoadingListeners(): void {\n        this.load.on('progress', (value: number) => {\n            this.updateProgress(value);\n        });\n\n        this.load.on('fileprogress', (file: Phaser.Loader.File) => {\n            this.assetText.setText(`Loading: ${file.key}`);\n        });\n\n        this.load.on('complete', () => {\n            console.log('Asset loading complete');\n            this.assetText.setText('Complete!');\n        });\n\n        this.load.on('loaderror', (file: Phaser.Loader.File) => {\n            console.error(`Failed to load: ${file.key}`);\n            this.assetText.setText(`Error loading: ${file.key}`);\n        });\n    }\n\n    private updateProgress(value: number): void {\n        const percent = Math.floor(value * 100);\n        this.percentText.setText(`${percent}%`);\n\n        this.progressBar.clear();\n        this.progressBar.fillStyle(0xffffff, 1);\n        \n        const progressBarWidth = 320;\n        const progressBarHeight = 50;\n        const centerX = this.cameras.main.centerX;\n        const centerY = this.cameras.main.centerY;\n        const progressBarX = centerX - progressBarWidth / 2;\n        const progressBarY = centerY;\n        \n        this.progressBar.fillRect(\n            progressBarX + 10,\n            progressBarY + 10,\n            (progressBarWidth - 20) * value,\n            progressBarHeight - 20\n        );\n\n        if (value >= 0.5) {\n            this.loadingText.setText('Loading Assets...');\n        }\n        if (value >= 0.8) {\n            this.loadingText.setText('Almost Ready...');\n        }\n    }\n\n    private createPlaceholderAssets(): void {\n        const graphics = this.make.graphics({ x: 0, y: 0 });\n        \n        graphics.fillStyle(0x3498db, 1);\n        graphics.fillCircle(32, 32, 32);\n        graphics.generateTexture(ASSET_KEYS.IMAGES.LOGO, 64, 64);\n        \n        graphics.clear();\n        graphics.fillStyle(0x2c3e50, 1);\n        graphics.fillRect(0, 0, this.cameras.main.width, this.cameras.main.height);\n        graphics.generateTexture(ASSET_KEYS.IMAGES.BACKGROUND, this.cameras.main.width, this.cameras.main.height);\n        \n        // Create particle texture\n        graphics.clear();\n        graphics.fillStyle(0xffffff, 1);\n        graphics.fillCircle(8, 8, 8);\n        graphics.generateTexture('particle', 16, 16);\n        \n        graphics.destroy();\n    }\n\n    private cleanupLoadingUI(): void {\n        if (this.progressBar) {\n            this.progressBar.destroy();\n        }\n        if (this.progressBox) {\n            this.progressBox.destroy();\n        }\n        if (this.percentText) {\n            this.percentText.destroy();\n        }\n        if (this.loadingText) {\n            this.loadingText.setText('Ready!');\n        }\n    }\n}","import { Scene } from 'phaser';\nimport { SceneKeys, ISceneData } from '@/types/GameTypes';\nimport { SceneManager } from '@systems/core/SceneManager';\nimport { GAME_CONSTANTS } from '@config/GameConfig';\nimport { ASSET_KEYS } from '@config/AssetManifest';\nimport { PerformanceMonitor } from '@utils/PerformanceMonitor';\n\nexport class MenuScene extends Scene {\n    private sceneManager!: SceneManager;\n    private performanceMonitor!: PerformanceMonitor;\n    private buttons: Phaser.GameObjects.Container[] = [];\n    private titleText!: Phaser.GameObjects.Text;\n    private versionText!: Phaser.GameObjects.Text;\n    private fpsText!: Phaser.GameObjects.Text;\n\n    constructor() {\n        super({ key: SceneKeys.MENU });\n    }\n\n    public init(_data: ISceneData): void {\n        console.log('MenuScene: Initializing main menu...');\n        this.sceneManager = SceneManager.getInstance();\n        this.sceneManager.setCurrentScene(SceneKeys.MENU);\n        this.performanceMonitor = new PerformanceMonitor();\n        if (this.game && this.game.events) {\n            this.performanceMonitor.setEventEmitter(this.game.events);\n        }\n    }\n\n    public create(): void {\n        // Debug: Check actual game FPS settings\n        console.log('MenuScene: create() called');\n        console.log('Game FPS Target:', this.game.config.fps);\n        console.log('Game Loop Type:', this.game.loop?.type);\n        console.log('Game Loop Target FPS:', this.game.loop?.targetFps);\n        console.log('Game Loop Actual FPS:', this.game.loop?.actualFps);\n        \n        this.createBackground();\n        this.createTitle();\n        this.createMenuButtons();\n        this.createVersionInfo();\n        this.createFPSDisplay();\n        this.addAnimations();\n    }\n\n    public override update(_time: number, _delta: number): void {\n        // Update FPS display once per second instead of every frame\n        // Check that time exists before accessing it\n        if (this.fpsText && this.time && this.time.now % 1000 < 16) {\n            const fps = Math.round(this.game.loop.actualFps);\n            this.fpsText.setText(`FPS: ${fps}`);\n            \n            // Simple color update\n            if (fps < 30) {\n                this.fpsText.setTint(0xff0000);\n            } else if (fps < 50) {\n                this.fpsText.setTint(0xffff00);\n            } else {\n                this.fpsText.setTint(0x00ff00);\n            }\n        }\n    }\n\n    private createBackground(): void {\n        const bg = this.add.image(0, 0, ASSET_KEYS.IMAGES.BACKGROUND);\n        bg.setOrigin(0, 0);\n        bg.setDisplaySize(this.cameras.main.width, this.cameras.main.height);\n        bg.setTint(0x1a1a2e);\n\n        for (let i = 0; i < 20; i++) {\n            const bubble = this.add.circle(\n                Phaser.Math.Between(0, this.cameras.main.width),\n                Phaser.Math.Between(0, this.cameras.main.height),\n                Phaser.Math.Between(10, 30),\n                Phaser.Math.Between(0x3498db, 0x9b59b6),\n                0.2\n            );\n\n            this.tweens.add({\n                targets: bubble,\n                y: bubble.y - Phaser.Math.Between(50, 150),\n                x: bubble.x + Phaser.Math.Between(-30, 30),\n                alpha: 0,\n                duration: Phaser.Math.Between(3000, 6000),\n                ease: 'Sine.easeOut',\n                repeat: -1,\n                delay: Phaser.Math.Between(0, 3000)\n            });\n        }\n    }\n\n    private createTitle(): void {\n        this.titleText = this.add.text(\n            this.cameras.main.centerX,\n            100,\n            'Bubble Battle\\nRoyale',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '42px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center',\n                stroke: '#000000',\n                strokeThickness: 4\n            }\n        ).setOrigin(0.5);\n\n        this.tweens.add({\n            targets: this.titleText,\n            scaleX: 1.05,\n            scaleY: 1.05,\n            duration: 2000,\n            ease: 'Sine.easeInOut',\n            yoyo: true,\n            repeat: -1\n        });\n    }\n\n    private createMenuButtons(): void {\n        const buttonData = [\n            { text: 'PLAY', action: () => this.startGame() },\n            { text: 'PRACTICE', action: () => this.startPractice() },\n            { text: 'SETTINGS', action: () => this.openSettings() },\n            { text: 'ABOUT', action: () => this.showAbout() }\n        ];\n\n        const startY = 250;\n        const spacing = 70;\n\n        buttonData.forEach((data, index) => {\n            const button = this.createButton(\n                this.cameras.main.centerX,\n                startY + (index * spacing),\n                data.text,\n                data.action\n            );\n            this.buttons.push(button);\n\n            button.setAlpha(0);\n            button.setScale(0.8);\n            \n            this.tweens.add({\n                targets: button,\n                alpha: 1,\n                scaleX: 1,\n                scaleY: 1,\n                duration: 500,\n                ease: 'Back.easeOut',\n                delay: 100 + (index * 100)\n            });\n        });\n    }\n\n    private createButton(x: number, y: number, text: string, callback: () => void): Phaser.GameObjects.Container {\n        const container = this.add.container(x, y);\n\n        const bg = this.add.rectangle(0, 0, 250, 50, 0x3498db, 1);\n        bg.setStrokeStyle(2, 0xffffff, 1);\n        bg.setInteractive({ useHandCursor: true });\n\n        const buttonText = this.add.text(0, 0, text, {\n            fontFamily: 'Arial, sans-serif',\n            fontSize: '20px',\n            color: GAME_CONSTANTS.COLORS.UI_TEXT,\n            align: 'center'\n        }).setOrigin(0.5);\n\n        container.add([bg, buttonText]);\n\n        bg.on('pointerover', () => {\n            bg.setFillStyle(0x5dade2);\n            this.tweens.add({\n                targets: container,\n                scaleX: 1.1,\n                scaleY: 1.1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n\n        bg.on('pointerout', () => {\n            bg.setFillStyle(0x3498db);\n            this.tweens.add({\n                targets: container,\n                scaleX: 1,\n                scaleY: 1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n\n        bg.on('pointerdown', () => {\n            container.setScale(0.95);\n        });\n\n        bg.on('pointerup', () => {\n            container.setScale(1);\n            callback();\n        });\n\n        return container;\n    }\n\n    private createVersionInfo(): void {\n        this.versionText = this.add.text(\n            10,\n            this.cameras.main.height - 30,\n            'v1.0.0 - Development Build',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '12px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT\n            }\n        ).setOrigin(0, 0.5).setAlpha(0.5);\n    }\n\n    private createFPSDisplay(): void {\n        this.fpsText = this.add.text(\n            this.cameras.main.width - 10,\n            10,\n            'FPS: 60',\n            {\n                fontFamily: 'monospace',\n                fontSize: '14px',\n                color: '#00ff00'\n            }\n        ).setOrigin(1, 0);\n    }\n\n    private addAnimations(): void {\n        this.add.particles(0, 0, ASSET_KEYS.IMAGES.LOGO, {\n            x: { min: 0, max: this.cameras.main.width },\n            y: this.cameras.main.height + 50,\n            lifespan: 8000,\n            speedY: { min: -100, max: -50 },\n            scale: { start: 0.1, end: 0 },\n            quantity: 1,\n            frequency: 2000,\n            alpha: { start: 0.3, end: 0 },\n            tint: [0x3498db, 0x9b59b6, 0xe74c3c, 0xf39c12]\n        });\n    }\n\n    private startGame(): void {\n        console.log('Opening theme selection...');\n        this.tweens.add({\n            targets: this.buttons,\n            alpha: 0,\n            duration: 300,\n            onComplete: () => {\n                this.sceneManager.transitionTo(SceneKeys.THEME_SELECT);\n            }\n        });\n    }\n\n    private startPractice(): void {\n        console.log('Starting practice mode...');\n        this.showMessage('Practice Mode Coming Soon!');\n    }\n\n    private openSettings(): void {\n        console.log('Opening settings...');\n        this.showMessage('Settings Coming Soon!');\n    }\n\n    private showAbout(): void {\n        console.log('Showing about...');\n        this.showMessage('Bubble Battle Royale\\nBuilt with Phaser 3 & TypeScript\\n\\nA competitive bubble shooter game!');\n    }\n\n    private showMessage(text: string): void {\n        const overlay = this.add.rectangle(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            this.cameras.main.width,\n            this.cameras.main.height,\n            0x000000,\n            0.7\n        );\n\n        const messageBox = this.add.rectangle(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            400,\n            200,\n            0x2c3e50,\n            1\n        );\n        messageBox.setStrokeStyle(2, 0xffffff);\n\n        const messageText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY - 30,\n            text,\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '18px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center',\n                wordWrap: { width: 350 }\n            }\n        ).setOrigin(0.5);\n\n        const closeButton = this.createButton(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY + 60,\n            'CLOSE',\n            () => {\n                overlay.destroy();\n                messageBox.destroy();\n                messageText.destroy();\n                closeButton.destroy();\n            }\n        );\n\n        overlay.setInteractive();\n        overlay.on('pointerdown', () => {\n            overlay.destroy();\n            messageBox.destroy();\n            messageText.destroy();\n            closeButton.destroy();\n        });\n    }\n}","/**\n * BackgroundSystem - Premium Visual Background with Best UX/UI Practices\n * Features:\n * - Dynamic gradient backgrounds with smooth transitions\n * - Parallax layers for depth\n * - Ambient particle effects\n * - Performance optimized for mobile\n * - Non-intrusive design that enhances gameplay\n */\n\nimport { Scene } from 'phaser';\nimport { HD_SCALE } from '@/config/GameConfig';\n\ninterface IBackgroundConfig {\n    theme?: 'ocean' | 'sunset' | 'forest' | 'space' | 'aurora';\n    quality?: 'low' | 'medium' | 'high' | 'ultra';\n    enableParticles?: boolean;\n    enableAnimation?: boolean;\n}\n\nexport class BackgroundSystem {\n    private scene: Scene;\n    private config: IBackgroundConfig;\n    \n    // Gradient layers\n    private gradientGraphics!: Phaser.GameObjects.Graphics;\n    private gradientTexture?: Phaser.Textures.CanvasTexture;\n    \n    // Parallax elements\n    private parallaxLayers: Phaser.GameObjects.Container[] = [];\n    \n    // Particle effects\n    private particleEmitters: Phaser.GameObjects.Particles.ParticleEmitter[] = [];\n    \n    // Ambient elements\n    private ambientElements: Phaser.GameObjects.GameObject[] = [];\n    \n    // Animation timers\n    private animationTimers: Phaser.Time.TimerEvent[] = [];\n    \n    // Color schemes for different themes with unique particle types\n    private readonly themes = {\n        ocean: {\n            colors: [0x001a33, 0x003366, 0x004d99, 0x0066cc],\n            accent: 0x00ccff,\n            particles: 0x66ddff,\n            name: 'Ocean Depths',\n            particleType: 'bubbles' as const,\n            secondaryParticles: 0x99eeff\n        },\n        sunset: {\n            colors: [0x1a0033, 0x330066, 0x660099, 0x9900cc],\n            accent: 0xff6600,\n            particles: 0xffaa00,\n            name: 'Twilight',\n            particleType: 'fireflies' as const,\n            secondaryParticles: 0xffcc66\n        },\n        forest: {\n            colors: [0x001a00, 0x003300, 0x004d00, 0x006600],\n            accent: 0x00ff00,\n            particles: 0x44aa44, // More visible green\n            name: 'Mystic Forest',\n            particleType: 'leaves' as const,\n            secondaryParticles: 0x66dd66 // Brighter leaves\n        },\n        space: {\n            colors: [0x000011, 0x000022, 0x000033, 0x000044],\n            accent: 0x9966ff,\n            particles: 0xffffff,\n            name: 'Deep Space',\n            particleType: 'stars' as const,\n            secondaryParticles: 0xaabbff\n        },\n        aurora: {\n            colors: [0x001122, 0x002244, 0x003366, 0x004488],\n            accent: 0x00ff99,\n            particles: 0x00ffaa, // Bright aurora green\n            name: 'Northern Lights',\n            particleType: 'aurora' as const,\n            secondaryParticles: 0xaaffff // Bright cyan\n        }\n    };\n    \n    private currentTheme: typeof this.themes.ocean;\n    private width: number;\n    private height: number;\n\n    constructor(scene: Scene, config: IBackgroundConfig = {}) {\n        this.scene = scene;\n        this.config = {\n            theme: config.theme || 'ocean',\n            quality: config.quality || 'high',\n            enableParticles: config.enableParticles !== false,\n            enableAnimation: config.enableAnimation !== false\n        };\n        \n        this.currentTheme = this.themes[this.config.theme!];\n        this.width = scene.cameras.main.width;\n        this.height = scene.cameras.main.height;\n        \n        this.create();\n    }\n\n    private create(): void {\n        // Create gradient background\n        this.createGradientBackground();\n        \n        // Add parallax layers based on quality\n        if (this.config.quality !== 'low') {\n            this.createParallaxLayers();\n        }\n        \n        // Add ambient particles\n        if (this.config.enableParticles && this.config.quality !== 'low') {\n            this.createAmbientParticles();\n        }\n        \n        // Add animated elements for high quality, or always for space theme\n        if ((this.config.quality === 'high' || this.config.quality === 'ultra') || \n            this.currentTheme.particleType === 'stars') {\n            this.createAnimatedElements();\n        }\n        \n        // Start animations if enabled\n        if (this.config.enableAnimation) {\n            this.startAnimations();\n        }\n    }\n\n    private createGradientBackground(): void {\n        this.gradientGraphics = this.scene.add.graphics();\n        \n        // Create smooth vertical gradient\n        const colors = this.currentTheme.colors;\n        const gradientHeight = this.height / (colors.length - 1);\n        \n        for (let i = 0; i < colors.length - 1; i++) {\n            const color1 = colors[i];\n            const color2 = colors[i + 1];\n            \n            // Create gradient between two colors\n            for (let y = 0; y < gradientHeight; y++) {\n                const ratio = y / gradientHeight;\n                const blendedColor = this.blendColors(color1, color2, ratio);\n                \n                this.gradientGraphics.fillStyle(blendedColor, 1);\n                this.gradientGraphics.fillRect(\n                    0,\n                    i * gradientHeight + y,\n                    this.width,\n                    1\n                );\n            }\n        }\n        \n        // Add subtle noise texture for depth (ultra quality)\n        if (this.config.quality === 'ultra') {\n            this.addNoiseTexture();\n        }\n        \n        // Set as background (behind everything)\n        this.gradientGraphics.setDepth(-1000);\n    }\n\n    private createParallaxLayers(): void {\n        // Create theme-specific background elements instead of geometric shapes\n        const layerCount = this.config.quality === 'ultra' ? 3 : 2;\n        \n        for (let i = 0; i < layerCount; i++) {\n            const layer = this.scene.add.container(0, 0);\n            layer.setDepth(-900 + i * 10);\n            \n            // Add theme-specific elements\n            const elementCount = this.config.quality === 'ultra' ? 6 : 3;\n            for (let j = 0; j < elementCount; j++) {\n                const element = this.createThemeElement(i);\n                if (element) {\n                    element.x = Phaser.Math.Between(0, this.width);\n                    element.y = Phaser.Math.Between(0, this.height);\n                    layer.add(element);\n                }\n            }\n            \n            this.parallaxLayers.push(layer);\n        }\n    }\n\n    private createThemeElement(layerIndex: number): Phaser.GameObjects.GameObject | null {\n        const alpha = 0.02 + layerIndex * 0.015; // Very subtle\n        const scale = 0.5 + layerIndex * 0.3;\n        \n        switch (this.currentTheme.particleType) {\n            case 'bubbles':\n                // Ocean theme - create subtle water bubbles\n                const bubble = this.scene.add.circle(\n                    0, 0,\n                    Phaser.Math.Between(20, 40) * HD_SCALE * scale,\n                    this.currentTheme.secondaryParticles,\n                    alpha\n                );\n                bubble.setStrokeStyle(1, this.currentTheme.particles, alpha * 2);\n                return bubble;\n                \n            case 'fireflies':\n                // Sunset theme - create glowing orbs\n                const firefly = this.scene.add.circle(\n                    0, 0,\n                    Phaser.Math.Between(3, 8) * HD_SCALE * scale,\n                    this.currentTheme.particles,\n                    alpha * 3\n                );\n                // Add glow effect\n                this.scene.tweens.add({\n                    targets: firefly,\n                    alpha: { from: alpha * 2, to: alpha * 4 },\n                    duration: Phaser.Math.Between(2000, 4000),\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                return firefly;\n                \n            case 'leaves':\n                // Forest theme - simple ellipse leaves that actually work\n                const bgLeaf = this.scene.add.ellipse(\n                    0, 0,\n                    18 * HD_SCALE * scale,\n                    25 * HD_SCALE * scale,\n                    Phaser.Math.RND.pick([0x5ca05c, 0x6cae6c, 0x4c904c]), // Natural greens\n                    0.12 // Subtle background opacity\n                );\n                bgLeaf.setAngle(Phaser.Math.Between(0, 360));\n                // Gentle rotation\n                this.scene.tweens.add({\n                    targets: bgLeaf,\n                    angle: `+=${Phaser.Math.Between(-30, 30)}`,\n                    duration: Phaser.Math.Between(8000, 12000),\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                return bgLeaf;\n                \n            case 'stars':\n                // Space theme - no geometric shapes, let the planets be the focus\n                return null;\n                \n            case 'aurora':\n                // Aurora theme - ethereal light pillars\n                const pillar = this.scene.add.rectangle(\n                    0, 0,\n                    Phaser.Math.Between(80, 120) * HD_SCALE * scale,\n                    500 * HD_SCALE * scale,\n                    Phaser.Math.RND.pick([0x00ffcc, 0x99ffee, 0xccffff]),\n                    0.06 + layerIndex * 0.02 // Layer depth\n                );\n                pillar.setBlendMode(Phaser.BlendModes.ADD);\n                pillar.setAngle(Phaser.Math.Between(-15, 15));\n                // Ethereal shimmering\n                this.scene.tweens.add({\n                    targets: pillar,\n                    alpha: { from: 0.04, to: 0.08 },\n                    scaleX: { from: 0.8, to: 1.2 },\n                    angle: pillar.angle + Phaser.Math.Between(-5, 5),\n                    duration: Phaser.Math.Between(12000, 18000),\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                return pillar;\n                \n            default:\n                return null;\n        }\n    }\n\n    private drawLeaf(graphics: Phaser.GameObjects.Graphics, x: number, y: number, size: number): void {\n        // Draw a simple diamond/leaf shape using fillPoints\n        const points = [\n            x, y - size * 1.5,     // Top\n            x - size * 0.7, y,     // Left\n            x, y + size * 1.5,     // Bottom\n            x + size * 0.7, y      // Right\n        ];\n        graphics.fillPoints(points, true);\n    }\n\n    private createAmbientParticles(): void {\n        // Adjusted particles for better visuals without hurting FPS\n        let particleCount = this.config.quality === 'ultra' ? 8 : 4;\n        let delay = 500; // Slower creation\n        \n        // More stars for space theme, positioned on left side\n        if (this.currentTheme.particleType === 'stars') {\n            particleCount = this.config.quality === 'ultra' ? 20 : 12; // More stars for ambiance\n            delay = 200; // Faster star creation\n        }\n        \n        for (let i = 0; i < particleCount; i++) {\n            this.scene.time.delayedCall(i * delay, () => {\n                this.createThemeParticle();\n            });\n        }\n        \n        // Secondary effects disabled for performance\n        // if (this.config.quality === 'ultra') {\n        //     this.createSecondaryEffect();\n        // }\n    }\n\n    private createThemeParticle(): void {\n        let particle: Phaser.GameObjects.GameObject;\n        const startX = Phaser.Math.Between(0, this.width);\n        const startY = this.currentTheme.particleType === 'leaves' ? -20 : this.height + 20;\n        \n        switch (this.currentTheme.particleType) {\n            case 'bubbles':\n                // Ocean bubbles rising up\n                particle = this.scene.add.circle(\n                    startX,\n                    this.height + 20,\n                    Phaser.Math.Between(3, 8) * HD_SCALE,\n                    this.currentTheme.particles,\n                    Phaser.Math.FloatBetween(0.1, 0.2)\n                );\n                // Add shimmer effect\n                (particle as Phaser.GameObjects.Arc).setStrokeStyle(\n                    1,\n                    this.currentTheme.secondaryParticles,\n                    0.3\n                );\n                // Float up with wobble\n                this.scene.tweens.add({\n                    targets: particle,\n                    y: -20,\n                    x: startX + Math.sin(Date.now() * 0.001) * 30,\n                    duration: Phaser.Math.Between(12000, 18000),\n                    ease: 'Linear',\n                    onComplete: () => this.recycleParticle(particle)\n                });\n                // Wobble horizontally\n                this.scene.tweens.add({\n                    targets: particle,\n                    x: `+=${Phaser.Math.Between(-30, 30)}`,\n                    duration: 2000,\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                break;\n                \n            case 'fireflies':\n                // Glowing fireflies with erratic movement\n                particle = this.scene.add.circle(\n                    startX,\n                    Phaser.Math.Between(this.height * 0.3, this.height * 0.7),\n                    Phaser.Math.Between(2, 4) * HD_SCALE,\n                    this.currentTheme.particles,\n                    0.8\n                );\n                // Glow pulsing\n                this.scene.tweens.add({\n                    targets: particle,\n                    scale: { from: 0.8, to: 1.3 },\n                    alpha: { from: 0.4, to: 1 },\n                    duration: Phaser.Math.Between(1000, 2000),\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                // Erratic floating movement\n                this.createFireflyPath(particle);\n                // Auto-recycle after some time\n                this.scene.time.delayedCall(Phaser.Math.Between(15000, 20000), () => {\n                    this.recycleParticle(particle);\n                });\n                break;\n                \n            case 'leaves':\n                // Falling leaves - using simple shapes that work\n                const leafSize = Phaser.Math.Between(10, 18) * HD_SCALE;\n                particle = this.scene.add.ellipse(\n                    startX,\n                    startY,\n                    leafSize * 0.8,\n                    leafSize * 1.3,\n                    Phaser.Math.RND.pick([0x5ca05c, 0x7cb87c, 0x4c904c, 0x6cae6c]), // Various green tones\n                    0.6\n                );\n                (particle as Phaser.GameObjects.Ellipse).setStrokeStyle(1, 0x3a7a3a, 0.8);\n                (particle as Phaser.GameObjects.Ellipse).setAngle(Phaser.Math.Between(0, 360));\n                // Fall with realistic leaf motion\n                const fallDuration = Phaser.Math.Between(10000, 15000);\n                this.scene.tweens.add({\n                    targets: particle,\n                    y: this.height + 20,\n                    angle: `+=${Phaser.Math.Between(90, 270)}`,\n                    duration: fallDuration,\n                    ease: 'Linear',\n                    onComplete: () => this.recycleParticle(particle)\n                });\n                // Gentle sway side to side\n                this.scene.tweens.add({\n                    targets: particle,\n                    x: `+=${Phaser.Math.Between(-60, 60)}`,\n                    duration: 2500,\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                // Subtle scale pulsing for depth\n                this.scene.tweens.add({\n                    targets: particle,\n                    scaleX: { from: 1, to: 0.85 },\n                    scaleY: { from: 1, to: 1.1 },\n                    duration: 3000,\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                break;\n                \n            case 'stars':\n                // Deep space - realistic stars everywhere except planet area (top-right)\n                const starSize = Phaser.Math.FloatBetween(0.5, 2) * HD_SCALE;\n                let starX = Phaser.Math.Between(0, this.width);\n                let starY = Phaser.Math.Between(0, this.height);\n                \n                // Avoid the planet area (top-right)\n                if (starX > this.width * 0.7 && starY < this.height * 0.3) {\n                    // If in planet area, move it elsewhere\n                    if (Phaser.Math.Between(0, 1) === 0) {\n                        starX = Phaser.Math.Between(0, this.width * 0.7); // Move left\n                    } else {\n                        starY = Phaser.Math.Between(this.height * 0.3, this.height); // Move down\n                    }\n                }\n                \n                particle = this.scene.add.circle(\n                    starX,\n                    starY,\n                    starSize,\n                    0xffffff,\n                    Phaser.Math.FloatBetween(0.5, 0.9) // Start visible\n                );\n                \n                // Some stars just stay static, others twinkle\n                if (Phaser.Math.Between(0, 10) > 7) {\n                    // 30% twinkle\n                    this.scene.tweens.add({\n                        targets: particle,\n                        alpha: { from: particle.alpha, to: particle.alpha * 0.3 },\n                        duration: Phaser.Math.Between(2000, 4000),\n                        yoyo: true,\n                        repeat: Phaser.Math.Between(1, 3),\n                        ease: 'Sine.easeInOut',\n                        onComplete: () => {\n                            // Fade out and recycle\n                            this.scene.tweens.add({\n                                targets: particle,\n                                alpha: 0,\n                                duration: 1000,\n                                onComplete: () => this.recycleParticle(particle)\n                            });\n                        }\n                    });\n                } else {\n                    // 70% stay static for a while then fade\n                    this.scene.time.delayedCall(Phaser.Math.Between(10000, 20000), () => {\n                        if (particle && particle.active) {\n                            this.scene.tweens.add({\n                                targets: particle,\n                                alpha: 0,\n                                duration: 2000,\n                                onComplete: () => this.recycleParticle(particle)\n                            });\n                        }\n                    });\n                }\n                break;\n                \n            case 'aurora':\n                // Beautiful flowing aurora curtains\n                const curtainX = Phaser.Math.Between(50, this.width - 50);\n                const curtainWidth = Phaser.Math.Between(100, 180) * HD_SCALE;\n                const curtainColor = Phaser.Math.RND.pick([\n                    0x00ffaa, // Green aurora\n                    0x00ddff, // Cyan aurora  \n                    0x99ffdd, // Mint aurora\n                    0xffaaff, // Pink aurora\n                    0xaaccff  // Blue aurora\n                ]);\n                \n                // Create tall vertical curtain\n                particle = this.scene.add.rectangle(\n                    curtainX,\n                    this.height / 2,\n                    curtainWidth,\n                    this.height * 1.5,\n                    curtainColor,\n                    0.12 // Visible but subtle\n                );\n                \n                // Set blend mode for glow effect\n                (particle as Phaser.GameObjects.Rectangle).setBlendMode(Phaser.BlendModes.ADD);\n                \n                // Slight initial angle for natural look\n                particle.setAngle(Phaser.Math.Between(-10, 10));\n                \n                // Beautiful flowing animation\n                this.scene.tweens.add({\n                    targets: particle,\n                    // Opacity pulse\n                    alpha: { \n                        from: 0.08, \n                        to: 0.18\n                    },\n                    // Width breathing\n                    scaleX: { \n                        from: 0.7, \n                        to: 1.2\n                    },\n                    // Gentle sway\n                    x: curtainX + Phaser.Math.Between(-40, 40),\n                    // Subtle rotation\n                    angle: particle.angle + Phaser.Math.Between(-5, 5),\n                    duration: Phaser.Math.Between(10000, 15000),\n                    yoyo: true,\n                    ease: 'Sine.easeInOut',\n                    onComplete: () => this.recycleParticle(particle)\n                });\n                \n                // Add shimmer effect - color shift\n                let colorPhase = 0;\n                const shimmerTimer = this.scene.time.addEvent({\n                    delay: 3000,\n                    callback: () => {\n                        if (particle && particle.active) {\n                            const colors = [curtainColor, 0x00ffcc, 0xaaffff];\n                            colorPhase = (colorPhase + 1) % colors.length;\n                            this.scene.tweens.add({\n                                targets: particle,\n                                duration: 2000,\n                                onUpdate: (tween) => {\n                                    const progress = tween.progress;\n                                    const fromColor = colors[colorPhase];\n                                    const toColor = colors[(colorPhase + 1) % colors.length];\n                                    const blended = Phaser.Display.Color.Interpolate.ColorWithColor(\n                                        Phaser.Display.Color.IntegerToColor(fromColor),\n                                        Phaser.Display.Color.IntegerToColor(toColor),\n                                        1,\n                                        progress\n                                    );\n                                    (particle as Phaser.GameObjects.Rectangle).setFillStyle(\n                                        Phaser.Display.Color.GetColor(blended.r, blended.g, blended.b),\n                                        particle.alpha\n                                    );\n                                }\n                            });\n                        } else {\n                            shimmerTimer.destroy();\n                        }\n                    },\n                    loop: true\n                });\n                break;\n                \n            default:\n                return;\n        }\n        \n        particle.setDepth(-850);\n        this.ambientElements.push(particle);\n    }\n    \n    private createFireflyPath(firefly: Phaser.GameObjects.GameObject): void {\n        // Create random floating movement for firefly\n        const moveFirefly = () => {\n            const newX = firefly.x + Phaser.Math.Between(-100, 100);\n            const newY = firefly.y + Phaser.Math.Between(-50, 50);\n            \n            // Keep within screen bounds\n            const boundedX = Phaser.Math.Clamp(newX, 50, this.width - 50);\n            const boundedY = Phaser.Math.Clamp(newY, this.height * 0.2, this.height * 0.8);\n            \n            this.scene.tweens.add({\n                targets: firefly,\n                x: boundedX,\n                y: boundedY,\n                duration: Phaser.Math.Between(2000, 3000),\n                ease: 'Sine.easeInOut',\n                onComplete: () => {\n                    // Continue moving if firefly still exists\n                    if (firefly && firefly.active) {\n                        moveFirefly();\n                    }\n                }\n            });\n        };\n        \n        // Start the movement\n        moveFirefly();\n    }\n    \n    private recycleParticle(particle: Phaser.GameObjects.GameObject): void {\n        particle.destroy();\n        this.ambientElements = this.ambientElements.filter(e => e !== particle);\n        // Create a new particle to maintain the effect\n        this.createThemeParticle();\n    }\n\n    private createSecondaryEffect(): void {\n        const sparkleTimer = this.scene.time.addEvent({\n            delay: 500,\n            callback: () => {\n                // Create secondary effects based on theme\n                switch (this.currentTheme.particleType) {\n                    case 'bubbles':\n                        // Small bubble clusters\n                        const clusterX = Phaser.Math.Between(0, this.width);\n                        for (let i = 0; i < 3; i++) {\n                            const smallBubble = this.scene.add.circle(\n                                clusterX + Phaser.Math.Between(-20, 20),\n                                this.height + 10,\n                                Phaser.Math.Between(1, 3) * HD_SCALE,\n                                this.currentTheme.secondaryParticles,\n                                0.2\n                            );\n                            smallBubble.setDepth(-840);\n                            this.ambientElements.push(smallBubble);\n                            this.scene.tweens.add({\n                                targets: smallBubble,\n                                y: -10,\n                                duration: Phaser.Math.Between(8000, 10000),\n                                delay: i * 100,\n                                ease: 'Linear',\n                                onComplete: () => {\n                                    smallBubble.destroy();\n                                    this.ambientElements = this.ambientElements.filter(e => e !== smallBubble);\n                                }\n                            });\n                        }\n                        break;\n                        \n                    case 'fireflies':\n                        // Spark trails\n                        const spark = this.scene.add.circle(\n                            Phaser.Math.Between(0, this.width),\n                            Phaser.Math.Between(this.height * 0.2, this.height * 0.8),\n                            1 * HD_SCALE,\n                            this.currentTheme.secondaryParticles,\n                            1\n                        );\n                        spark.setDepth(-840);\n                        this.ambientElements.push(spark);\n                        this.scene.tweens.add({\n                            targets: spark,\n                            alpha: { from: 1, to: 0 },\n                            scale: { from: 1, to: 0 },\n                            duration: 1000,\n                            ease: 'Power2',\n                            onComplete: () => {\n                                spark.destroy();\n                                this.ambientElements = this.ambientElements.filter(e => e !== spark);\n                            }\n                        });\n                        break;\n                        \n                    case 'stars':\n                        // Minimal space dust - very subtle\n                        const dust = this.scene.add.circle(\n                            Phaser.Math.Between(0, this.width),\n                            Phaser.Math.Between(0, this.height),\n                            0.5 * HD_SCALE, // Tiny\n                            0xccddff,\n                            Phaser.Math.FloatBetween(0.3, 0.5)\n                        );\n                        dust.setDepth(-840);\n                        this.ambientElements.push(dust);\n                        \n                        // Very slow drift\n                        this.scene.tweens.add({\n                            targets: dust,\n                            x: dust.x + Phaser.Math.Between(-10, 10),\n                            y: dust.y + Phaser.Math.Between(-10, 10),\n                            alpha: 0,\n                            duration: Phaser.Math.Between(5000, 8000),\n                            ease: 'Linear',\n                            onComplete: () => {\n                                dust.destroy();\n                                this.ambientElements = this.ambientElements.filter(e => e !== dust);\n                            }\n                        });\n                        break;\n                        \n                    default:\n                        // Generic sparkle for other themes\n                        const sparkle = this.scene.add.star(\n                            Phaser.Math.Between(0, this.width),\n                            Phaser.Math.Between(0, this.height),\n                            4, 2 * HD_SCALE, 4 * HD_SCALE,\n                            this.currentTheme.particles\n                        );\n                        sparkle.setAlpha(0);\n                        sparkle.setDepth(-840);\n                        this.ambientElements.push(sparkle);\n                        this.scene.tweens.add({\n                            targets: sparkle,\n                            alpha: { from: 0, to: 0.3, yoyo: true },\n                            scale: { from: 0, to: 1, yoyo: true },\n                            angle: 180,\n                            duration: 1500,\n                            ease: 'Cubic.easeOut',\n                            onComplete: () => {\n                                sparkle.destroy();\n                                this.ambientElements = this.ambientElements.filter(e => e !== sparkle);\n                            }\n                        });\n                        break;\n                }\n            },\n            loop: true\n        });\n        \n        this.animationTimers.push(sparkleTimer);\n    }\n\n    private createAnimatedElements(): void {\n        // Add special elements for specific themes\n        if (this.currentTheme.particleType === 'stars') {\n            // Always add planet and shooting stars for space theme\n            console.log('Space theme detected, creating planet and shooting stars');\n            this.createBackgroundPlanet();\n            this.createShootingStarTimer();\n        }\n    }\n    \n    private createBackgroundPlanet(): void {\n        // Earth planet with slow approach effect - like traveling towards it\n        \n        if (this.scene.textures.exists('planet')) {\n            const earthX = this.width * 0.85; // Slightly more to the right\n            const earthY = this.height * 0.15;\n            const startScale = 0.3; // Start small - far away\n            const endScale = 1.8; // Grow much larger - very close to Earth\n            \n            const earth = this.scene.add.image(earthX, earthY, 'planet');\n            earth.setScale(startScale);\n            earth.setAlpha(0.25); // Start less visible when far\n            earth.setDepth(-998); // Far back\n            \n            // Approaching Earth effect - like traveling towards it\n            this.scene.tweens.add({\n                targets: earth,\n                scale: { from: startScale, to: endScale }, // From small to large\n                alpha: { from: 0.25, to: 0.45 }, // More visible as we approach\n                duration: 120000, // 2 minutes to reach maximum size\n                ease: 'Linear', // Linear for now to ensure it's working\n                repeat: -1, // Loop forever\n                yoyo: true, // Go back and forth\n                onComplete: () => {\n                    // After reaching Earth, slowly drift away again\n                    this.scene.tweens.add({\n                        targets: earth,\n                        scale: startScale,\n                        alpha: 0.3,\n                        duration: 240000, // 4 minutes to go back\n                        ease: 'Cubic.easeOut',\n                        onComplete: () => {\n                            // Restart the approach\n                            this.createBackgroundPlanet();\n                            earth.destroy();\n                        }\n                    });\n                }\n            });\n            \n            // Subtle floating motion throughout\n            this.scene.tweens.add({\n                targets: earth,\n                y: earthY + (10 * HD_SCALE),\n                x: earthX - (5 * HD_SCALE), // Also drift slightly horizontally\n                duration: 50000,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut'\n            });\n            \n            // Very slow rotation to add realism\n            this.scene.tweens.add({\n                targets: earth,\n                angle: 360,\n                duration: 900000, // 15 minutes for one rotation\n                repeat: -1,\n                ease: 'Linear'\n            });\n            \n            this.ambientElements.push(earth);\n            console.log('Earth planet loaded with approach effect');\n        }\n    }\n    \n    private createFloatingBubblesBetweenPlanets(): void {\n        // Removed for performance - no floating bubbles between planets\n    }\n    \n    private createShootingStarTimer(): void {\n        // First shooting star after 3 seconds\n        this.scene.time.delayedCall(3000, () => {\n            this.createShootingStar();\n            console.log('Creating first shooting star');\n        });\n        \n        // Create well-spaced shooting stars\n        const createNextStar = () => {\n            const delay = Phaser.Math.Between(8000, 15000); // Good spacing between stars\n            this.scene.time.delayedCall(delay, () => {\n                if (this.scene && this.scene.scene.isActive()) {\n                    this.createShootingStar();\n                    console.log('Creating shooting star');\n                    createNextStar(); // Schedule next one\n                }\n            });\n        };\n        \n        createNextStar();\n    }\n    \n    private createShootingStar(): void {\n        // Create shooting stars across the screen\n        const startX = Phaser.Math.Between(0, this.width * 0.6);\n        const startY = Phaser.Math.Between(0, this.height * 0.4);\n        \n        // Create shooting star container\n        const shootingContainer = this.scene.add.container(startX, startY);\n        \n        // Create gradient trail using multiple segments\n        const trailLength = 8;\n        for (let i = trailLength; i > 0; i--) {\n            const segment = this.scene.add.circle(\n                -i * 8, 0,\n                (trailLength - i) * 0.3 + 0.5, // Taper from thin to thick\n                0xffffff,\n                (1 - i / trailLength) * 0.5 // Fade from transparent to bright\n            );\n            segment.setBlendMode(Phaser.BlendModes.ADD);\n            shootingContainer.add(segment);\n        }\n        \n        // Bright head\n        const head = this.scene.add.circle(0, 0, 1.5 * HD_SCALE, 0xffffff, 1);\n        head.setBlendMode(Phaser.BlendModes.ADD);\n        shootingContainer.add(head);\n        \n        shootingContainer.add(head);\n        shootingContainer.setDepth(-800); // Behind most things\n        shootingContainer.setAngle(35); // Natural angle\n        this.ambientElements.push(shootingContainer);\n        \n        // Normal shooting star animation\n        const endX = startX + Phaser.Math.Between(300, 450);\n        const endY = startY + Phaser.Math.Between(150, 250);\n        \n        this.scene.tweens.add({\n            targets: shootingContainer,\n            x: endX,\n            y: endY,\n            duration: 600,\n            ease: 'Power2.easeIn',\n            onUpdate: (tween) => {\n                // Fade out naturally\n                const progress = tween.progress;\n                shootingContainer.alpha = 1 - progress * 0.7;\n            },\n            onComplete: () => {\n                shootingContainer.destroy();\n                this.ambientElements = this.ambientElements.filter(e => e !== shootingContainer);\n            }\n        });\n    }\n\n    private startAnimations(): void {\n        // Parallax movement on scene update\n        if (this.parallaxLayers.length > 0) {\n            const updateEvent = this.scene.time.addEvent({\n                delay: 50,\n                callback: this.updateParallax.bind(this),\n                loop: true\n            });\n            this.animationTimers.push(updateEvent);\n        }\n        \n        // Gradient color shifting for ultra quality\n        if (this.config.quality === 'ultra') {\n            this.startGradientAnimation();\n        }\n    }\n\n    private updateParallax(): void {\n        this.parallaxLayers.forEach((layer, index) => {\n            const speed = (index + 1) * 0.1;\n            layer.x -= speed;\n            \n            // Wrap around\n            if (layer.x < -100) {\n                layer.x = 0;\n            }\n        });\n    }\n\n    private startGradientAnimation(): void {\n        // Subtle color shift over time\n        let hueShift = 0;\n        \n        const gradientTimer = this.scene.time.addEvent({\n            delay: 100,\n            callback: () => {\n                hueShift += 0.5;\n                if (hueShift > 360) hueShift = 0;\n                \n                // Apply subtle hue shift to accent elements\n                this.ambientElements.forEach(element => {\n                    if ('setTint' in element) {\n                        const shifted = this.shiftHue(this.currentTheme.accent, hueShift);\n                        (element as any).setTint(shifted);\n                    }\n                });\n            },\n            loop: true\n        });\n        \n        this.animationTimers.push(gradientTimer);\n    }\n\n    private addNoiseTexture(): void {\n        // Add subtle noise for texture\n        const noiseGraphics = this.scene.add.graphics();\n        noiseGraphics.setAlpha(0.02); // Very subtle\n        \n        for (let i = 0; i < 1000; i++) {\n            const x = Phaser.Math.Between(0, this.width);\n            const y = Phaser.Math.Between(0, this.height);\n            const alpha = Phaser.Math.FloatBetween(0.1, 0.3);\n            \n            noiseGraphics.fillStyle(0xffffff, alpha);\n            noiseGraphics.fillRect(x, y, 1, 1);\n        }\n        \n        noiseGraphics.setDepth(-999);\n    }\n\n    private blendColors(color1: number, color2: number, ratio: number): number {\n        const r1 = (color1 >> 16) & 0xff;\n        const g1 = (color1 >> 8) & 0xff;\n        const b1 = color1 & 0xff;\n        \n        const r2 = (color2 >> 16) & 0xff;\n        const g2 = (color2 >> 8) & 0xff;\n        const b2 = color2 & 0xff;\n        \n        const r = Math.floor(r1 + (r2 - r1) * ratio);\n        const g = Math.floor(g1 + (g2 - g1) * ratio);\n        const b = Math.floor(b1 + (b2 - b1) * ratio);\n        \n        return (r << 16) | (g << 8) | b;\n    }\n\n    private shiftHue(color: number, degrees: number): number {\n        // Convert to HSL, shift hue, convert back\n        const r = ((color >> 16) & 0xff) / 255;\n        const g = ((color >> 8) & 0xff) / 255;\n        const b = (color & 0xff) / 255;\n        \n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        const l = (max + min) / 2;\n        \n        if (max === min) {\n            return color; // Gray, no hue to shift\n        }\n        \n        const d = max - min;\n        const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        \n        let h;\n        if (max === r) {\n            h = ((g - b) / d + (g < b ? 6 : 0)) / 6;\n        } else if (max === g) {\n            h = ((b - r) / d + 2) / 6;\n        } else {\n            h = ((r - g) / d + 4) / 6;\n        }\n        \n        h = (h + degrees / 360) % 1;\n        \n        // Convert back to RGB\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1/6) return p + (q - p) * 6 * t;\n            if (t < 1/2) return q;\n            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n            return p;\n        };\n        \n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        \n        const newR = Math.floor(hue2rgb(p, q, h + 1/3) * 255);\n        const newG = Math.floor(hue2rgb(p, q, h) * 255);\n        const newB = Math.floor(hue2rgb(p, q, h - 1/3) * 255);\n        \n        return (newR << 16) | (newG << 8) | newB;\n    }\n\n    public setTheme(theme: 'ocean' | 'sunset' | 'forest' | 'space' | 'aurora'): void {\n        this.config.theme = theme;\n        this.currentTheme = this.themes[theme];\n        \n        // Recreate background with new theme\n        this.destroy();\n        this.create();\n    }\n\n    public setQuality(quality: 'low' | 'medium' | 'high' | 'ultra'): void {\n        this.config.quality = quality;\n        \n        // Recreate with new quality settings\n        this.destroy();\n        this.create();\n    }\n\n    public destroy(): void {\n        // Clean up graphics\n        this.gradientGraphics?.destroy();\n        \n        // Clean up parallax layers\n        this.parallaxLayers.forEach(layer => layer.destroy());\n        this.parallaxLayers = [];\n        \n        // Clean up particles\n        this.particleEmitters.forEach(emitter => emitter.destroy());\n        this.particleEmitters = [];\n        \n        // Clean up ambient elements\n        this.ambientElements.forEach(element => element.destroy());\n        this.ambientElements = [];\n        \n        // Clean up timers\n        this.animationTimers.forEach(timer => timer.destroy());\n        this.animationTimers = [];\n    }\n}","/**\n * ThemeSelectScene - Beautiful theme selection screen\n * Allows players to choose their preferred visual theme before starting the game\n */\n\nimport { Scene } from 'phaser';\nimport { SceneKeys } from '@/types/GameTypes';\nimport { BackgroundSystem } from '@/systems/visual/BackgroundSystem';\nimport { HD_SCALE } from '@/config/GameConfig';\n\nexport type ThemeType = 'ocean' | 'sunset' | 'forest' | 'space' | 'aurora';\n\ninterface ThemeOption {\n    key: ThemeType;\n    name: string;\n    description: string;\n    colors: number[];\n    icon: string;\n}\n\nexport class ThemeSelectScene extends Scene {\n    private backgroundSystem!: BackgroundSystem;\n    private selectedTheme: ThemeType = 'ocean';\n    private themeContainers: Phaser.GameObjects.Container[] = [];\n    private titleText!: Phaser.GameObjects.Text;\n    private confirmButton!: Phaser.GameObjects.Container;\n    private previewBackground!: BackgroundSystem;\n    \n    private themes: ThemeOption[] = [\n        {\n            key: 'ocean',\n            name: 'Ocean Depths',\n            description: 'Dive into deep blue waters',\n            colors: [0x001a33, 0x003366, 0x004d99, 0x0066cc],\n            icon: '🌊'\n        },\n        {\n            key: 'sunset',\n            name: 'Twilight Dream',\n            description: 'Purple and orange sunset vibes',\n            colors: [0x1a0033, 0x330066, 0x660099, 0xff6600],\n            icon: '🌅'\n        },\n        {\n            key: 'forest',\n            name: 'Mystic Forest',\n            description: 'Natural green serenity',\n            colors: [0x001a00, 0x003300, 0x004d00, 0x006600],\n            icon: '🌲'\n        },\n        {\n            key: 'space',\n            name: 'Deep Space',\n            description: 'Journey through the cosmos',\n            colors: [0x000011, 0x000022, 0x000033, 0x9966ff],\n            icon: '🚀'\n        },\n        {\n            key: 'aurora',\n            name: 'Northern Lights',\n            description: 'Magical aurora borealis',\n            colors: [0x001122, 0x002244, 0x003366, 0x00ff99],\n            icon: '🌌'\n        }\n    ];\n\n    constructor() {\n        super({ key: SceneKeys.THEME_SELECT });\n    }\n\n    create(): void {\n        const { width, height } = this.cameras.main;\n        \n        // Create preview background (starts with ocean)\n        this.previewBackground = new BackgroundSystem(this, {\n            theme: 'ocean',\n            quality: 'high',\n            enableParticles: true,\n            enableAnimation: true\n        });\n        \n        // Add dark overlay for better text visibility\n        const overlay = this.add.graphics();\n        overlay.fillStyle(0x000000, 0.3);\n        overlay.fillRect(0, 0, width, height);\n        overlay.setDepth(100);\n        \n        // Title - optimized for mobile\n        this.titleText = this.add.text(width / 2, 40 * HD_SCALE, 'Choose Your Theme', {\n            fontSize: `${24 * HD_SCALE}px`,\n            fontFamily: 'Arial Black',\n            color: '#ffffff',\n            stroke: '#000000',\n            strokeThickness: 3\n        });\n        this.titleText.setOrigin(0.5);\n        this.titleText.setDepth(101);\n        \n        // Add glow effect to title\n        this.tweens.add({\n            targets: this.titleText,\n            scale: { from: 0.95, to: 1.05 },\n            duration: 2000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Create theme selection cards\n        this.createThemeCards();\n        \n        // Create confirm button\n        this.createConfirmButton();\n        \n        // Add keyboard shortcuts\n        this.setupKeyboardControls();\n        \n        // Select first theme by default\n        this.selectTheme(0);\n    }\n\n    private createThemeCards(): void {\n        const { width, height } = this.cameras.main;\n        \n        // Mobile-first vertical layout - optimized for small screens\n        const cardWidth = width * 0.85; // Use 85% of screen width for better mobile fit\n        const cardHeight = 65 * HD_SCALE; // Slightly taller for better touch targets\n        const spacing = 10 * HD_SCALE; // Proportional spacing\n        const titleHeight = 80 * HD_SCALE; // Account for title\n        const buttonHeight = 100 * HD_SCALE; // Account for button at bottom\n        \n        // Calculate available height and distribute cards evenly\n        const availableHeight = height - titleHeight - buttonHeight;\n        const totalCardHeight = (cardHeight * this.themes.length) + (spacing * (this.themes.length - 1));\n        \n        // Center cards vertically in available space\n        const startY = titleHeight + (availableHeight - totalCardHeight) / 2;\n        const centerX = width / 2;\n        \n        this.themes.forEach((theme, index) => {\n            const y = startY + (index * (cardHeight + spacing));\n            const container = this.createThemeCard(theme, centerX, y, cardWidth, cardHeight, index);\n            this.themeContainers.push(container);\n        });\n    }\n\n    private createThemeCard(theme: ThemeOption, x: number, y: number, width: number, height: number, index: number): Phaser.GameObjects.Container {\n        const container = this.add.container(x, y);\n        container.setDepth(102);\n        \n        // Card background\n        const bg = this.add.graphics();\n        bg.fillStyle(0x000000, 0.7);\n        bg.fillRoundedRect(-width/2, -height/2, width, height, 10);\n        bg.lineStyle(2, 0xffffff, 0.3);\n        bg.strokeRoundedRect(-width/2, -height/2, width, height, 10);\n        container.add(bg);\n        \n        // Selection glow (hidden by default)\n        const glow = this.add.graphics();\n        glow.lineStyle(3, 0x00ff00, 1);\n        glow.strokeRoundedRect(-width/2 - 3, -height/2 - 3, width + 6, height + 6, 12);\n        glow.setVisible(false);\n        container.add(glow);\n        container.setData('glow', glow);\n        \n        // Optimized horizontal layout for mobile\n        // Theme icon on the left\n        const iconX = -width/2 + 30 * HD_SCALE;\n        const icon = this.add.text(iconX, 0, theme.icon, {\n            fontSize: `${28 * HD_SCALE}px`,\n            fontFamily: 'Arial'\n        });\n        icon.setOrigin(0.5);\n        container.add(icon);\n        \n        // Theme name - larger and better positioned\n        const nameText = this.add.text(-20 * HD_SCALE, -10 * HD_SCALE, theme.name, {\n            fontSize: `${16 * HD_SCALE}px`,\n            fontFamily: 'Arial Black',\n            color: '#ffffff',\n            align: 'left'\n        });\n        nameText.setOrigin(0, 0.5);\n        container.add(nameText);\n        \n        // Theme description below name\n        const descText = this.add.text(-20 * HD_SCALE, 10 * HD_SCALE, theme.description, {\n            fontSize: `${11 * HD_SCALE}px`,\n            fontFamily: 'Arial',\n            color: '#aaaaaa',\n            align: 'left'\n        });\n        descText.setOrigin(0, 0.5);\n        container.add(descText);\n        \n        // Color preview dots on the right - horizontal layout\n        const dotSize = 8 * HD_SCALE;\n        const dotSpacing = 12 * HD_SCALE;\n        const dotsStartX = width/2 - (theme.colors.length * dotSpacing + 20 * HD_SCALE);\n        \n        theme.colors.forEach((color, i) => {\n            const dot = this.add.circle(\n                dotsStartX + (i * dotSpacing),\n                0,\n                dotSize / 2,\n                color\n            );\n            dot.setStrokeStyle(1, 0xffffff, 0.3);\n            container.add(dot);\n        });\n        \n        // Make interactive\n        container.setInteractive(new Phaser.Geom.Rectangle(-width/2, -height/2, width, height), Phaser.Geom.Rectangle.Contains);\n        \n        // Hover effects\n        container.on('pointerover', () => {\n            this.tweens.add({\n                targets: container,\n                scale: 1.05,\n                duration: 200,\n                ease: 'Power2'\n            });\n            bg.clear();\n            bg.fillStyle(0x000000, 0.9);\n            bg.fillRoundedRect(-width/2, -height/2, width, height, 10);\n            bg.lineStyle(3, 0xffffff, 0.5);\n            bg.strokeRoundedRect(-width/2, -height/2, width, height, 10);\n        });\n        \n        container.on('pointerout', () => {\n            if (this.selectedTheme !== theme.key) {\n                this.tweens.add({\n                    targets: container,\n                    scale: 1,\n                    duration: 200,\n                    ease: 'Power2'\n                });\n                bg.clear();\n                bg.fillStyle(0x000000, 0.7);\n                bg.fillRoundedRect(-width/2, -height/2, width, height, 10);\n                bg.lineStyle(3, 0xffffff, 0.3);\n                bg.strokeRoundedRect(-width/2, -height/2, width, height, 10);\n            }\n        });\n        \n        // Click to select\n        container.on('pointerdown', () => {\n            this.selectTheme(index);\n        });\n        \n        // Add entrance animation\n        container.setScale(0);\n        container.setAlpha(0);\n        this.tweens.add({\n            targets: container,\n            scale: 1,\n            alpha: 1,\n            duration: 500,\n            delay: index * 100,\n            ease: 'Back.easeOut'\n        });\n        \n        return container;\n    }\n\n    private createConfirmButton(): void {\n        const { width, height } = this.cameras.main;\n        const buttonY = height - 50 * HD_SCALE; // Very close to bottom for mobile\n        \n        this.confirmButton = this.add.container(width / 2, buttonY);\n        this.confirmButton.setDepth(103);\n        \n        // Button background - optimized for mobile touch\n        const bg = this.add.graphics();\n        const buttonWidth = width * 0.65; // 65% of screen width\n        const buttonHeight = 40 * HD_SCALE; // Good touch target size\n        \n        bg.fillStyle(0x00ff00, 0.8);\n        bg.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 10);\n        this.confirmButton.add(bg);\n        \n        // Button text - optimized size for mobile\n        const text = this.add.text(0, 0, 'START GAME', {\n            fontSize: `${18 * HD_SCALE}px`,\n            fontFamily: 'Arial Black',\n            color: '#000000'\n        });\n        text.setOrigin(0.5);\n        this.confirmButton.add(text);\n        \n        // Make interactive\n        this.confirmButton.setInteractive(new Phaser.Geom.Rectangle(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight), Phaser.Geom.Rectangle.Contains);\n        \n        // Hover effect\n        this.confirmButton.on('pointerover', () => {\n            bg.clear();\n            bg.fillStyle(0x00ff00, 1);\n            bg.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 10);\n            this.tweens.add({\n                targets: this.confirmButton,\n                scale: 1.1,\n                duration: 200,\n                ease: 'Power2'\n            });\n        });\n        \n        this.confirmButton.on('pointerout', () => {\n            bg.clear();\n            bg.fillStyle(0x00ff00, 0.8);\n            bg.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 10);\n            this.tweens.add({\n                targets: this.confirmButton,\n                scale: 1,\n                duration: 200,\n                ease: 'Power2'\n            });\n        });\n        \n        // Click to start game\n        this.confirmButton.on('pointerdown', () => {\n            this.startGame();\n        });\n        \n        // Pulsing animation\n        this.tweens.add({\n            targets: this.confirmButton,\n            scale: { from: 0.95, to: 1.05 },\n            duration: 1000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n    }\n\n    private selectTheme(index: number): void {\n        const theme = this.themes[index];\n        this.selectedTheme = theme.key;\n        \n        // Update preview background\n        this.previewBackground.setTheme(theme.key);\n        \n        // Update visual selection\n        this.themeContainers.forEach((container, i) => {\n            const glow = container.getData('glow') as Phaser.GameObjects.Graphics;\n            if (i === index) {\n                glow.setVisible(true);\n                container.setScale(1.1);\n                \n                // Bounce animation\n                this.tweens.add({\n                    targets: container,\n                    y: container.y - 10,\n                    duration: 200,\n                    yoyo: true,\n                    ease: 'Power2'\n                });\n            } else {\n                glow.setVisible(false);\n                container.setScale(1);\n            }\n        });\n        \n        // Store selection\n        this.registry.set('selectedTheme', theme.key);\n    }\n\n    private setupKeyboardControls(): void {\n        // Number keys 1-5 for quick selection\n        this.input.keyboard?.on('keydown-ONE', () => this.selectTheme(0));\n        this.input.keyboard?.on('keydown-TWO', () => this.selectTheme(1));\n        this.input.keyboard?.on('keydown-THREE', () => this.selectTheme(2));\n        this.input.keyboard?.on('keydown-FOUR', () => this.selectTheme(3));\n        this.input.keyboard?.on('keydown-FIVE', () => this.selectTheme(4));\n        \n        // Enter or Space to confirm\n        this.input.keyboard?.on('keydown-ENTER', () => this.startGame());\n        this.input.keyboard?.on('keydown-SPACE', () => this.startGame());\n        \n        // ESC to go back\n        this.input.keyboard?.on('keydown-ESC', () => {\n            this.scene.start(SceneKeys.MENU);\n        });\n    }\n\n    private startGame(): void {\n        // Clean up\n        this.previewBackground.destroy();\n        \n        // Transition effect\n        const fadeOut = this.add.graphics();\n        fadeOut.fillStyle(0x000000, 0);\n        fadeOut.fillRect(0, 0, this.cameras.main.width, this.cameras.main.height);\n        fadeOut.setDepth(1000);\n        \n        this.tweens.add({\n            targets: fadeOut,\n            alpha: 1,\n            duration: 500,\n            ease: 'Power2',\n            onComplete: () => {\n                // Start game with selected theme\n                this.scene.start(SceneKeys.GAME, {\n                    theme: this.selectedTheme\n                });\n            }\n        });\n    }\n\n    shutdown(): void {\n        this.previewBackground?.destroy();\n    }\n}","export interface IArenaConfig {\n    width: number;\n    height: number;\n    playerZoneHeight: number;\n    opponentZoneHeight: number;\n    objectiveZoneHeight: number;\n    bubbleSize: number;\n    objectiveSize: number;\n    launcherOffset: number;\n}\n\nexport interface IBubbleData {\n    gridX: number;\n    gridY: number;\n    color: BubbleColor;\n    isSpecial: boolean;\n}\n\nexport interface IHexPosition {\n    q: number; // column\n    r: number; // row\n    s: number; // constraint: q + r + s = 0\n}\n\nexport interface IPixelPosition {\n    x: number;\n    y: number;\n}\n\nexport enum BubbleColor {\n    RED = 0xff0000,\n    BLUE = 0x0000ff,\n    GREEN = 0x00ff00,\n    YELLOW = 0xffff00,\n    PURPLE = 0xff00ff\n}\n\nexport enum ArenaZone {\n    PLAYER = 'player',\n    OPPONENT = 'opponent',\n    OBJECTIVE = 'objective',\n    NEUTRAL = 'neutral'\n}\n\nexport interface IZoneBounds {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    zone: ArenaZone;\n}\n\nexport interface ILauncherConfig {\n    x: number;\n    y: number;\n    angle: number;\n    zone: ArenaZone;\n}\n\nexport interface IObjectiveConfig {\n    x: number;\n    y: number;\n    size: number;\n    health: number;\n}","import { IArenaConfig } from '@/types/ArenaTypes';\n\nconst HD_SCALE = 2.5;  // Ultra HD scaling factor restored\n\nexport const ARENA_CONFIG: IArenaConfig = {\n    width: 375 * HD_SCALE,  // 937.5 Ultra HD width\n    height: 667 * HD_SCALE, // 1667.5 Ultra HD height\n    playerZoneHeight: 267 * HD_SCALE,    // 667.5 Ultra HD\n    opponentZoneHeight: 267 * HD_SCALE,  // 667.5 Ultra HD\n    objectiveZoneHeight: 133 * HD_SCALE, // 332.5 Ultra HD\n    bubbleSize: 28 * HD_SCALE,  // 70 Ultra HD (reduced from 32)\n    objectiveSize: 28 * HD_SCALE, // 70 Ultra HD (reduced from 32)\n    launcherOffset: 45 * HD_SCALE  // 112.5 Ultra HD (reduced from 50)\n};\n\nexport const BUBBLE_CONFIG = {\n    SIZE: 28 * HD_SCALE,  // 70 Ultra HD (reduced from 32)\n    GAP: 0,  // No gap - bubbles touch perfectly\n    COLORS: 5,\n    POOL_SIZE: 50, // OPTIMIZED: Reduced pool size for better iOS performance\n    HEX_WIDTH: 28 * HD_SCALE,  // 70 Ultra HD (reduced)\n    HEX_HEIGHT: 24 * HD_SCALE, // 60 Ultra HD (SIZE * 0.866)\n    ANIMATION_DURATION: 200,\n    FALL_SPEED: 500 * HD_SCALE  // 1250 Ultra HD\n};\n\nexport const GRID_CONFIG = {\n    ROWS: 15,\n    COLS: 11,\n    CENTER_ROW: 7,\n    CENTER_COL: 5,\n    OBJECTIVE_RADIUS: 3 // Bubbles around objective in hex rings\n};\n\nexport const DANGER_ZONE_CONFIG = {\n    PLAYER_OFFSET: 120 * HD_SCALE,    // 300 Ultra HD\n    OPPONENT_OFFSET: 120 * HD_SCALE,  // 300 Ultra HD\n    LINE_COLOR: 0xFFFFFF,\n    LINE_ALPHA: 0.08,\n    LINE_WIDTH: 1 * HD_SCALE,  // 2.5 Ultra HD\n    PULSE_DURATION: 1000\n};\n\nexport const ZONE_COLORS = {\n    PLAYER: 0x3498db,\n    OPPONENT: 0xe74c3c,\n    OBJECTIVE: 0xf39c12,\n    NEUTRAL: 0x95a5a6,\n    DEBUG_ALPHA: 0.2\n};\n\nexport const Z_LAYERS = {\n    BACKGROUND: 0,\n    ZONE_DEBUG: 1,\n    GRID_DEBUG: 2,\n    BUBBLES_BACK: 10,\n    BUBBLES: 15,  // Grid bubbles\n    BUBBLES_FRONT: 20,  // Projectile bubbles\n    OBJECTIVE: 25,  // Objective should be above bubbles\n    LAUNCHERS: 40,\n    UI: 50,\n    FLOATING_UI: 60,  // For floating power-ups\n    DEBUG_OVERLAY: 100\n};","import { IHexPosition, IPixelPosition } from '@/types/ArenaTypes';\nimport { BUBBLE_CONFIG, GRID_CONFIG } from '@/config/ArenaConfig';\n\nexport class BubbleGrid {\n    private centerX: number;\n    private centerY: number;\n    private hexSize: number;\n    private gridMap: Map<string, IHexPosition>;\n\n    constructor(centerX: number, centerY: number) {\n        this.centerX = centerX;\n        this.centerY = centerY;\n        // Use bubble radius plus small spacing\n        this.hexSize = (BUBBLE_CONFIG.SIZE / 2) + 1;\n        this.gridMap = new Map();\n        this.initializeGrid();\n    }\n\n    private initializeGrid(): void {\n        // Initialize hex grid positions\n        for (let q = -GRID_CONFIG.CENTER_COL; q <= GRID_CONFIG.CENTER_COL; q++) {\n            for (let r = -GRID_CONFIG.CENTER_ROW; r <= GRID_CONFIG.CENTER_ROW; r++) {\n                const s = -q - r;\n                const key = this.getKey(q, r);\n                this.gridMap.set(key, { q, r, s });\n            }\n        }\n    }\n\n    public hexToPixel(hex: IHexPosition): IPixelPosition {\n        // Simple offset grid for bubble shooters\n        // Odd rows are offset by half a bubble width\n        const rowHeight = this.hexSize * Math.sqrt(3);\n        const colWidth = this.hexSize * 2;\n        \n        // Calculate position with offset for odd rows\n        const isOddRow = Math.abs(hex.r) % 2 === 1;\n        const xOffset = isOddRow ? this.hexSize : 0;\n        \n        const x = hex.q * colWidth + xOffset;\n        const y = hex.r * rowHeight;\n        \n        return {\n            x: this.centerX + x,\n            y: this.centerY + y\n        };\n    }\n\n    public pixelToHex(pixel: IPixelPosition): IHexPosition {\n        const x = pixel.x - this.centerX;\n        const y = pixel.y - this.centerY;\n        \n        const rowHeight = this.hexSize * Math.sqrt(3);\n        const colWidth = this.hexSize * 2;\n        \n        // Estimate row\n        const r = Math.round(y / rowHeight);\n        \n        // Adjust x for odd row offset\n        const isOddRow = Math.abs(r) % 2 === 1;\n        const adjustedX = isOddRow ? x - this.hexSize : x;\n        \n        // Estimate column\n        const q = Math.round(adjustedX / colWidth);\n        \n        return { q, r, s: -q - r };\n    }\n\n    private roundHex(q: number, r: number): IHexPosition {\n        const s = -q - r;\n        \n        let rq = Math.round(q);\n        let rr = Math.round(r);\n        let rs = Math.round(s);\n        \n        const qDiff = Math.abs(rq - q);\n        const rDiff = Math.abs(rr - r);\n        const sDiff = Math.abs(rs - s);\n        \n        if (qDiff > rDiff && qDiff > sDiff) {\n            rq = -rr - rs;\n        } else if (rDiff > sDiff) {\n            rr = -rq - rs;\n        } else {\n            rs = -rq - rr;\n        }\n        \n        return { q: rq, r: rr, s: rs };\n    }\n\n    public getNeighbors(hex: IHexPosition): IHexPosition[] {\n        // For offset grid, neighbors depend on whether we're in an odd or even row\n        const isOddRow = Math.abs(hex.r) % 2 === 1;\n        \n        let directions: Array<{q: number, r: number}> = [];\n        \n        if (!isOddRow) {\n            // Even row neighbors\n            directions = [\n                { q: 0, r: -1 },   // Top\n                { q: 1, r: 0 },    // Right\n                { q: 0, r: 1 },    // Bottom\n                { q: -1, r: 1 },   // Bottom-left\n                { q: -1, r: 0 },   // Left\n                { q: -1, r: -1 }   // Top-left\n            ];\n        } else {\n            // Odd row neighbors (offset by half)\n            directions = [\n                { q: 0, r: -1 },   // Top\n                { q: 1, r: -1 },   // Top-right\n                { q: 1, r: 0 },    // Right\n                { q: 1, r: 1 },    // Bottom-right\n                { q: 0, r: 1 },    // Bottom\n                { q: -1, r: 0 }    // Left\n            ];\n        }\n        \n        return directions.map(dir => ({\n            q: hex.q + dir.q,\n            r: hex.r + dir.r,\n            s: 0 // Not used in offset grid\n        }));\n    }\n\n    public getDistance(a: IHexPosition, b: IHexPosition): number {\n        return (Math.abs(a.q - b.q) + Math.abs(a.r - b.r) + Math.abs(a.s - b.s)) / 2;\n    }\n\n    public getRing(center: IHexPosition, radius: number): IHexPosition[] {\n        if (radius === 0) return [center];\n        \n        const results: IHexPosition[] = [];\n        const directions = [\n            { q: 1, r: 0, s: -1 },\n            { q: 1, r: -1, s: 0 },\n            { q: 0, r: -1, s: 1 },\n            { q: -1, r: 0, s: 1 },\n            { q: -1, r: 1, s: 0 },\n            { q: 0, r: 1, s: -1 }\n        ];\n        \n        let hex = {\n            q: center.q + directions[4].q * radius,\n            r: center.r + directions[4].r * radius,\n            s: center.s + directions[4].s * radius\n        };\n        \n        for (let i = 0; i < 6; i++) {\n            for (let j = 0; j < radius; j++) {\n                results.push({ ...hex });\n                hex = {\n                    q: hex.q + directions[i].q,\n                    r: hex.r + directions[i].r,\n                    s: hex.s + directions[i].s\n                };\n            }\n        }\n        \n        return results;\n    }\n\n    public getSpiral(center: IHexPosition, maxRadius: number): IHexPosition[] {\n        const results: IHexPosition[] = [];\n        \n        for (let radius = 0; radius <= maxRadius; radius++) {\n            const ring = this.getRing(center, radius);\n            results.push(...ring);\n        }\n        \n        return results;\n    }\n\n    private getKey(q: number, r: number): string {\n        return `${q},${r}`;\n    }\n\n    public isValidPosition(hex: IHexPosition): boolean {\n        const key = this.getKey(hex.q, hex.r);\n        return this.gridMap.has(key);\n    }\n\n    public getGridBounds(): { minQ: number; maxQ: number; minR: number; maxR: number } {\n        return {\n            minQ: -GRID_CONFIG.CENTER_COL,\n            maxQ: GRID_CONFIG.CENTER_COL,\n            minR: -GRID_CONFIG.CENTER_ROW,\n            maxR: GRID_CONFIG.CENTER_ROW\n        };\n    }\n    \n    /**\n     * Get all bubbles currently in the grid\n     */\n    public getAllBubbles(): any[] {\n        // This would need to be implemented with actual bubble tracking\n        return [];\n    }\n    \n    /**\n     * Get bubble at specific world position\n     */\n    public getBubbleAt(x: number, y: number): any | null {\n        // Convert world position to hex position\n        const hex = this.pixelToHex({ x, y });\n        const key = this.getKey(hex.q, hex.r);\n        \n        // This would need actual bubble tracking\n        return null;\n    }\n    \n    /**\n     * Get bubbles within radius of a point\n     */\n    public getBubblesInRadius(x: number, y: number, radius: number): any[] {\n        // This would need actual implementation with bubble tracking\n        return [];\n    }\n}","import { BubbleColor, IHexPosition } from '@/types/ArenaTypes';\nimport { BUBBLE_CONFIG, Z_LAYERS } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\n\nexport class Bubble extends Phaser.GameObjects.Container {\n    private bubbleSprite: Phaser.GameObjects.Arc;\n    private innerGradient?: Phaser.GameObjects.Arc;\n    private highlightSprite?: Phaser.GameObjects.Arc;\n    private secondaryHighlight?: Phaser.GameObjects.Arc;\n    private shadowSprite?: Phaser.GameObjects.Arc;\n    private rimLight?: Phaser.GameObjects.Arc;\n    private patternSprite?: Phaser.GameObjects.Graphics;\n    private gridPosition: IHexPosition | null = null;\n    private color: BubbleColor;\n    private isSpecial: boolean = false;\n    private pooled: boolean = false;\n    private shooter: 'player' | 'ai' | 'none' = 'none';\n    private idleAnimation?: Phaser.Tweens.Tween;\n\n    constructor(scene: Phaser.Scene, x: number, y: number, color: BubbleColor) {\n        super(scene, x, y);\n        \n        this.color = color;\n        const radius = BUBBLE_CONFIG.SIZE / 2;\n        \n        // Premium bubble design with multiple layers\n        // 1. Simple shadow without blend mode\n        this.shadowSprite = scene.add.circle(3, 5, radius, 0x000000, 0.2);\n        // NO BLEND MODE for performance\n        this.shadowSprite.setScale(0.95);\n        \n        // 2. Main bubble base\n        this.bubbleSprite = scene.add.circle(0, 0, radius, color);\n        \n        // 3. HD inner gradient with better depth\n        this.innerGradient = scene.add.circle(0, 2, radius - 4, this.getDarkerColor(color));\n        this.innerGradient.setAlpha(0.5);\n        this.innerGradient.setScale(0.9);\n        \n        // 4. HD rim lighting for 3D pop\n        this.rimLight = scene.add.circle(0, 0, radius - 2, this.getLighterColor(color));\n        this.rimLight.setAlpha(0.0); // Will be visible only at edges via stroke\n        this.rimLight.setStrokeStyle(3, this.getLighterColor(color), 0.6);\n        \n        // 5. Simple highlight without blend mode\n        this.highlightSprite = scene.add.circle(\n            -radius * 0.35,\n            -radius * 0.4,\n            radius * 0.4,\n            0xFFFFFF,\n            0.3\n        );\n        // NO BLEND MODE for performance\n        \n        // 6. Simple secondary highlight\n        this.secondaryHighlight = scene.add.circle(\n            radius * 0.3,\n            -radius * 0.35,\n            radius * 0.25,\n            0xFFFFFF,\n            0.2\n        );\n        // NO BLEND MODE for performance\n        \n        // 7. Ultra HD border for crisp definition\n        this.bubbleSprite.setStrokeStyle(3, this.getDarkerColor(color), 1);\n        \n        // 8. Pattern sprite for colorblind patterns\n        this.patternSprite = scene.add.graphics();\n        \n        // Add all elements in proper order for best visual effect\n        this.add([\n            this.shadowSprite,\n            this.bubbleSprite,\n            this.innerGradient,\n            this.rimLight,\n            this.highlightSprite,\n            this.secondaryHighlight,\n            this.patternSprite\n        ]);\n        \n        this.setSize(BUBBLE_CONFIG.SIZE, BUBBLE_CONFIG.SIZE);\n        this.setDepth(Z_LAYERS.BUBBLES);\n        \n        scene.add.existing(this);\n        \n        // No idle animation - keep bubbles static\n        // this.addIdleAnimation();\n    }\n    \n    private addIdleAnimation(): void {\n        // DISABLED - No idle animations to keep bubbles static\n        // Only animate highlight shimmer if needed\n        return; // Early return to disable\n        /* Disabled animation code\n        if (this.highlightSprite) {\n            this.scene.tweens.add({\n                targets: this.highlightSprite,\n                alpha: { from: 0.4, to: 0.6 },\n                duration: 3000,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut',\n                delay: Math.random() * 1000\n            });\n        }\n        */\n    }\n\n    public setGridPosition(hex: IHexPosition | null): void {\n        this.gridPosition = hex;\n    }\n\n    public getGridPosition(): IHexPosition | null {\n        return this.gridPosition;\n    }\n    \n    public setShooter(shooter: 'player' | 'ai'): void {\n        this.shooter = shooter;\n    }\n    \n    public getShooter(): 'player' | 'ai' | 'none' {\n        return this.shooter;\n    }\n\n    public getColor(): BubbleColor {\n        return this.color;\n    }\n    \n    public setColor(color: BubbleColor): void {\n        this.color = color;\n        // Update all color-dependent elements\n        this.bubbleSprite.setFillStyle(color);\n        this.bubbleSprite.setStrokeStyle(2, this.getDarkerColor(color), 1);\n        \n        if (this.innerGradient) {\n            this.innerGradient.setFillStyle(this.getDarkerColor(color));\n        }\n        \n        if (this.rimLight) {\n            this.rimLight.setStrokeStyle(2, this.getLighterColor(color), 0.5);\n        }\n    }\n\n    public setTint(tint: number): void {\n        this.bubbleSprite.setFillStyle(tint);\n    }\n\n    public clearTint(): void {\n        this.bubbleSprite.setFillStyle(this.color);\n    }\n\n    public setSpecial(special: boolean): void {\n        this.isSpecial = special;\n        if (special) {\n            this.addGlow();\n        } else {\n            this.removeGlow();\n        }\n    }\n\n    public getIsSpecial(): boolean {\n        return this.isSpecial;\n    }\n\n    private addGlow(): void {\n        // No scale animation - just visual glow\n        // Add pulsing glow ring behind bubble\n        const glow = this.scene.add.circle(0, 0, BUBBLE_CONFIG.SIZE / 2 + (3 * HD_SCALE), this.color, 0.4);\n        glow.setStrokeStyle(2, this.getLighterColor(this.color), 0.6);\n        this.addAt(glow, 0);\n        \n        // Animate only the glow opacity, not the bubble scale\n        this.scene.tweens.add({\n            targets: glow,\n            alpha: { from: 0.2, to: 0.5 },\n            duration: 800,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n    }\n\n    private removeGlow(): void {\n        // Remove the glow element if it exists\n        if (this.length > 6) { // We have 6 base elements, glow would be 7th\n            const glowElement = this.getAt(0);\n            this.scene.tweens.killTweensOf(glowElement);\n            this.removeAt(0);\n            glowElement.destroy();\n        }\n    }\n\n    private getDarkerColor(color: BubbleColor): number {\n        // Create darker shade for depth\n        const r = (color >> 16) & 0xff;\n        const g = (color >> 8) & 0xff;\n        const b = color & 0xff;\n        \n        // Much darker for inner gradient\n        return (Math.floor(r * 0.5) << 16) | \n               (Math.floor(g * 0.5) << 8) | \n               Math.floor(b * 0.5);\n    }\n    \n    private getLighterColor(color: BubbleColor): number {\n        // Create lighter shade for rim lighting\n        const r = (color >> 16) & 0xff;\n        const g = (color >> 8) & 0xff;\n        const b = color & 0xff;\n        \n        // Lighter version for rim\n        const lr = Math.min(255, Math.floor(r * 1.3 + 50));\n        const lg = Math.min(255, Math.floor(g * 1.3 + 50));\n        const lb = Math.min(255, Math.floor(b * 1.3 + 50));\n        \n        return (lr << 16) | (lg << 8) | lb;\n    }\n\n    /**\n     * Adds colorblind-friendly patterns to bubbles\n     * Each color gets a unique pattern for accessibility\n     */\n    private addColorblindPattern(color: BubbleColor): void {\n        if (!this.patternSprite) return;\n        \n        this.patternSprite.clear();\n        this.patternSprite.lineStyle(1 * HD_SCALE, 0xffffff, 0.4);\n        \n        const radius = BUBBLE_CONFIG.SIZE / 2;\n        \n        switch (color) {\n            case BubbleColor.RED:\n                // Horizontal lines pattern\n                for (let y = -radius + (2 * HD_SCALE); y < radius; y += (3 * HD_SCALE)) {\n                    const x = Math.sqrt(radius * radius - y * y) * 0.8;\n                    this.patternSprite.lineBetween(-x, y, x, y);\n                }\n                break;\n                \n            case BubbleColor.BLUE:\n                // Vertical lines pattern\n                for (let x = -radius + (2 * HD_SCALE); x < radius; x += (3 * HD_SCALE)) {\n                    const y = Math.sqrt(radius * radius - x * x) * 0.8;\n                    this.patternSprite.lineBetween(x, -y, x, y);\n                }\n                break;\n                \n            case BubbleColor.GREEN:\n                // Diagonal lines (top-left to bottom-right)\n                for (let offset = -radius; offset < radius; offset += (3 * HD_SCALE)) {\n                    const startX = Math.max(-radius * 0.7, offset - radius * 0.7);\n                    const startY = Math.max(-radius * 0.7, -offset - radius * 0.7);\n                    const endX = Math.min(radius * 0.7, offset + radius * 0.7);\n                    const endY = Math.min(radius * 0.7, -offset + radius * 0.7);\n                    this.patternSprite.lineBetween(startX, startY, endX, endY);\n                }\n                break;\n                \n            case BubbleColor.YELLOW:\n                // Dots pattern\n                for (let x = -radius + (3 * HD_SCALE); x < radius; x += (4 * HD_SCALE)) {\n                    for (let y = -radius + (3 * HD_SCALE); y < radius; y += (4 * HD_SCALE)) {\n                        if (x * x + y * y < radius * radius * 0.7) {\n                            this.patternSprite.fillStyle(0xffffff, 0.5);\n                            this.patternSprite.fillCircle(x, y, 1 * HD_SCALE);\n                        }\n                    }\n                }\n                break;\n                \n            case BubbleColor.PURPLE:\n                // Cross-hatch pattern (X pattern)\n                for (let offset = -radius; offset < radius; offset += (3 * HD_SCALE)) {\n                    // Diagonal 1\n                    const x1 = Math.max(-radius * 0.7, offset - radius * 0.7);\n                    const y1 = Math.max(-radius * 0.7, -offset - radius * 0.7);\n                    const x2 = Math.min(radius * 0.7, offset + radius * 0.7);\n                    const y2 = Math.min(radius * 0.7, -offset + radius * 0.7);\n                    this.patternSprite.lineBetween(x1, y1, x2, y2);\n                    \n                    // Diagonal 2 (opposite)\n                    this.patternSprite.lineBetween(x1, -y1, x2, -y2);\n                }\n                break;\n        }\n    }\n\n    public pop(): void {\n        // Stop idle animation\n        if (this.idleAnimation) {\n            this.idleAnimation.stop();\n        }\n        \n        // Dynamic pop animation\n        this.scene.tweens.add({\n            targets: this,\n            scaleX: 1.3,\n            scaleY: 1.3,\n            alpha: 0,\n            duration: BUBBLE_CONFIG.ANIMATION_DURATION,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                this.setVisible(false);\n                this.returnToPool();\n            }\n        });\n        \n        // Rotate for dynamic effect\n        this.scene.tweens.add({\n            targets: this,\n            angle: Phaser.Math.Between(-45, 45),\n            duration: BUBBLE_CONFIG.ANIMATION_DURATION,\n            ease: 'Power2'\n        });\n        \n        // Create enhanced particle effect\n        this.createPopParticles();\n    }\n\n    private createPopParticles(): void {\n        // Premium particle explosion\n        const particleCount = 8;\n        const colors = [this.color, this.getLighterColor(this.color), 0xFFFFFF];\n        \n        for (let i = 0; i < particleCount; i++) {\n            const size = Phaser.Math.Between(2, 6);\n            const colorIndex = i % colors.length;\n            const particle = this.scene.add.circle(\n                this.x, \n                this.y, \n                size,\n                colors[colorIndex],\n                1\n            );\n            // NO BLEND MODE for performance\n            \n            const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.3;\n            const speed = Phaser.Math.Between(50, 150);\n            const rotationSpeed = Phaser.Math.Between(-360, 360);\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: this.x + Math.cos(angle) * speed,\n                y: this.y + Math.sin(angle) * speed + Phaser.Math.Between(-10, 30),\n                scale: 0,\n                alpha: 0,\n                angle: rotationSpeed,\n                duration: 400 + Math.random() * 100,\n                ease: 'Expo.easeOut',\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n        \n        // Simple flash effect for impact\n        const flash1 = this.scene.add.circle(this.x, this.y, BUBBLE_CONFIG.SIZE / 2, 0xFFFFFF, 0.4);\n        // NO BLEND MODE for performance\n        \n        this.scene.tweens.add({\n            targets: flash1,\n            scale: 2,\n            alpha: 0,\n            duration: 250,\n            ease: 'Power2',\n            onComplete: () => {\n                flash1.destroy();\n            }\n        });\n        \n        // Ring burst effect\n        const ring = this.scene.add.circle(this.x, this.y, BUBBLE_CONFIG.SIZE / 2, this.color, 0);\n        ring.setStrokeStyle(3, this.color, 0.8);\n        \n        this.scene.tweens.add({\n            targets: ring,\n            scale: 2.5,\n            alpha: 0,\n            duration: 300,\n            ease: 'Power2',\n            onComplete: () => {\n                ring.destroy();\n            }\n        });\n    }\n\n    public reset(x: number, y: number, color?: BubbleColor): void {\n        this.setPosition(x, y);\n        this.setAlpha(1);\n        this.setScale(1);\n        this.setVisible(true);\n        this.gridPosition = null;\n        this.isSpecial = false;\n        this.pooled = false;\n        \n        // Update color if provided\n        if (color !== undefined) {\n            this.setColor(color);\n        }\n    }\n\n    public returnToPool(): void {\n        this.pooled = true;\n        this.setVisible(false);\n        this.gridPosition = null;\n        // Reset position to avoid positioning bugs when reused\n        this.setPosition(0, 0);\n        this.setScale(1);\n        this.setAlpha(1);\n        this.setAngle(0);\n        this.clearTint();\n    }\n\n    public isPooled(): boolean {\n        return this.pooled;\n    }\n\n    public static getRandomColor(): BubbleColor {\n        const colors = [\n            BubbleColor.RED,\n            BubbleColor.BLUE,\n            BubbleColor.GREEN,\n            BubbleColor.YELLOW,\n            BubbleColor.PURPLE\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n}","import { Scene } from 'phaser';\n\n// Event types for different scoring scenarios\nexport enum ScoreEventType {\n    BUBBLE_MATCH = 'bubble_match',\n    ORPHAN_DROP = 'orphan_drop',\n    POWER_UP = 'power_up',\n    CHAIN_COMBO = 'chain_combo',\n    SPECIAL_BONUS = 'special_bonus',\n    OBJECTIVE_HIT = 'objective_hit',\n    TIME_BONUS = 'time_bonus',\n    PERFECT_SHOT = 'perfect_shot'\n}\n\n// Context for scoring calculation\nexport interface ScoreContext {\n    type: ScoreEventType;\n    baseValue: number;\n    position: { x: number; y: number };\n    matchSize?: number;\n    comboLevel?: number;\n    isPlayer: boolean;\n    bubbleColor?: number;\n    metadata?: Record<string, any>;\n}\n\n// Result of score calculation\nexport interface ScoreResult {\n    finalScore: number;\n    displayText: string;\n    visualEffectLevel: number; // 1-5 for effect intensity\n    color: number;\n    comboMultiplier?: number;\n}\n\n// Interface for scoring modules\nexport interface IScoringModule {\n    type: ScoreEventType;\n    calculateScore(context: ScoreContext): ScoreResult;\n    canProcess(context: ScoreContext): boolean;\n    priority: number; // Higher priority processes first\n}\n\n// Score event for queue processing\ninterface ScoreEvent {\n    context: ScoreContext;\n    timestamp: number;\n    processed: boolean;\n}\n\nexport class ScoreEventManager {\n    private scene: Scene;\n    private modules: Map<ScoreEventType, IScoringModule[]> = new Map();\n    private eventQueue: ScoreEvent[] = [];\n    private processing: boolean = false;\n    private totalPlayerScore: number = 0;\n    private totalOpponentScore: number = 0;\n    \n    // Performance optimization\n    private readonly MAX_QUEUE_SIZE = 50;\n    private readonly PROCESS_INTERVAL = 16; // ~60fps\n    \n    // Event callbacks\n    private scoreUpdateCallbacks: ((score: number, isPlayer: boolean) => void)[] = [];\n    private visualEffectCallbacks: ((result: ScoreResult, position: { x: number; y: number }) => void)[] = [];\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.initializeDefaultModules();\n        this.startProcessing();\n    }\n    \n    private initializeDefaultModules(): void {\n        // Register default scoring modules\n        this.registerModule(new BubbleMatchModule());\n        this.registerModule(new OrphanDropModule());\n        this.registerModule(new ChainComboModule());\n    }\n    \n    public registerModule(module: IScoringModule): void {\n        if (!this.modules.has(module.type)) {\n            this.modules.set(module.type, []);\n        }\n        \n        const modules = this.modules.get(module.type)!;\n        modules.push(module);\n        \n        // Sort by priority\n        modules.sort((a, b) => b.priority - a.priority);\n    }\n    \n    public queueEvent(context: ScoreContext): void {\n        // Add to queue\n        this.eventQueue.push({\n            context,\n            timestamp: Date.now(),\n            processed: false\n        });\n        \n        // Limit queue size for performance\n        if (this.eventQueue.length > this.MAX_QUEUE_SIZE) {\n            this.eventQueue.shift();\n        }\n    }\n    \n    private startProcessing(): void {\n        this.scene.time.addEvent({\n            delay: this.PROCESS_INTERVAL,\n            callback: this.processQueue,\n            callbackScope: this,\n            loop: true\n        });\n    }\n    \n    private processQueue(): void {\n        if (this.processing || this.eventQueue.length === 0) return;\n        \n        this.processing = true;\n        \n        // Process up to 5 events per frame to maintain performance\n        const eventsToProcess = Math.min(5, this.eventQueue.length);\n        \n        for (let i = 0; i < eventsToProcess; i++) {\n            const event = this.eventQueue.shift();\n            if (!event || event.processed) continue;\n            \n            this.processEvent(event);\n        }\n        \n        this.processing = false;\n    }\n    \n    private processEvent(event: ScoreEvent): void {\n        const { context } = event;\n        const modules = this.modules.get(context.type) || [];\n        \n        let finalResult: ScoreResult | null = null;\n        \n        // Process through all applicable modules\n        for (const module of modules) {\n            if (module.canProcess(context)) {\n                const result = module.calculateScore(context);\n                \n                // Combine results if multiple modules apply\n                if (finalResult) {\n                    finalResult.finalScore += result.finalScore;\n                    finalResult.visualEffectLevel = Math.max(\n                        finalResult.visualEffectLevel,\n                        result.visualEffectLevel\n                    );\n                } else {\n                    finalResult = result;\n                }\n            }\n        }\n        \n        if (finalResult) {\n            // Update scores\n            if (context.isPlayer) {\n                this.totalPlayerScore += finalResult.finalScore;\n                this.notifyScoreUpdate(this.totalPlayerScore, true);\n            } else {\n                this.totalOpponentScore += finalResult.finalScore;\n                this.notifyScoreUpdate(this.totalOpponentScore, false);\n            }\n            \n            // Trigger visual effects\n            this.notifyVisualEffect(finalResult, context.position);\n            \n            // Emit scene event for other systems\n            this.scene.events.emit('score-calculated', {\n                context,\n                result: finalResult\n            });\n        }\n        \n        event.processed = true;\n    }\n    \n    public onScoreUpdate(callback: (score: number, isPlayer: boolean) => void): void {\n        this.scoreUpdateCallbacks.push(callback);\n    }\n    \n    public onVisualEffect(callback: (result: ScoreResult, position: { x: number; y: number }) => void): void {\n        this.visualEffectCallbacks.push(callback);\n    }\n    \n    private notifyScoreUpdate(score: number, isPlayer: boolean): void {\n        this.scoreUpdateCallbacks.forEach(cb => cb(score, isPlayer));\n    }\n    \n    private notifyVisualEffect(result: ScoreResult, position: { x: number; y: number }): void {\n        this.visualEffectCallbacks.forEach(cb => cb(result, position));\n    }\n    \n    public getPlayerScore(): number {\n        return this.totalPlayerScore;\n    }\n    \n    public getOpponentScore(): number {\n        return this.totalOpponentScore;\n    }\n    \n    public reset(): void {\n        this.totalPlayerScore = 0;\n        this.totalOpponentScore = 0;\n        this.eventQueue = [];\n        this.processing = false;\n    }\n    \n    public destroy(): void {\n        this.reset();\n        this.modules.clear();\n        this.scoreUpdateCallbacks = [];\n        this.visualEffectCallbacks = [];\n    }\n}\n\n// Default Scoring Modules\n\nclass BubbleMatchModule implements IScoringModule {\n    type = ScoreEventType.BUBBLE_MATCH;\n    priority = 100;\n    \n    private readonly BASE_POINTS: { [key: number]: number } = {\n        3: 10,\n        4: 20,\n        5: 30,\n        6: 40,\n        7: 50\n    };\n    \n    canProcess(context: ScoreContext): boolean {\n        return context.type === this.type && (context.matchSize ?? 0) >= 3;\n    }\n    \n    calculateScore(context: ScoreContext): ScoreResult {\n        const matchSize = context.matchSize ?? 3;\n        const basePoints = this.BASE_POINTS[Math.min(matchSize, 7)] || this.BASE_POINTS[7];\n        \n        // Calculate multiplier and text based on match size\n        let multiplier = 1.0;\n        let displayText = `+${basePoints}`;\n        let effectLevel = 1;\n        \n        if (matchSize >= 7) {\n            multiplier = 2.0;\n            const finalScore = Math.floor(basePoints * multiplier);\n            displayText = `PERFECT!\\n+${finalScore}`;\n            effectLevel = 5;\n        } else if (matchSize >= 6) {\n            multiplier = 1.8;\n            const finalScore = Math.floor(basePoints * multiplier);\n            displayText = `AMAZING!\\n+${finalScore}`;\n            effectLevel = 4;\n        } else if (matchSize >= 5) {\n            multiplier = 1.5;\n            const finalScore = Math.floor(basePoints * multiplier);\n            displayText = `GREAT!\\n+${finalScore}`;\n            effectLevel = 3;\n        } else if (matchSize >= 4) {\n            multiplier = 1.2;\n            const finalScore = Math.floor(basePoints * multiplier);\n            displayText = `GOOD!\\n+${finalScore}`;\n            effectLevel = 2;\n        }\n        \n        return {\n            finalScore: Math.floor(basePoints * multiplier),\n            displayText,\n            visualEffectLevel: effectLevel,\n            color: context.bubbleColor || 0xFFD700,\n            comboMultiplier: multiplier\n        };\n    }\n}\n\nclass OrphanDropModule implements IScoringModule {\n    type = ScoreEventType.ORPHAN_DROP;\n    priority = 90;\n    \n    canProcess(context: ScoreContext): boolean {\n        return context.type === this.type;\n    }\n    \n    calculateScore(context: ScoreContext): ScoreResult {\n        const dropCount = context.metadata?.dropCount || 1;\n        const pointsPerDrop = 5;\n        const totalPoints = dropCount * pointsPerDrop;\n        \n        // Different text for different drop amounts\n        let displayText = '';\n        if (dropCount <= 3) {\n            displayText = `DROP!\\n+${totalPoints}`;\n        } else if (dropCount <= 6) {\n            displayText = `NICE DROP!\\n+${totalPoints}`;\n        } else {\n            displayText = `MEGA DROP!\\n+${totalPoints}`;\n        }\n        \n        return {\n            finalScore: totalPoints,\n            displayText,\n            visualEffectLevel: Math.min(Math.ceil(dropCount / 3), 3),\n            color: 0x00BFFF,\n            comboMultiplier: 1.0\n        };\n    }\n}\n\nclass ChainComboModule implements IScoringModule {\n    type = ScoreEventType.CHAIN_COMBO;\n    priority = 80;\n    \n    private chainCount: number = 0;\n    private lastChainTime: number = 0;\n    private readonly CHAIN_TIMEOUT = 2000;\n    \n    canProcess(context: ScoreContext): boolean {\n        if (context.type !== ScoreEventType.BUBBLE_MATCH) return false;\n        \n        const now = Date.now();\n        const isChain = (now - this.lastChainTime) < this.CHAIN_TIMEOUT;\n        \n        if (isChain) {\n            this.chainCount++;\n        } else {\n            this.chainCount = 0;\n        }\n        \n        this.lastChainTime = now;\n        return isChain && this.chainCount > 1;\n    }\n    \n    calculateScore(context: ScoreContext): ScoreResult {\n        const chainBonus = this.chainCount * 10;\n        \n        return {\n            finalScore: chainBonus,\n            displayText: `CHAIN x${this.chainCount}`,\n            visualEffectLevel: Math.min(this.chainCount, 4),\n            color: 0xFF69B4,\n            comboMultiplier: 1.0 + (this.chainCount * 0.1)\n        };\n    }\n}","import { Scene } from 'phaser';\nimport { ScoreEventManager, ScoreEventType } from '../scoring/ScoreEventManager';\n\n// Power-up types\nexport enum PowerUpType {\n    BOMB = 'bomb',           // Explodes in area\n    LASER = 'laser',         // Destroys entire line\n    RAINBOW = 'rainbow',     // Matches any color\n    MULTIPLIER = 'multiplier', // Score multiplier\n    FREEZE = 'freeze',       // Slows down time\n    LIGHTNING = 'lightning', // Chain reaction\n    MAGNET = 'magnet',      // Attracts bubbles\n    SHIELD = 'shield'       // Protection from danger\n}\n\n// Power-up configuration\nexport interface PowerUpConfig {\n    type: PowerUpType;\n    name: string;\n    description: string;\n    icon: string;\n    color: number;\n    rarity: number; // 1-5 (common to legendary)\n    duration?: number; // For time-based power-ups\n    radius?: number; // For area effects\n    power?: number; // Effect strength\n}\n\n// Power-up instance\nexport interface PowerUp {\n    id: string;\n    type: PowerUpType;\n    config: PowerUpConfig;\n    active: boolean;\n    position?: { x: number; y: number };\n    owner: 'player' | 'opponent';\n    activatedAt?: number;\n    expiresAt?: number;\n}\n\n// Power-up effect handler\nexport interface IPowerUpEffect {\n    type: PowerUpType;\n    canActivate(powerUp: PowerUp, target?: any): boolean;\n    activate(powerUp: PowerUp, target?: any): void;\n    update?(powerUp: PowerUp, delta: number): void;\n    deactivate(powerUp: PowerUp): void;\n}\n\nexport class PowerUpManager {\n    private scene: Scene;\n    private scoreEventManager?: ScoreEventManager;\n    private powerUps: Map<string, PowerUp> = new Map();\n    private effects: Map<PowerUpType, IPowerUpEffect> = new Map();\n    private activePowerUps: PowerUp[] = [];\n    \n    // Power-up configurations\n    private readonly POWER_UP_CONFIGS: Map<PowerUpType, PowerUpConfig> = new Map([\n        [PowerUpType.BOMB, {\n            type: PowerUpType.BOMB,\n            name: 'Bomb',\n            description: 'Explodes bubbles in area',\n            icon: '💣',\n            color: 0xFF4500,\n            rarity: 2,\n            radius: 100,\n            power: 3\n        }],\n        [PowerUpType.LASER, {\n            type: PowerUpType.LASER,\n            name: 'Laser',\n            description: 'Destroys entire line',\n            icon: '⚡',\n            color: 0x00FFFF,\n            rarity: 3,\n            power: 5\n        }],\n        [PowerUpType.RAINBOW, {\n            type: PowerUpType.RAINBOW,\n            name: 'Rainbow',\n            description: 'Matches any color',\n            icon: '🌈',\n            color: 0xFF69B4,\n            rarity: 4,\n            duration: 10000\n        }],\n        [PowerUpType.MULTIPLIER, {\n            type: PowerUpType.MULTIPLIER,\n            name: 'Score x2',\n            description: 'Doubles score for 30 seconds',\n            icon: '✨',\n            color: 0xFFD700,\n            rarity: 3,\n            duration: 30000,\n            power: 2\n        }],\n        [PowerUpType.FREEZE, {\n            type: PowerUpType.FREEZE,\n            name: 'Freeze',\n            description: 'Slows down time',\n            icon: '❄️',\n            color: 0x87CEEB,\n            rarity: 2,\n            duration: 15000,\n            power: 0.5\n        }],\n        [PowerUpType.LIGHTNING, {\n            type: PowerUpType.LIGHTNING,\n            name: 'Lightning',\n            description: 'Chain reaction destruction',\n            icon: '⚡',\n            color: 0xFFFF00,\n            rarity: 5,\n            power: 7\n        }],\n        [PowerUpType.MAGNET, {\n            type: PowerUpType.MAGNET,\n            name: 'Magnet',\n            description: 'Attracts matching bubbles',\n            icon: '🧲',\n            color: 0x808080,\n            rarity: 3,\n            duration: 20000,\n            radius: 150\n        }],\n        [PowerUpType.SHIELD, {\n            type: PowerUpType.SHIELD,\n            name: 'Shield',\n            description: 'Protection from danger',\n            icon: '🛡️',\n            color: 0x4169E1,\n            rarity: 4,\n            duration: 45000\n        }]\n    ]);\n    \n    constructor(scene: Scene, scoreEventManager?: ScoreEventManager) {\n        this.scene = scene;\n        this.scoreEventManager = scoreEventManager;\n        this.initializeEffects();\n    }\n    \n    private initializeEffects(): void {\n        // Register default power-up effects\n        this.registerEffect(new BombEffect(this.scene));\n        this.registerEffect(new MultiplierEffect(this.scene));\n        // Add more effects as needed\n    }\n    \n    public registerEffect(effect: IPowerUpEffect): void {\n        this.effects.set(effect.type, effect);\n    }\n    \n    public createPowerUp(type: PowerUpType, owner: 'player' | 'opponent', position?: { x: number; y: number }): PowerUp | null {\n        const config = this.POWER_UP_CONFIGS.get(type);\n        if (!config) return null;\n        \n        const powerUp: PowerUp = {\n            id: `${type}_${Date.now()}_${Math.random()}`,\n            type,\n            config,\n            active: false,\n            owner,\n            position\n        };\n        \n        this.powerUps.set(powerUp.id, powerUp);\n        return powerUp;\n    }\n    \n    public activatePowerUp(powerUpId: string, target?: any): boolean {\n        const powerUp = this.powerUps.get(powerUpId);\n        if (!powerUp || powerUp.active) return false;\n        \n        const effect = this.effects.get(powerUp.type);\n        if (!effect || !effect.canActivate(powerUp, target)) return false;\n        \n        // Mark as active\n        powerUp.active = true;\n        powerUp.activatedAt = Date.now();\n        \n        // Set expiration if duration-based\n        if (powerUp.config.duration) {\n            powerUp.expiresAt = Date.now() + powerUp.config.duration;\n        }\n        \n        // Add to active list\n        this.activePowerUps.push(powerUp);\n        \n        // Activate effect\n        effect.activate(powerUp, target);\n        \n        // Emit event for scoring\n        if (this.scoreEventManager) {\n            this.scoreEventManager.queueEvent({\n                type: ScoreEventType.POWER_UP,\n                baseValue: 100, // Base points for using power-up\n                position: powerUp.position || { x: 0, y: 0 },\n                isPlayer: powerUp.owner === 'player',\n                metadata: {\n                    powerUpType: powerUp.type,\n                    rarity: powerUp.config.rarity\n                }\n            });\n        }\n        \n        // Show activation feedback\n        this.showActivationFeedback(powerUp);\n        \n        return true;\n    }\n    \n    private showActivationFeedback(powerUp: PowerUp): void {\n        if (!powerUp.position) return;\n        \n        // Create activation visual\n        const flash = this.scene.add.graphics();\n        flash.fillStyle(powerUp.config.color, 0.5);\n        flash.fillCircle(0, 0, 50);\n        flash.setPosition(powerUp.position.x, powerUp.position.y);\n        flash.setDepth(1500);\n        flash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        // Animate\n        this.scene.tweens.add({\n            targets: flash,\n            alpha: 0,\n            scale: 3,\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                flash.destroy();\n            }\n        });\n        \n        // Show power-up name\n        const text = this.scene.add.text(\n            powerUp.position.x,\n            powerUp.position.y - 30,\n            powerUp.config.name.toUpperCase(),\n            {\n                fontSize: '28px',\n                color: '#FFFFFF',\n                fontFamily: 'Arial Black',\n                stroke: '#000000',\n                strokeThickness: 4\n            }\n        );\n        text.setOrigin(0.5);\n        text.setDepth(1501);\n        \n        this.scene.tweens.add({\n            targets: text,\n            y: text.y - 50,\n            alpha: 0,\n            scale: 1.5,\n            duration: 1000,\n            ease: 'Power2.easeOut',\n            onComplete: () => {\n                text.destroy();\n            }\n        });\n    }\n    \n    public update(delta: number): void {\n        const now = Date.now();\n        \n        // Update active power-ups\n        this.activePowerUps = this.activePowerUps.filter(powerUp => {\n            // Check expiration\n            if (powerUp.expiresAt && now >= powerUp.expiresAt) {\n                this.deactivatePowerUp(powerUp);\n                return false;\n            }\n            \n            // Update effect\n            const effect = this.effects.get(powerUp.type);\n            if (effect && effect.update) {\n                effect.update(powerUp, delta);\n            }\n            \n            return powerUp.active;\n        });\n    }\n    \n    private deactivatePowerUp(powerUp: PowerUp): void {\n        powerUp.active = false;\n        \n        const effect = this.effects.get(powerUp.type);\n        if (effect) {\n            effect.deactivate(powerUp);\n        }\n        \n        // Remove from active list\n        const index = this.activePowerUps.indexOf(powerUp);\n        if (index > -1) {\n            this.activePowerUps.splice(index, 1);\n        }\n    }\n    \n    public getActivePowerUps(owner?: 'player' | 'opponent'): PowerUp[] {\n        if (owner) {\n            return this.activePowerUps.filter(p => p.owner === owner);\n        }\n        return [...this.activePowerUps];\n    }\n    \n    public hasActivePowerUp(type: PowerUpType, owner?: 'player' | 'opponent'): boolean {\n        return this.activePowerUps.some(p => \n            p.type === type && (!owner || p.owner === owner)\n        );\n    }\n    \n    public reset(): void {\n        // Deactivate all power-ups\n        this.activePowerUps.forEach(powerUp => {\n            this.deactivatePowerUp(powerUp);\n        });\n        \n        this.powerUps.clear();\n        this.activePowerUps = [];\n    }\n    \n    public destroy(): void {\n        this.reset();\n        this.effects.clear();\n    }\n}\n\n// Example Power-Up Effects\n\nclass BombEffect implements IPowerUpEffect {\n    type = PowerUpType.BOMB;\n    private scene: Scene;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n    }\n    \n    canActivate(powerUp: PowerUp, target?: any): boolean {\n        return powerUp.position !== undefined;\n    }\n    \n    activate(powerUp: PowerUp, target?: any): void {\n        if (!powerUp.position) return;\n        \n        const radius = powerUp.config.radius || 100;\n        \n        // Create explosion visual\n        const explosion = this.scene.add.circle(\n            powerUp.position.x,\n            powerUp.position.y,\n            radius,\n            0xFF4500,\n            0.3\n        );\n        explosion.setDepth(1000);\n        \n        this.scene.tweens.add({\n            targets: explosion,\n            scale: { from: 0, to: 1 },\n            alpha: { from: 0.8, to: 0 },\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                explosion.destroy();\n            }\n        });\n        \n        // Emit event to destroy bubbles in radius\n        this.scene.events.emit('bomb-exploded', {\n            position: powerUp.position,\n            radius,\n            owner: powerUp.owner\n        });\n    }\n    \n    deactivate(powerUp: PowerUp): void {\n        // Bomb is instant, no deactivation needed\n    }\n}\n\nclass MultiplierEffect implements IPowerUpEffect {\n    type = PowerUpType.MULTIPLIER;\n    private scene: Scene;\n    private originalMultiplier: number = 1;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n    }\n    \n    canActivate(powerUp: PowerUp): boolean {\n        return true;\n    }\n    \n    activate(powerUp: PowerUp): void {\n        // Store original multiplier and apply new one\n        const multiplier = powerUp.config.power || 2;\n        \n        // Emit event to apply multiplier\n        this.scene.events.emit('score-multiplier-changed', {\n            multiplier,\n            owner: powerUp.owner\n        });\n        \n        // Show multiplier indicator\n        if (powerUp.owner === 'player') {\n            this.showMultiplierIndicator(multiplier);\n        }\n    }\n    \n    update(powerUp: PowerUp, delta: number): void {\n        // Could show remaining time\n        if (powerUp.expiresAt) {\n            const remaining = Math.max(0, powerUp.expiresAt - Date.now());\n            // Update UI with remaining time\n        }\n    }\n    \n    deactivate(powerUp: PowerUp): void {\n        // Reset multiplier\n        this.scene.events.emit('score-multiplier-changed', {\n            multiplier: 1,\n            owner: powerUp.owner\n        });\n    }\n    \n    private showMultiplierIndicator(multiplier: number): void {\n        const indicator = this.scene.add.text(\n            this.scene.cameras.main.centerX,\n            100,\n            `SCORE x${multiplier}`,\n            {\n                fontSize: '32px',\n                color: '#FFD700',\n                fontFamily: 'Arial Black',\n                stroke: '#000000',\n                strokeThickness: 4\n            }\n        );\n        indicator.setOrigin(0.5);\n        indicator.setDepth(1500);\n        \n        this.scene.tweens.add({\n            targets: indicator,\n            scale: { from: 0, to: 1.2 },\n            duration: 500,\n            ease: 'Back.easeOut',\n            yoyo: true,\n            hold: 1000,\n            onComplete: () => {\n                indicator.destroy();\n            }\n        });\n    }\n}","import { Scene } from 'phaser';\nimport { Bubble } from './Bubble';\nimport { PowerUpType } from '@/systems/powerups/PowerUpManager';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\n\n/**\n * Mystery Bubble that cycles through different power-ups\n * Shows the current power-up icon inside a semi-transparent bubble\n */\nexport class MysteryBubble extends Bubble {\n    private powerUpIcon!: Phaser.GameObjects.Text;\n    private currentPowerUp: PowerUpType;\n    private powerUpCycleTimer?: Phaser.Time.TimerEvent;\n    private glowEffect!: Phaser.GameObjects.Graphics;\n    private iconBg!: Phaser.GameObjects.Graphics;\n    \n    // Power-up rotation sequence\n    private powerUpSequence: PowerUpType[] = [\n        PowerUpType.RAINBOW,\n        PowerUpType.BOMB,\n        PowerUpType.LIGHTNING,\n        PowerUpType.FREEZE,\n        PowerUpType.LASER,\n        PowerUpType.MULTIPLIER\n    ];\n    private sequenceIndex: number = 0;\n    \n    // Power-up icons and colors\n    private powerUpIcons: Record<PowerUpType, { icon: string; color: number }> = {\n        [PowerUpType.RAINBOW]: { icon: '🌈', color: 0xFF69B4 },\n        [PowerUpType.BOMB]: { icon: '💣', color: 0xFF4500 },\n        [PowerUpType.LIGHTNING]: { icon: '⚡', color: 0xFFD700 },\n        [PowerUpType.FREEZE]: { icon: '❄️', color: 0x00CED1 },\n        [PowerUpType.LASER]: { icon: '🎯', color: 0x00FF00 },\n        [PowerUpType.MULTIPLIER]: { icon: '✨', color: 0x9370DB },\n        [PowerUpType.SHIELD]: { icon: '🛡️', color: 0x4169E1 },\n        [PowerUpType.MAGNET]: { icon: '🧲', color: 0xDC143C }\n    };\n    \n    constructor(scene: Scene, x: number, y: number) {\n        // Use random color as base\n        super(scene, x, y, Bubble.getRandomColor());\n        \n        // Start with a random power-up\n        this.sequenceIndex = Math.floor(Math.random() * this.powerUpSequence.length);\n        this.currentPowerUp = this.powerUpSequence[this.sequenceIndex];\n        \n        this.createMysteryVisuals();\n        this.startPowerUpCycle();\n    }\n    \n    private createMysteryVisuals(): void {\n        // Make base bubble semi-transparent so we can see the power-up inside\n        const bubbleSprite = this.list[0] as Phaser.GameObjects.Arc;\n        if (bubbleSprite) {\n            bubbleSprite.setAlpha(0.4); // Semi-transparent\n        }\n        \n        // Create a subtle glow effect\n        this.glowEffect = this.scene.add.graphics();\n        this.updateGlowEffect();\n        this.addAt(this.glowEffect, 0); // Add behind bubble\n        \n        // Create icon background circle for better visibility - LARGER\n        this.iconBg = this.scene.add.graphics();\n        this.iconBg.fillStyle(0x000000, 0.3);\n        this.iconBg.fillCircle(0, 0, 10 * HD_SCALE);\n        this.add(this.iconBg);\n        \n        // Create power-up icon - MUCH LARGER for visibility\n        this.powerUpIcon = this.scene.add.text(0, 0, '', {\n            fontSize: `${14 * HD_SCALE}px`,\n            fontFamily: 'Arial'\n        });\n        this.powerUpIcon.setOrigin(0.5);\n        this.add(this.powerUpIcon);\n        \n        // Update to show current power-up\n        this.updatePowerUpDisplay();\n        \n        // Add subtle pulse animation\n        this.scene.tweens.add({\n            targets: [this.powerUpIcon, this.iconBg],\n            scale: { from: 0.9, to: 1.1 },\n            duration: 1500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n    }\n    \n    private updateGlowEffect(): void {\n        if (!this.glowEffect) return;\n        \n        this.glowEffect.clear();\n        const config = this.powerUpIcons[this.currentPowerUp];\n        \n        // Create gradient glow - LARGER for bigger icon\n        this.glowEffect.fillStyle(config.color, 0.2);\n        this.glowEffect.fillCircle(0, 0, 14 * HD_SCALE);\n        this.glowEffect.fillStyle(config.color, 0.1);\n        this.glowEffect.fillCircle(0, 0, 18 * HD_SCALE);\n    }\n    \n    private updatePowerUpDisplay(): void {\n        const config = this.powerUpIcons[this.currentPowerUp];\n        this.powerUpIcon.setText(config.icon);\n        \n        // Update glow color\n        this.updateGlowEffect();\n        \n        // Add a small pop animation when changing\n        this.scene.tweens.add({\n            targets: this.powerUpIcon,\n            scale: { from: 1.3, to: 1 },\n            duration: 300,\n            ease: 'Back.easeOut'\n        });\n    }\n    \n    private startPowerUpCycle(): void {\n        // Change power-up every 2-3 seconds\n        const cycleFunction = () => {\n            this.cyclePowerUp();\n            // Schedule next cycle\n            this.powerUpCycleTimer = this.scene.time.delayedCall(\n                Phaser.Math.Between(2000, 3000),\n                cycleFunction\n            );\n        };\n        \n        // Start the first cycle\n        this.powerUpCycleTimer = this.scene.time.delayedCall(\n            Phaser.Math.Between(2000, 3000),\n            cycleFunction\n        );\n    }\n    \n    private cyclePowerUp(): void {\n        // Move to next power-up in sequence\n        this.sequenceIndex = (this.sequenceIndex + 1) % this.powerUpSequence.length;\n        this.currentPowerUp = this.powerUpSequence[this.sequenceIndex] || PowerUpType.RAINBOW;\n        this.updatePowerUpDisplay();\n    }\n    \n    /**\n     * Get the current power-up type\n     */\n    public getCurrentPowerUp(): PowerUpType {\n        return this.currentPowerUp;\n    }\n    \n    /**\n     * Override to identify as mystery bubble\n     */\n    public isMysteryBubble(): boolean {\n        return true;\n    }\n    \n    /**\n     * Collect power-up when bubble is destroyed\n     */\n    public collectPowerUp(isPlayerShot: boolean = true): void {\n        // console.log(`Collecting power-up: ${this.currentPowerUp} at position (${this.x}, ${this.y}) for ${isPlayerShot ? 'player' : 'opponent'}`);\n        \n        // Create visual feedback at bubble position\n        const config = this.powerUpIcons[this.currentPowerUp];\n        \n        // Create large icon that floats up and fades - LARGER\n        const floatingIcon = this.scene.add.text(this.x, this.y, config.icon, {\n            fontSize: `${24 * HD_SCALE}px`,\n            fontFamily: 'Arial'\n        });\n        floatingIcon.setOrigin(0.5);\n        floatingIcon.setDepth(Z_LAYERS.FLOATING_UI);\n        \n        // Add \"POWER-UP!\" text - LARGER\n        const powerUpText = this.scene.add.text(this.x, this.y + (15 * HD_SCALE), 'POWER-UP!', {\n            fontSize: `${12 * HD_SCALE}px`,\n            fontFamily: 'Arial Black',\n            color: '#FFFFFF',\n            stroke: '#000000',\n            strokeThickness: 2 * HD_SCALE\n        });\n        powerUpText.setOrigin(0.5);\n        powerUpText.setDepth(Z_LAYERS.FLOATING_UI);\n        \n        // Animate both elements\n        this.scene.tweens.add({\n            targets: [floatingIcon, powerUpText],\n            y: this.y - (25 * HD_SCALE),\n            alpha: 0,\n            scale: 1.5,\n            duration: 1000,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                floatingIcon.destroy();\n                powerUpText.destroy();\n            }\n        });\n        \n        // Flash effect\n        const flash = this.scene.add.circle(this.x, this.y, 15 * HD_SCALE, config.color, 0.5);\n        flash.setDepth(Z_LAYERS.FLOATING_UI - 1);\n        \n        this.scene.tweens.add({\n            targets: flash,\n            scale: 2,\n            alpha: 0,\n            duration: 400,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                flash.destroy();\n            }\n        });\n        \n        // Emit event to add power-up to inventory\n        // Owner is determined by who shot the bubble that caused the match\n        const owner = isPlayerShot ? 'player' : 'opponent';\n        // console.log(`Emitting power-up-collected event: type=${this.currentPowerUp}, owner=${owner}`);\n        \n        this.scene.events.emit('power-up-collected', {\n            type: this.currentPowerUp,\n            x: this.x,\n            y: this.y,\n            owner: owner\n        });\n    }\n    \n    public override destroy(): void {\n        // console.log('MysteryBubble destroy called, visible:', this.visible);\n        \n        if (this.powerUpCycleTimer) {\n            this.powerUpCycleTimer.destroy();\n        }\n        \n        // Note: Power-ups are collected through MatchDetectionSystem now\n        // This destroy method is called when returning to pool, not when collecting\n        \n        super.destroy();\n    }\n}","import { ArenaZone, BubbleColor } from '@/types/ArenaTypes';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\nimport { Bubble } from './Bubble';\nimport { PowerUpType } from '@/systems/powerups/PowerUpManager';\n\n// Arsenal slot interface for integrated weapon system\ninterface ArsenalSlot {\n    container: Phaser.GameObjects.Container;\n    background: Phaser.GameObjects.Graphics;\n    icon: Phaser.GameObjects.Text;\n    countText: Phaser.GameObjects.Text;\n    energyConduit?: Phaser.GameObjects.Graphics;\n    position: { x: number, y: number };\n    powerUpType: PowerUpType | undefined;\n    count: number;\n    isActive: boolean;\n    cooldownOverlay?: Phaser.GameObjects.Graphics;\n    progressArc?: Phaser.GameObjects.Graphics;\n}\n\n/**\n * EXCEPTIONAL LAUNCHER - Premium Mobile-First Game Experience\n * \n * A sophisticated, unified launcher optimized for mobile devices (375x667px).\n * Every detail is crafted for mobile clarity, accessibility, and engaging gameplay.\n * \n * MOBILE-FIRST DESIGN PRINCIPLES:\n * - INTEGRATED: Uses existing BUBBLE_POSITION_Y (-35) for loaded bubble\n * - UNIFIED: Uses existing QUEUE_POSITION_Y (5) for next bubble preview\n * - ACCESSIBLE: 120px touch areas exceed Apple/Android minimums (44px/48dp)\n * - CLEAR: Visual hierarchy clearly distinguishes loaded vs next bubble\n * - OPTIMIZED: Larger text, thicker borders, enhanced contrast for mobile\n * - ENGAGING: Premium animations and feedback designed for mobile sessions\n * \n * VISUAL HIERARCHY:\n * - TOP (-35px): Main firing chamber with loaded bubble (ready to shoot)\n * - BOTTOM (5px): Integrated queue chamber with next bubble (preview)\n * - UNIFIED DESIGN: Single cohesive launcher body connects both chambers\n * \n * MOBILE UX FEATURES:\n * - 120px touch areas for excellent mobile accessibility\n * - Enhanced visual feedback with satisfying animations\n * - Clear state indicators (idle, aiming, charging, ready, cooldown)\n * - Premium mobile interactions with haptic-like feedback\n * - Optimized performance for mobile devices\n */\nexport class Launcher extends Phaser.GameObjects.Container {\n    // === CORE COMPONENTS ===\n    private launcherPlatform?: Phaser.GameObjects.Container;\n    private bubbleChamber?: Phaser.GameObjects.Container;\n    private queuePanel?: Phaser.GameObjects.Container;\n    private effectsLayer?: Phaser.GameObjects.Container;\n    \n    // === VISUAL ELEMENTS ===\n    private platformGraphics: Phaser.GameObjects.Graphics | undefined;\n    private chamberGraphics: Phaser.GameObjects.Graphics | undefined;\n    private queueBackground: Phaser.GameObjects.Graphics | undefined;\n    private queueLabel?: Phaser.GameObjects.Text;\n    private glowEffect: Phaser.GameObjects.Graphics | undefined;\n    \n    // === ENHANCED UX ELEMENTS ===\n    private stateIndicator: Phaser.GameObjects.Graphics | undefined;\n    private readyIndicator: Phaser.GameObjects.Arc | undefined;\n    private queueContainer?: Phaser.GameObjects.Container;\n    private nextBubbleFrame: Phaser.GameObjects.Graphics | undefined;\n    private nextBubbleGraphics: Phaser.GameObjects.Graphics | undefined;\n    private secondBubbleGraphics: Phaser.GameObjects.Graphics | undefined;\n    \n    // === ARSENAL INTEGRATION ===\n    private arsenalSlots: ArsenalSlot[] = [];\n    private weaponRing?: Phaser.GameObjects.Container;\n    private energyConduits: Phaser.GameObjects.Graphics | undefined;\n    private activePowerUp?: PowerUpType;\n    private arsenalContainer?: Phaser.GameObjects.Container;\n    \n    // === ANIMATION SYSTEMS ===\n    private idleAnimation?: Phaser.Tweens.Tween;\n    private chargingTween?: Phaser.Tweens.Tween;\n    private particles?: Phaser.GameObjects.Particles.ParticleEmitter;\n    \n    // === STATE MANAGEMENT ===\n    private zone: ArenaZone;\n    private currentAngle: number = 0;\n    private loadedBubble: Bubble | undefined;\n    private nextBubbleColors: BubbleColor[] = [];\n    private currentTheme: any;\n    private isAiming: boolean = false;\n    private isOpponent: boolean;\n    \n    // === ENHANCED STATE ===\n    private launcherState: 'idle' | 'aiming' | 'charging' | 'ready' | 'cooldown' = 'idle';\n    private powerLevel: number = 0;\n    \n    // === POSITIONING CONSTANTS ===\n    private readonly BUBBLE_POSITION_Y: number;\n    private readonly QUEUE_POSITION_Y: number;\n    \n    // === ARSENAL POSITIONING ===\n    // Better spacing: more separation between slots\n    private readonly ARSENAL_POSITIONS_PLAYER = [\n        { x: 70 * HD_SCALE, y: -35 * HD_SCALE },     // First slot with good separation\n        { x: 110 * HD_SCALE, y: -35 * HD_SCALE },    // 40 unit spacing between slots\n        { x: 150 * HD_SCALE, y: -35 * HD_SCALE }     // More spread out\n    ];\n    private readonly ARSENAL_POSITIONS_OPPONENT = [\n        { x: -70 * HD_SCALE, y: -35 * HD_SCALE },    // Mirror positions for opponent\n        { x: -110 * HD_SCALE, y: -35 * HD_SCALE },\n        { x: -150 * HD_SCALE, y: -35 * HD_SCALE }\n    ];\n    private readonly SLOT_SIZE = 25 * HD_SCALE;  // Further reduced for better spacing\n    \n    // Power-up icons\n    private powerUpIcons: Record<PowerUpType, string> = {\n        [PowerUpType.RAINBOW]: '🌈',\n        [PowerUpType.BOMB]: '💣',\n        [PowerUpType.LIGHTNING]: '⚡',\n        [PowerUpType.FREEZE]: '❄️',\n        [PowerUpType.LASER]: '🎯',\n        [PowerUpType.MULTIPLIER]: '✨',\n        [PowerUpType.SHIELD]: '🛡️',\n        [PowerUpType.MAGNET]: '🧲'\n    };\n\n    constructor(scene: Phaser.Scene, x: number, y: number, zone: ArenaZone) {\n        super(scene, x, y);\n        \n        this.zone = zone;\n        this.isOpponent = (zone === ArenaZone.OPPONENT);\n        \n        // MOBILE-FIRST POSITIONING: Optimized for 375x667px mobile screens\n        this.BUBBLE_POSITION_Y = -28 * HD_SCALE;  // Main chamber position\n        this.QUEUE_POSITION_Y = 25 * HD_SCALE;     // Queue loading chamber position\n        \n        if (this.isOpponent) {\n            this.currentAngle = 90;\n            // Flip the entire launcher for opponent\n            this.setScale(1, -1);\n        } else {\n            this.currentAngle = 270;\n        }\n        \n        // Build the exceptional launcher\n        this.createExceptionalLauncher();\n        \n        // Create integrated arsenal for both player and opponent\n        this.createIntegratedArsenal();\n        \n        this.setDepth(Z_LAYERS.LAUNCHERS);\n        scene.add.existing(this);\n        \n        // Initialize with accessible theme\n        this.updateTheme(BubbleColor.BLUE);\n        this.startEnhancedIdleAnimations();\n        \n        // Setup arsenal event listeners\n        this.setupArsenalListeners();\n        \n        // Add touch area for better mobile interaction\n        this.setupMobileTouchArea();\n    }\n\n    /**\n     * Creates the premium launcher experience with unified design\n     */\n    private createExceptionalLauncher(): void {\n        // Create in perfect hierarchy order\n        this.createLauncherPlatform();\n        this.createBubbleChamber();\n        this.createEnhancedQueueSystem();  // ENHANCED: More visible queue system\n        this.createStateIndicators();       // NEW: Visual state feedback\n        this.createEffectsLayer();\n        \n        // Add all components with perfect layering\n        this.add([\n            this.launcherPlatform!,\n            this.bubbleChamber!,\n            this.queueContainer!,\n            this.effectsLayer!\n        ]);\n    }\n\n    /**\n     * Creates the sophisticated launcher platform\n     */\n    private createLauncherPlatform(): void {\n        this.launcherPlatform = this.scene.add.container(0, 0);\n        this.platformGraphics = this.scene.add.graphics();\n        this.launcherPlatform.add(this.platformGraphics);\n    }\n\n    /**\n     * Creates the premium bubble chamber with perfect positioning\n     */\n    private createBubbleChamber(): void {\n        this.bubbleChamber = this.scene.add.container(0, this.BUBBLE_POSITION_Y);\n        this.chamberGraphics = this.scene.add.graphics();\n        this.glowEffect = this.scene.add.graphics();\n        \n        this.bubbleChamber.add([this.glowEffect, this.chamberGraphics]);\n    }\n\n    /**\n     * ENHANCED: Mobile-first integrated queue system using proper positioning\n     */\n    private createEnhancedQueueSystem(): void {\n        // Use the defined QUEUE_POSITION_Y properly - no arbitrary offset\n        this.queueContainer = this.scene.add.container(0, this.QUEUE_POSITION_Y);\n        \n        // Enhanced queue background with mobile-optimized design\n        this.queueBackground = this.scene.add.graphics();\n        \n        // Next bubble frame indicator with better mobile visibility\n        this.nextBubbleFrame = this.scene.add.graphics();\n        \n        this.queueContainer.add([this.queueBackground, this.nextBubbleFrame]);\n        \n        // No rotation on the whole container - bubbles will have their own animations\n    }\n\n    /**\n     * NEW: Creates visual state indicators for better UX\n     */\n    private createStateIndicators(): void {\n        // State indicator as graphics for drawing\n        this.stateIndicator = this.scene.add.graphics();\n        this.add(this.stateIndicator);\n        \n        // Ready indicator ring around chamber - no default color\n        this.readyIndicator = this.scene.add.circle(0, this.BUBBLE_POSITION_Y, 28 * HD_SCALE, 0x000000, 0);\n        this.readyIndicator.setStrokeStyle(2 * HD_SCALE, 0x000000, 0);\n        this.readyIndicator.setVisible(false);\n        this.add(this.readyIndicator);\n    }\n\n    /**\n     * Creates effects layer for particles and animations\n     */\n    private createEffectsLayer(): void {\n        this.effectsLayer = this.scene.add.container(0, 0);\n    }\n\n    /**\n     * Renders all visual components with unified design\n     */\n    private updateAllVisuals(): void {\n        this.renderLauncherPlatform();\n        this.renderBubbleChamber();\n        this.renderEnhancedQueue();\n        this.renderStateIndicators();\n        this.renderGlowEffects();\n    }\n\n    /**\n     * Renders the sophisticated launcher platform\n     */\n    private renderLauncherPlatform(): void {\n        if (!this.platformGraphics || !this.currentTheme) return;\n        \n        this.platformGraphics.clear();\n        \n        // Create a compact integrated launcher design\n        const topY = this.BUBBLE_POSITION_Y;\n        const bottomY = this.QUEUE_POSITION_Y;\n        const height = Math.abs(bottomY - topY);\n        \n        // Energy flow tube connecting chambers\n        const columnWidth = 24 * HD_SCALE;\n        \n        // Draw energy conduit\n        this.platformGraphics.fillGradientStyle(\n            this.currentTheme.platform.top,\n            this.currentTheme.platform.top,\n            this.currentTheme.platform.bottom,\n            this.currentTheme.platform.bottom,\n            1, 1, 0.7, 0.7\n        );\n        this.platformGraphics.fillRoundedRect(\n            -columnWidth/2, \n            topY + (14 * HD_SCALE), \n            columnWidth, \n            height - (22 * HD_SCALE), \n            8 * HD_SCALE\n        );\n        \n        // Energy flow lines\n        this.platformGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.chamber.highlight, 0.3);\n        this.platformGraphics.lineBetween(-columnWidth/3, topY + 20 * HD_SCALE, -columnWidth/3, bottomY - 10 * HD_SCALE);\n        this.platformGraphics.lineBetween(columnWidth/3, topY + 20 * HD_SCALE, columnWidth/3, bottomY - 10 * HD_SCALE);\n        \n        // Subtle border\n        this.platformGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.platform.rim, 0.3);\n        this.platformGraphics.strokeRoundedRect(\n            -columnWidth/2, \n            topY + (14 * HD_SCALE), \n            columnWidth, \n            height - (22 * HD_SCALE), \n            8 * HD_SCALE\n        );\n    }\n\n    /**\n     * Renders the premium bubble chamber with perfect depth\n     */\n    private renderBubbleChamber(): void {\n        if (!this.chamberGraphics || !this.currentTheme) return;\n        \n        this.chamberGraphics.clear();\n        \n        // Chamber - more prominent than queue\n        const chamberRadius = 24 * HD_SCALE;\n        const innerRadius = 16 * HD_SCALE;\n        \n        // Gradient background\n        this.chamberGraphics.fillGradientStyle(\n            this.currentTheme.chamber.outerTop,\n            this.currentTheme.chamber.outerTop,\n            this.currentTheme.chamber.outerBottom,\n            this.currentTheme.chamber.outerBottom,\n            1, 1, 0.9, 0.9\n        );\n        this.chamberGraphics.fillCircle(0, 0, chamberRadius);\n        \n        // Strong rim for the chamber\n        this.chamberGraphics.lineStyle(3 * HD_SCALE, this.currentTheme.chamber.rim, 1);\n        this.chamberGraphics.strokeCircle(0, 0, chamberRadius);\n        \n        // Inner chamber where bubble sits\n        this.chamberGraphics.fillStyle(0x0a0a0a, 0.9);\n        this.chamberGraphics.fillCircle(0, 0, innerRadius);\n        \n        // Inner rim accent\n        this.chamberGraphics.lineStyle(2 * HD_SCALE, this.currentTheme.chamber.innerRim, 0.8);\n        this.chamberGraphics.strokeCircle(0, 0, innerRadius);\n        \n        // Power indicator ring\n        this.chamberGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.chamber.highlight, 0.5);\n        this.chamberGraphics.strokeCircle(0, 0, innerRadius + (3 * HD_SCALE));\n        \n        // Highlight dot\n        this.chamberGraphics.fillStyle(this.currentTheme.chamber.highlight, 0.4);\n        this.chamberGraphics.fillCircle(-5 * HD_SCALE, -5 * HD_SCALE, 3 * HD_SCALE);\n    }\n\n    /**\n     * MOBILE-FIRST: Renders integrated queue with optimal mobile visibility\n     */\n    private renderEnhancedQueue(): void {\n        if (!this.queueBackground || !this.currentTheme) return;\n        \n        this.queueBackground.clear();\n        \n        // Create a circular loading chamber similar to main chamber\n        const queueRadius = 20 * HD_SCALE;\n        const innerRadius = 14 * HD_SCALE;\n        \n        // Gradient background matching launcher style\n        this.queueBackground.fillGradientStyle(\n            this.currentTheme.chamber.outerTop,\n            this.currentTheme.chamber.outerTop,\n            this.currentTheme.chamber.outerBottom,\n            this.currentTheme.chamber.outerBottom,\n            0.8, 0.8, 0.6, 0.6\n        );\n        this.queueBackground.fillCircle(0, 0, queueRadius);\n        \n        // Rim matching launcher theme\n        this.queueBackground.lineStyle(2.5 * HD_SCALE, this.currentTheme.chamber.rim, 0.8);\n        this.queueBackground.strokeCircle(0, 0, queueRadius);\n        \n        // Inner chamber where bubbles queue\n        this.queueBackground.fillStyle(0x0a0a0a, 0.7);\n        this.queueBackground.fillCircle(0, 0, innerRadius);\n        \n        // Inner rim accent\n        this.queueBackground.lineStyle(1.5 * HD_SCALE, this.currentTheme.chamber.innerRim, 0.6);\n        this.queueBackground.strokeCircle(0, 0, innerRadius);\n        \n        // Loading indicator arc (animated)\n        this.queueBackground.lineStyle(1 * HD_SCALE, this.currentTheme.chamber.highlight, 0.4);\n        this.queueBackground.strokeCircle(0, 0, innerRadius + (2 * HD_SCALE));\n        \n        // Small highlight dots for depth\n        this.queueBackground.fillStyle(this.currentTheme.chamber.highlight, 0.3);\n        this.queueBackground.fillCircle(-4 * HD_SCALE, -4 * HD_SCALE, 2 * HD_SCALE);\n        \n        // Render queue bubbles\n        this.renderEnhancedQueueBubbles();\n    }\n\n    /**\n     * NEW: Renders state indicators for better game feel\n     */\n    private renderStateIndicators(): void {\n        if (!this.readyIndicator) return;\n        \n        // Don't show indicator if we don't have a theme yet\n        if (!this.currentTheme) {\n            this.readyIndicator.setVisible(false);\n            return;\n        }\n        \n        // Update ready indicator based on state - using theme colors\n        switch (this.launcherState) {\n            case 'ready':\n                this.readyIndicator.setVisible(true);\n                // Use the current bubble's theme color instead of hardcoded green\n                this.readyIndicator.setStrokeStyle(2, this.currentTheme.platform.rim, 0.8);\n                break;\n            case 'aiming':\n                this.readyIndicator.setVisible(true);\n                // Use accent color for aiming\n                this.readyIndicator.setStrokeStyle(2, this.currentTheme.glow.aiming, 0.6);\n                break;\n            case 'charging':\n                this.readyIndicator.setVisible(true);\n                // Use pulse color for charging\n                this.readyIndicator.setStrokeStyle(3, this.currentTheme.glow.pulse, 0.9);\n                break;\n            default:\n                this.readyIndicator.setVisible(false);\n                break;\n        }\n    }\n\n    /**\n     * MOBILE-OPTIMIZED: Renders queue bubbles side by side\n     */\n    private renderEnhancedQueueBubbles(): void {\n        if (!this.queueBackground || !this.queueContainer) return;\n        \n        // Render bubbles side by side horizontally\n        if (this.nextBubbleColors.length > 0 && this.nextBubbleColors[0]) {\n            this.createNextBubble(this.nextBubbleColors[0]);\n        }\n        \n        if (this.nextBubbleColors.length > 1 && this.nextBubbleColors[1]) {\n            this.createSecondBubble(this.nextBubbleColors[1]);\n        }\n    }\n    \n    /**\n     * Create the main next bubble\n     */\n    private createNextBubble(color: BubbleColor): void {\n        if (!this.queueContainer) return;\n        \n        // Clear any existing graphics first\n        if (this.nextBubbleGraphics) {\n            this.nextBubbleGraphics.destroy();\n            this.nextBubbleGraphics = undefined;\n        }\n        \n        const bubbleGraphics = this.scene.add.graphics();\n        this.queueContainer.add(bubbleGraphics);\n        this.nextBubbleGraphics = bubbleGraphics;\n        \n        // Center position for main queue bubble\n        bubbleGraphics.x = 0;\n        bubbleGraphics.y = 0;\n        \n        // Draw the next bubble - larger, ready to move up\n        const radius = 11 * HD_SCALE;  // Good size for next bubble\n        this.drawQueueBubble(bubbleGraphics, 0, 0, radius, 1, color);\n        \n        // Set initial scale to 0 for animation\n        bubbleGraphics.setScale(0);\n        \n        // Animate appearance with rotation for loading effect\n        this.scene.tweens.add({\n            targets: bubbleGraphics,\n            scale: 1,\n            rotation: Math.PI * 2,\n            duration: 400,\n            ease: 'Back.easeOut'\n        });\n        \n        // Add pulsing effect to show it's ready\n        this.scene.tweens.add({\n            targets: bubbleGraphics,\n            scale: { from: 1, to: 1.08 },\n            duration: 1200,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.InOut',\n            delay: 400\n        });\n    }\n    \n    /**\n     * Create the small second bubble\n     */\n    private createSecondBubble(color: BubbleColor): void {\n        if (!this.queueContainer) return;\n        \n        // Clear any existing graphics first\n        if (this.secondBubbleGraphics) {\n            this.secondBubbleGraphics.destroy();\n            this.secondBubbleGraphics = undefined;\n        }\n        \n        const bubbleGraphics = this.scene.add.graphics();\n        // Add behind the main bubble\n        this.queueContainer.addAt(bubbleGraphics, 0);\n        this.secondBubbleGraphics = bubbleGraphics;\n        \n        // Position offset to the side - visible but smaller\n        bubbleGraphics.x = 9 * HD_SCALE;\n        bubbleGraphics.y = 7 * HD_SCALE;\n        \n        // Draw the small bubble - smaller, waiting its turn\n        const radius = 7 * HD_SCALE;  // Smaller bubble but visible\n        this.drawQueueBubble(bubbleGraphics, 0, 0, radius, 0.7, color);\n        \n        // Set initial scale to 0 for animation\n        bubbleGraphics.setScale(0);\n        \n        // Animate appearance\n        this.scene.tweens.add({\n            targets: bubbleGraphics,\n            scale: 0.65,  // Keep it smaller\n            duration: 400,\n            ease: 'Back.easeOut'\n        });\n        \n        // Gentle floating motion for dynamic feel\n        this.scene.tweens.add({\n            targets: bubbleGraphics,\n            y: bubbleGraphics.y - 1.5 * HD_SCALE,\n            duration: 2500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.InOut',\n            delay: 200\n        });\n    }\n    \n    /**\n     * Reset all queue bubbles\n     */\n    private resetQueueBubbles(): void {\n        if (this.nextBubbleGraphics) {\n            this.scene.tweens.add({\n                targets: this.nextBubbleGraphics,\n                alpha: 0,\n                scale: 0.5,\n                duration: 150,\n                ease: 'Power2.In',\n                onComplete: () => {\n                    this.nextBubbleGraphics?.destroy();\n                    this.nextBubbleGraphics = undefined;\n                }\n            });\n        }\n        \n        if (this.secondBubbleGraphics) {\n            this.scene.tweens.add({\n                targets: this.secondBubbleGraphics,\n                alpha: 0,\n                scale: 0.5,\n                duration: 150,\n                ease: 'Power2.In',\n                onComplete: () => {\n                    this.secondBubbleGraphics?.destroy();\n                    this.secondBubbleGraphics = undefined;\n                }\n            });\n        }\n    }\n    \n    /**\n     * Draw queue bubble on graphics object\n     */\n    private drawQueueBubble(graphics: Phaser.GameObjects.Graphics, x: number, y: number, radius: number, alpha: number, color: BubbleColor): void {\n        const bubbleTheme = this.getBubbleColors(color);\n        \n        // Main bubble fill with correct color\n        graphics.fillStyle(bubbleTheme.primary);\n        graphics.fillCircle(x, y, radius);\n        \n        // Strong border\n        graphics.lineStyle(2 * HD_SCALE, bubbleTheme.dark, 0.9);\n        graphics.strokeCircle(x, y, radius);\n        \n        // Highlight spot\n        graphics.fillStyle(bubbleTheme.light);\n        graphics.fillCircle(x - radius * 0.3, y - radius * 0.3, radius * 0.35);\n        \n        // Inner glow\n        graphics.fillStyle(bubbleTheme.accent, 0.4);\n        graphics.fillCircle(x, y, radius * 0.6);\n        \n        // Set overall alpha\n        graphics.setAlpha(alpha);\n    }\n    \n    /**\n     * Draw small queue bubble on graphics object\n     */\n    private drawSmallQueueBubble(graphics: Phaser.GameObjects.Graphics, x: number, y: number, radius: number, alpha: number, color: BubbleColor): void {\n        // Just use the same method as the main bubble for consistency\n        this.drawQueueBubble(graphics, x, y, radius, alpha, color);\n    }\n\n\n    /**\n     * Renders premium glow effects\n     */\n    private renderGlowEffects(): void {\n        if (!this.glowEffect || !this.currentTheme) return;\n        \n        this.glowEffect.clear();\n        \n        if (this.isAiming) {\n            // Aiming glow effect\n            this.glowEffect.fillStyle(this.currentTheme.glow.aiming, 0.3);\n            this.glowEffect.fillCircle(0, 0, 30 * HD_SCALE);\n            \n            // Pulsing outer glow\n            this.glowEffect.fillStyle(this.currentTheme.glow.pulse, 0.1);\n            this.glowEffect.fillCircle(0, 0, 35 * HD_SCALE);\n        }\n        \n        if (this.loadedBubble) {\n            // Loaded bubble ambient glow\n            this.glowEffect.fillStyle(this.currentTheme.glow.loaded, 0.2);\n            this.glowEffect.fillCircle(0, 0, 25 * HD_SCALE);\n        }\n    }\n\n    /**\n     * Gets premium theme colors for unified design\n     */\n    private getExceptionalTheme(color: BubbleColor): any {\n        const base = this.getBubbleColors(color);\n        \n        return {\n            platform: {\n                top: base.secondary,\n                bottom: this.darkenColor(base.secondary, 30),\n                rim: base.primary,\n                highlight: base.light,\n                shadow: this.darkenColor(base.dark, 20)\n            },\n            chamber: {\n                outerTop: base.secondary,\n                outerBottom: this.darkenColor(base.secondary, 25),\n                innerTop: this.darkenColor(base.dark, 10),\n                innerBottom: this.darkenColor(base.dark, 40),\n                rim: base.primary,\n                innerRim: base.accent,\n                highlight: base.light,\n                depth: this.darkenColor(base.dark, 30)\n            },\n            queue: {\n                panelTop: 0x2A2A2A,\n                panelBottom: 0x1A1A1A,\n                panelBorder: base.primary,\n                panelGlow: base.light\n            },\n            glow: {\n                aiming: base.primary,\n                pulse: base.light,\n                loaded: base.accent\n            }\n        };\n    }\n\n    /**\n     * Premium color palette for exceptional visual quality\n     */\n    private getBubbleColors(color: BubbleColor): any {\n        switch(color) {\n            case BubbleColor.RED:\n                return {\n                    primary: 0xFF4757,\n                    secondary: 0xE84142,\n                    accent: 0xFF6B7A,\n                    dark: 0xB91E28,\n                    light: 0xFF9CAA\n                };\n            case BubbleColor.BLUE:\n                return {\n                    primary: 0x3742FA,\n                    secondary: 0x2F3542,\n                    accent: 0x5E72FF,\n                    dark: 0x1E2745,\n                    light: 0x8A9CFF\n                };\n            case BubbleColor.GREEN:\n                return {\n                    primary: 0x2ED573,\n                    secondary: 0x1B9F47,\n                    accent: 0x5FE085,\n                    dark: 0x146B34,\n                    light: 0x8EEB9B\n                };\n            case BubbleColor.YELLOW:\n                return {\n                    primary: 0xFFD32A,\n                    secondary: 0xFFB800,\n                    accent: 0xFFDE4D,\n                    dark: 0xCC8F00,\n                    light: 0xFFE870\n                };\n            case BubbleColor.PURPLE: // Actually PINK/MAGENTA (0xff00ff)\n                return {\n                    primary: 0xFF00FF,  // Bright magenta/pink\n                    secondary: 0xE600E6,\n                    accent: 0xFF66FF,\n                    dark: 0xCC00CC,\n                    light: 0xFF99FF\n                };\n            default: // Cyan\n                return {\n                    primary: 0x00D4FF,\n                    secondary: 0x0097CC,\n                    accent: 0x33DDFF,\n                    dark: 0x006B99,\n                    light: 0x66E6FF\n                };\n        }\n    }\n\n    /**\n     * Utility: Darkens a color by percentage\n     */\n    private darkenColor(color: number, percent: number): number {\n        const r = (color >> 16) & 0xFF;\n        const g = (color >> 8) & 0xFF;\n        const b = color & 0xFF;\n        \n        const factor = (100 - percent) / 100;\n        \n        return ((r * factor) << 16) | ((g * factor) << 8) | (b * factor);\n    }\n\n    /**\n     * Updates theme with unified design consistency\n     */\n    private updateTheme(color: BubbleColor): void {\n        // Store current scale before updating\n        const currentScaleY = this.scaleY;\n        \n        this.currentTheme = this.getExceptionalTheme(color);\n        this.updateAllVisuals();\n        \n        // Restore scale after updating visuals\n        if (this.isOpponent) {\n            this.setScale(1, -1);\n        }\n    }\n\n    /**\n     * MOBILE-OPTIMIZED: Enhanced idle animations with clear visual hierarchy\n     */\n    private startEnhancedIdleAnimations(): void {\n        // Optimized breathing effect - more visible on mobile without performance impact\n        this.idleAnimation = this.scene.tweens.add({\n            targets: this.bubbleChamber,\n            scaleX: { from: 1, to: 1.02 },   // Slightly more visible\n            scaleY: { from: 1, to: 1.02 },\n            duration: 2200,                   // Optimized timing for mobile attention\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.InOut'\n        });\n        \n        // Mobile-friendly queue indicator - helps users understand the system\n        if (this.queueContainer) {\n            // Subtle pulsing to indicate \"next bubble\"\n            this.scene.tweens.add({\n                targets: this.queueContainer,\n                alpha: { from: 0.85, to: 1 },\n                duration: 3000,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.InOut'\n            });\n            \n            // Gentle scale animation to draw attention without being distracting\n            this.scene.tweens.add({\n                targets: this.queueContainer,\n                scaleX: { from: 1, to: 1.01 },\n                scaleY: { from: 1, to: 1.01 },\n                duration: 2000,\n                repeat: -1,\n                yoyo: true,\n                ease: 'Sine.InOut'\n            });\n        }\n        \n        // Mobile-optimized ready state indicator\n        if (this.readyIndicator) {\n            this.scene.tweens.add({\n                targets: this.readyIndicator,\n                alpha: { from: 0.4, to: 0.8 },\n                duration: 1800,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.InOut',\n                paused: true  // Activated when launcher is ready\n            });\n        }\n    }\n\n    /**\n     * MOBILE-FIRST: Setup optimized touch interaction with proper accessibility\n     */\n    private setupMobileTouchArea(): void {\n        // Create touch area following mobile accessibility guidelines\n        // iOS: 44x44pt minimum, Android: 48x48dp minimum - we use generous 120px\n        const touchSize = 120; // Premium touch area for excellent mobile UX\n        const touchArea = this.scene.add.rectangle(0, 0, touchSize, touchSize, 0x000000, 0);\n        touchArea.setInteractive({ useHandCursor: true });\n        \n        // Position behind all visual elements for clean design\n        this.addAt(touchArea, 0);\n        \n        // Enhanced mobile feedback system\n        touchArea.on('pointerdown', (pointer: Phaser.Input.Pointer) => {\n            // Satisfying mobile scale feedback - more pronounced\n            this.scene.tweens.add({\n                targets: this,\n                scaleX: 0.92,\n                scaleY: this.isOpponent ? -0.92 : 0.92,  // Maintain flip for opponent\n                duration: 60,\n                yoyo: true,\n                ease: 'Power3.Out'\n            });\n            \n            // Premium mobile ripple effect with better visibility\n            const ripple = this.scene.add.circle(0, 0, 12 * HD_SCALE, 0xffffff, 0.4);\n            this.add(ripple);\n            \n            this.scene.tweens.add({\n                targets: ripple,\n                scale: { from: 0, to: 4 },\n                alpha: { from: 0.4, to: 0 },\n                duration: 500,\n                ease: 'Power2.Out',\n                onComplete: () => ripple.destroy()\n            });\n            \n            // Visual hierarchy pulse for clarity\n            if (this.queueContainer) {\n                this.scene.tweens.add({\n                    targets: this.queueContainer,\n                    scaleX: { from: 1, to: 1.05 },\n                    scaleY: { from: 1, to: 1.05 },\n                    duration: 100,\n                    yoyo: true,\n                    ease: 'Power2.Out'\n                });\n            }\n        });\n        \n        // Subtle hover effect for desktop/tablet hybrid devices\n        touchArea.on('pointerover', () => {\n            this.setHighlight(true);\n        });\n        \n        touchArea.on('pointerout', () => {\n            this.setHighlight(false);\n        });\n    }\n\n    // === PUBLIC INTERFACE - ENHANCED ===\n\n    public setAimAngle(angle: number): void {\n        this.currentAngle = angle;\n        \n        let visualAngle = angle;\n        \n        if (this.zone === ArenaZone.PLAYER) {\n            if (angle > 180) {\n                visualAngle = Phaser.Math.Clamp(angle, 195, 345);\n            } else {\n                visualAngle = Phaser.Math.Clamp(angle, 15, 165);\n            }\n        } else {\n            visualAngle = Phaser.Math.Clamp(angle, 15, 165);\n        }\n        \n        this.currentAngle = visualAngle;\n        \n        // No visual rotation - the launcher stays fixed\n        // The trajectory preview shows the aiming direction\n    }\n\n    public getAimAngle(): number {\n        return this.currentAngle;\n    }\n\n    public getAimDirection(): Phaser.Math.Vector2 {\n        const rad = Phaser.Math.DegToRad(this.currentAngle);\n        return new Phaser.Math.Vector2(Math.cos(rad), Math.sin(rad));\n    }\n\n    public showAiming(show: boolean): void {\n        this.isAiming = show;\n        this.launcherState = show ? 'aiming' : 'idle';\n        \n        // Enhanced aiming feedback\n        if (show) {\n            // Charging animation with better visual feedback\n            this.chargingTween = this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1.08,\n                scaleY: 1.08,\n                duration: 200,\n                ease: 'Power2.Out'\n            });\n            \n            // Add subtle chamber pulsing when aiming\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                alpha: { from: 1, to: 0.9 },\n                duration: 800,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.InOut'\n            });\n        } else {\n            // Return to normal with better transition\n            if (this.chargingTween) {\n                this.chargingTween.stop();\n            }\n            \n            // Stop pulsing\n            if (this.bubbleChamber) {\n                this.scene.tweens.killTweensOf(this.bubbleChamber);\n            }\n            \n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1,\n                scaleY: 1,\n                alpha: 1,\n                duration: 300,\n                ease: 'Elastic.Out'\n            });\n        }\n        \n        // Update all visual feedback systems\n        this.renderStateIndicators();\n        this.renderGlowEffects();\n    }\n\n    public animateShoot(bubbleColor?: BubbleColor): void {\n        this.launcherState = 'charging';\n        this.createEnhancedLaunchEffects(bubbleColor);\n        this.animateEnhancedLaunch();\n        \n        // Enter cooldown state briefly\n        setTimeout(() => {\n            this.launcherState = 'idle';\n            this.renderStateIndicators();\n        }, 500);\n    }\n\n    /**\n     * NEW: Set launcher state with visual updates\n     */\n    public override setState(state: 'idle' | 'aiming' | 'charging' | 'ready' | 'cooldown'): this {\n        this.launcherState = state;\n        this.updateStateIndicator();\n        this.renderStateIndicators();\n        return this;\n    }\n\n    /**\n     * NEW: Update state indicator visuals\n     */\n    private updateStateIndicator(): void {\n        if (!this.stateIndicator) return;\n        \n        // Clear previous state visuals\n        this.stateIndicator.clear();\n        \n        switch (this.launcherState) {\n            case 'idle':\n                // Subtle idle glow\n                this.stateIndicator.fillStyle(0x4CAF50, 0.2);\n                this.stateIndicator.fillCircle(0, 0, 35 * HD_SCALE);\n                break;\n                \n            case 'aiming':\n                // Aiming reticle effect\n                this.stateIndicator.lineStyle(4 * HD_SCALE, 0xFFC107, 0.6);  // HD line width\n                this.stateIndicator.strokeCircle(0, 0, 40 * HD_SCALE);\n                // Add crosshair\n                this.stateIndicator.lineBetween(-10 * HD_SCALE, 0, 10 * HD_SCALE, 0);\n                this.stateIndicator.lineBetween(0, -10 * HD_SCALE, 0, 10 * HD_SCALE);\n                break;\n                \n            case 'charging':\n                // Charging energy effect\n                const chargeColor = this.powerLevel < 30 ? 0xFF5722 : \n                                   this.powerLevel < 70 ? 0xFF9800 : 0x4CAF50;\n                this.stateIndicator.fillStyle(chargeColor, 0.3 + (this.powerLevel / 200));\n                this.stateIndicator.fillCircle(0, 0, (30 * HD_SCALE) + (this.powerLevel / 10));\n                break;\n                \n            case 'ready':\n                // Ready pulse effect\n                this.stateIndicator.fillStyle(0x00BCD4, 0.4);\n                this.stateIndicator.fillCircle(0, 0, 35 * HD_SCALE);\n                if (this.readyIndicator) {\n                    this.readyIndicator.setVisible(true);\n                }\n                break;\n                \n            case 'cooldown':\n                // Cooldown dimmed effect\n                this.stateIndicator.fillStyle(0x9E9E9E, 0.2);\n                this.stateIndicator.fillCircle(0, 0, 30 * HD_SCALE);\n                break;\n        }\n    }\n\n    /**\n     * NEW: Power charging system for better game feel\n     */\n    public startPowerCharge(): void {\n        this.launcherState = 'charging';\n        this.powerLevel = 0;\n        \n        // Visual power buildup\n        this.scene.tweens.add({\n            targets: this,\n            powerLevel: 100,\n            duration: 1500,\n            ease: 'Power2.Out',\n            onUpdate: () => {\n                this.renderPowerIndicator();\n            }\n        });\n        \n        // Chamber charging effect\n        if (this.bubbleChamber) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: { from: 1, to: 1.15 },\n                scaleY: { from: 1, to: 1.15 },\n                duration: 1500,\n                ease: 'Power2.Out'\n            });\n        }\n        \n        this.renderStateIndicators();\n    }\n\n    /**\n     * NEW: Release power charge\n     */\n    public releasePowerCharge(): number {\n        const power = this.powerLevel;\n        this.powerLevel = 0;\n        \n        // Reset chamber size\n        if (this.bubbleChamber) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1,\n                scaleY: 1,\n                duration: 200,\n                ease: 'Power2.Out'\n            });\n        }\n        \n        return power;\n    }\n\n    /**\n     * NEW: Render power charging indicator\n     */\n    private renderPowerIndicator(): void {\n        if (!this.stateIndicator || this.launcherState !== 'charging') return;\n        \n        // Clear previous power indicator\n        if (this.readyIndicator) {\n            const powerColor = this.powerLevel < 30 ? 0xff4444 : \n                              this.powerLevel < 70 ? 0xffaa00 : 0x00ff88;\n            \n            const alpha = 0.3 + (this.powerLevel / 100) * 0.7;\n            this.readyIndicator.setStrokeStyle(3, powerColor, alpha);\n            this.readyIndicator.setVisible(true);\n        }\n    }\n\n    public setHighlight(enabled: boolean): void {\n        const alpha = enabled ? 1.0 : 0.95;\n        \n        // Enhanced highlight with better mobile feedback\n        this.scene.tweens.add({\n            targets: this,\n            alpha,\n            duration: 150,  // Faster response for mobile\n            ease: 'Power2.Out'\n        });\n        \n        // Add subtle glow effect to chamber when highlighted\n        if (this.bubbleChamber && enabled) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1.03,\n                scaleY: 1.03,\n                duration: 150,\n                ease: 'Power2.Out'\n            });\n        } else if (this.bubbleChamber) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1,\n                scaleY: 1,\n                duration: 150,\n                ease: 'Power2.Out'\n            });\n        }\n    }\n\n    public loadBubble(color: BubbleColor): void {\n        // Clear existing bubble\n        if (this.loadedBubble) {\n            this.remove(this.loadedBubble);\n            this.loadedBubble.destroy();\n        }\n        \n        // Mobile-optimized bubble positioning and sizing\n        this.loadedBubble = new Bubble(this.scene, 0, this.BUBBLE_POSITION_Y, color);\n        this.loadedBubble.setScale(1.0); // Slightly larger for mobile clarity (was 0.95)\n        this.add(this.loadedBubble);\n        this.bringToTop(this.loadedBubble);\n        \n        // Update theme to match loaded bubble\n        this.updateTheme(color);\n        \n        // Update ready indicator color to match bubble - no alpha initially\n        if (this.readyIndicator && this.currentTheme) {\n            // Don't set visibility here, let renderStateIndicators handle it\n            // Just prepare the color for when it becomes visible\n            this.readyIndicator.setStrokeStyle(2, this.currentTheme.platform.rim, 0);\n        }\n        \n        // Update arsenal slot colors to match launcher theme\n        this.updateArsenalTheme();\n        \n        // Enhanced mobile loading animation with better visual feedback\n        this.loadedBubble.setScale(0);\n        this.scene.tweens.add({\n            targets: this.loadedBubble,\n            scale: 1.0,\n            duration: 450,\n            ease: 'Back.Out'\n        });\n        \n        // Mobile visual hierarchy: emphasize the loaded bubble is READY TO SHOOT\n        this.scene.tweens.add({\n            targets: this.loadedBubble,\n            alpha: { from: 0.7, to: 1 },\n            duration: 600,\n            ease: 'Power2.InOut',\n            delay: 200\n        });\n        \n        // Update launcher state\n        this.launcherState = 'ready';\n        \n        // Maintain opponent flip consistency\n        if (this.isOpponent && this.scaleY !== -1) {\n            this.setScale(1, -1);\n        }\n        \n        // Update all visual indicators\n        this.renderStateIndicators();\n        \n        // Mobile-friendly chamber response with clearer feedback\n        this.scene.tweens.add({\n            targets: this.bubbleChamber,\n            scaleX: { from: 1, to: 1.12 },\n            scaleY: { from: 1, to: 1.12 },\n            duration: 300,\n            yoyo: true,\n            ease: 'Back.Out'\n        });\n        \n        // Update visual effects\n        this.renderGlowEffects();\n        \n        // Mobile UX: Subtle visual indicator that this is the ACTIVE bubble\n        if (this.bubbleChamber) {\n            this.scene.time.delayedCall(500, () => {\n                this.scene.tweens.add({\n                    targets: this.bubbleChamber,\n                    alpha: { from: 1, to: 0.95 },\n                    duration: 300,\n                    ease: 'Sine.InOut'\n                });\n            });\n        }\n    }\n\n    public getLoadedBubble(): Bubble | undefined {\n        return this.loadedBubble;\n    }\n\n    public clearLoadedBubble(): void {\n        if (this.loadedBubble) {\n            this.remove(this.loadedBubble);\n        }\n        this.loadedBubble = undefined;\n        this.renderGlowEffects();\n        \n        // Ensure flip is maintained for opponent\n        if (this.isOpponent && this.scaleY !== -1) {\n            this.setScale(1, -1);\n        }\n    }\n\n    public updateQueueColors(colors: BubbleColor[]): void {\n        this.nextBubbleColors = colors;\n        \n        if (!this.queueContainer) return;\n        \n        // console.log('Launcher: Updating queue colors:', colors);\n        \n        // Clear existing bubbles with animation\n        if (this.nextBubbleGraphics) {\n            this.scene.tweens.add({\n                targets: this.nextBubbleGraphics,\n                alpha: 0,\n                scale: 0,\n                duration: 150,\n                onComplete: () => {\n                    this.nextBubbleGraphics?.destroy();\n                    this.nextBubbleGraphics = undefined;\n                }\n            });\n        }\n        \n        if (this.secondBubbleGraphics) {\n            this.scene.tweens.add({\n                targets: this.secondBubbleGraphics,\n                alpha: 0,\n                scale: 0,\n                duration: 150,\n                onComplete: () => {\n                    this.secondBubbleGraphics?.destroy();\n                    this.secondBubbleGraphics = undefined;\n                }\n            });\n        }\n        \n        // Create new bubbles with correct colors after a brief delay\n        this.scene.time.delayedCall(200, () => {\n            if (colors.length > 0 && colors[0]) {\n                // console.log('Creating next bubble with color:', colors[0]);\n                this.createNextBubble(colors[0]);\n            }\n            if (colors.length > 1 && colors[1]) {\n                this.scene.time.delayedCall(150, () => {\n                    // console.log('Creating second bubble with color:', colors[1]!);\n                    this.createSecondBubble(colors[1]!);\n                });\n            }\n        });\n    }\n\n    // === PRIVATE ANIMATION METHODS - ENHANCED ===\n\n    private animateEnhancedLaunch(): void {\n        // Enhanced launch recoil with power-based intensity\n        const recoilIntensity = 1 + (this.powerLevel / 100) * 0.5;\n        \n        if (this.bubbleChamber) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1.15 * recoilIntensity,\n                scaleY: 1.15 * recoilIntensity,\n                duration: 200 + this.powerLevel,\n                yoyo: true,\n                ease: 'Power3.Out'\n            });\n        }\n        \n        // Enhanced platform shake with haptic feel\n        if (this.launcherPlatform) {\n            const shakeIntensity = 2 * recoilIntensity;\n            this.scene.tweens.add({\n                targets: this.launcherPlatform,\n                x: -shakeIntensity,\n                duration: 175,\n                yoyo: true,\n                ease: 'Power2.Out'\n            });\n        }\n        \n        // Power-based launcher recoil\n        const recoilDistance = 3 * recoilIntensity;\n        this.scene.tweens.add({\n            targets: this,\n            y: this.y - (this.isOpponent ? -recoilDistance : recoilDistance),\n            duration: 100,\n            yoyo: true,\n            ease: 'Power2.Out'\n        });\n        \n        // Screen shake for powerful shots\n        if (this.powerLevel > 70) {\n            this.scene.cameras.main.shake(150, 0.01);\n        }\n    }\n\n    private createEnhancedLaunchEffects(bubbleColor?: BubbleColor): void {\n        if (!bubbleColor) return;\n        \n        const colors = this.getBubbleColors(bubbleColor);\n        const effectY = this.isOpponent ? \n            this.y + Math.abs(this.BUBBLE_POSITION_Y) :\n            this.y + this.BUBBLE_POSITION_Y;\n        \n        // Power-based effect intensity\n        const effectIntensity = 0.8 + (this.powerLevel / 100) * 0.4;\n        const particleCount = Math.floor(8 + (this.powerLevel / 100) * 8);\n        \n        // Enhanced muzzle flash\n        const flashSize = 22 * effectIntensity;\n        const flash = this.scene.add.circle(this.x, effectY, flashSize, colors.primary, 0.9);\n        flash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        this.scene.tweens.add({\n            targets: flash,\n            scale: { from: 0.5, to: 2.2 * effectIntensity },\n            alpha: { from: 0.9, to: 0 },\n            duration: 280 + (this.powerLevel * 2),\n            ease: 'Power2.Out',\n            onComplete: () => flash.destroy()\n        });\n        \n        // Power-based sparkle burst\n        for (let i = 0; i < particleCount; i++) {\n            const angle = (Math.PI * 2 / particleCount) * i;\n            const baseDistance = 10 + Math.random() * 12;\n            const distance = baseDistance * effectIntensity;\n            const sparkX = this.x + Math.cos(angle) * distance;\n            const sparkY = effectY + Math.sin(angle) * distance;\n            \n            const sparkleSize = 4.5 * effectIntensity;\n            const sparkle = this.scene.add.circle(sparkX, sparkY, sparkleSize, colors.primary, 0.95);\n            sparkle.setBlendMode(Phaser.BlendModes.ADD);\n            \n            this.scene.tweens.add({\n                targets: sparkle,\n                scale: { from: 1.1, to: 0 },\n                alpha: { from: 0.9, to: 0 },\n                x: sparkX + Math.cos(angle) * 28 * effectIntensity,\n                y: sparkY + Math.sin(angle) * 28 * effectIntensity,\n                duration: 450 + (this.powerLevel * 3),\n                delay: i * 18,\n                ease: 'Power2.Out',\n                onComplete: () => sparkle.destroy()\n            });\n        }\n        \n        // Enhanced energy rings for powerful shots\n        if (this.powerLevel > 50) {\n            for (let r = 0; r < 2; r++) {\n                const ring = this.scene.add.circle(this.x, effectY, 19 + r * 5, colors.primary, 0);\n                ring.setStrokeStyle(3.5 - r * 0.5, colors.primary, 0.9 - r * 0.2);\n                ring.setBlendMode(Phaser.BlendModes.ADD);\n                \n                this.scene.tweens.add({\n                    targets: ring,\n                    scale: { from: 0.6, to: (2.2 + r * 0.3) * effectIntensity },\n                    alpha: { from: 0.8, to: 0 },\n                    duration: 380 + r * 100,\n                    delay: r * 50,\n                    ease: 'Power2.Out',\n                    onComplete: () => ring.destroy()\n                });\n            }\n        } else {\n            // Standard ring for normal shots\n            const ring = this.scene.add.circle(this.x, effectY, 19, colors.primary, 0);\n            ring.setStrokeStyle(3.5, colors.primary, 0.9);\n            ring.setBlendMode(Phaser.BlendModes.ADD);\n            \n            this.scene.tweens.add({\n                targets: ring,\n                scale: { from: 0.6, to: 2.2 },\n                alpha: { from: 0.8, to: 0 },\n                duration: 380,\n                ease: 'Power2.Out',\n                onComplete: () => ring.destroy()\n            });\n        }\n    }\n\n    private updateArsenalTheme(): void {\n        if (!this.arsenalSlots || !this.currentTheme) return;\n        \n        // Update all arsenal slot backgrounds with new theme\n        this.arsenalSlots.forEach(slot => {\n            if (slot.background) {\n                this.drawArsenalSlotBackground(slot.background, slot.isActive);\n            }\n        });\n    }\n    \n    // === ARSENAL INTEGRATION METHODS ===\n    \n    private createIntegratedArsenal(): void {\n        // Create container for arsenal system\n        this.arsenalContainer = this.scene.add.container(0, 0);\n        this.add(this.arsenalContainer);\n        \n        // Create the horizontal chamber design first\n        this.createArsenalChamber();\n        \n        // Use appropriate positions based on player/opponent\n        const positions = this.isOpponent ? \n            this.ARSENAL_POSITIONS_OPPONENT : \n            this.ARSENAL_POSITIONS_PLAYER;\n        \n        // Create arsenal slots in horizontal formation\n        positions.forEach((pos, index) => {\n            const slot = this.createArsenalSlot(pos, index);\n            this.arsenalSlots.push(slot);\n            if (this.arsenalContainer) {\n                this.arsenalContainer.add(slot.container);\n            }\n        });\n        \n        // Position arsenal at higher depth to ensure visibility\n        this.arsenalContainer.setDepth(100);\n    }\n    \n    private createArsenalChamber(): void {\n        if (!this.arsenalContainer || !this.currentTheme) return;\n        \n        const chamberGraphics = this.scene.add.graphics();\n        \n        // Calculate bounds for horizontal chamber\n        const startX = this.isOpponent ? -70 * HD_SCALE : 70 * HD_SCALE;\n        const endX = this.isOpponent ? -150 * HD_SCALE : 150 * HD_SCALE;\n        const chamberY = -35 * HD_SCALE;\n        const chamberHeight = 40 * HD_SCALE;\n        const chamberWidth = Math.abs(endX - startX) + 40 * HD_SCALE;\n        const chamberX = Math.min(startX, endX) - 18 * HD_SCALE;\n        \n        // === LAYER 1: Base Platform (like launcher) ===\n        // Outer shadow/glow\n        chamberGraphics.fillStyle(0x000000, 0.5);\n        chamberGraphics.fillRoundedRect(\n            chamberX - 3,\n            chamberY - chamberHeight/2 - 3,\n            chamberWidth + 6,\n            chamberHeight + 6,\n            15 * HD_SCALE\n        );\n        \n        // Main platform base\n        const gradient = chamberGraphics.fillGradientStyle(\n            this.currentTheme.platform.base,\n            this.currentTheme.platform.base,\n            this.currentTheme.secondary,\n            this.currentTheme.secondary,\n            0.7\n        );\n        chamberGraphics.fillRoundedRect(\n            chamberX,\n            chamberY - chamberHeight/2,\n            chamberWidth,\n            chamberHeight,\n            12 * HD_SCALE\n        );\n        \n        // === LAYER 2: Inner Chamber Details ===\n        // Inner recessed area\n        chamberGraphics.fillStyle(this.currentTheme.chamber.inner, 0.4);\n        chamberGraphics.fillRoundedRect(\n            chamberX + 4 * HD_SCALE,\n            chamberY - chamberHeight/2 + 4 * HD_SCALE,\n            chamberWidth - 8 * HD_SCALE,\n            chamberHeight - 8 * HD_SCALE,\n            10 * HD_SCALE\n        );\n        \n        // === LAYER 3: Tech Details ===\n        // Tech panels between slots\n        const slotSpacing = 40 * HD_SCALE;\n        for (let i = 0; i < 2; i++) {\n            const panelX = startX + (i + 0.5) * slotSpacing * (this.isOpponent ? -1 : 1);\n            \n            // Panel background\n            chamberGraphics.fillStyle(this.currentTheme.platform.detail, 0.3);\n            chamberGraphics.fillRect(\n                panelX - 8 * HD_SCALE,\n                chamberY - 10 * HD_SCALE,\n                16 * HD_SCALE,\n                20 * HD_SCALE\n            );\n            \n            // Panel lines\n            chamberGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.glow.pulse, 0.4);\n            chamberGraphics.lineBetween(\n                panelX - 6 * HD_SCALE,\n                chamberY,\n                panelX + 6 * HD_SCALE,\n                chamberY\n            );\n        }\n        \n        // === LAYER 4: Premium Borders & Rims ===\n        // Outer rim\n        chamberGraphics.lineStyle(3 * HD_SCALE, this.currentTheme.platform.rim, 1);\n        chamberGraphics.strokeRoundedRect(\n            chamberX,\n            chamberY - chamberHeight/2,\n            chamberWidth,\n            chamberHeight,\n            12 * HD_SCALE\n        );\n        \n        // Inner rim detail\n        chamberGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.chamber.detail, 0.6);\n        chamberGraphics.strokeRoundedRect(\n            chamberX + 4 * HD_SCALE,\n            chamberY - chamberHeight/2 + 4 * HD_SCALE,\n            chamberWidth - 8 * HD_SCALE,\n            chamberHeight - 8 * HD_SCALE,\n            10 * HD_SCALE\n        );\n        \n        // === CONNECTING TUBE (Premium Design) ===\n        const tubeStartX = this.isOpponent ? -35 * HD_SCALE : 35 * HD_SCALE;\n        const tubeEndX = startX - (this.isOpponent ? -18 : 18) * HD_SCALE;\n        const tubeY = chamberY;\n        const tubeHeight = 24 * HD_SCALE;\n        \n        // Tube shadow\n        chamberGraphics.fillStyle(0x000000, 0.3);\n        chamberGraphics.fillRect(\n            Math.min(tubeStartX, tubeEndX) - 1,\n            tubeY - tubeHeight/2 - 1,\n            Math.abs(tubeEndX - tubeStartX) + 2,\n            tubeHeight + 2\n        );\n        \n        // Tube main body\n        chamberGraphics.fillStyle(this.currentTheme.platform.base, 0.6);\n        chamberGraphics.fillRect(\n            Math.min(tubeStartX, tubeEndX),\n            tubeY - tubeHeight/2,\n            Math.abs(tubeEndX - tubeStartX),\n            tubeHeight\n        );\n        \n        // Tube inner detail\n        chamberGraphics.fillStyle(this.currentTheme.chamber.inner, 0.3);\n        chamberGraphics.fillRect(\n            Math.min(tubeStartX, tubeEndX) + 2,\n            tubeY - tubeHeight/2 + 2,\n            Math.abs(tubeEndX - tubeStartX) - 4,\n            tubeHeight - 4\n        );\n        \n        // Tube borders\n        chamberGraphics.lineStyle(2 * HD_SCALE, this.currentTheme.platform.rim, 0.9);\n        chamberGraphics.lineBetween(tubeStartX, tubeY - tubeHeight/2, tubeEndX, tubeY - tubeHeight/2);\n        chamberGraphics.lineBetween(tubeStartX, tubeY + tubeHeight/2, tubeEndX, tubeY + tubeHeight/2);\n        \n        // Energy flow lines in tube\n        chamberGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.glow.pulse, 0.5);\n        for (let i = 0; i < 3; i++) {\n            const lineY = tubeY - tubeHeight/2 + (i + 1) * (tubeHeight / 4);\n            chamberGraphics.setLineDash([5 * HD_SCALE, 5 * HD_SCALE]);\n            chamberGraphics.lineBetween(tubeStartX, lineY, tubeEndX, lineY);\n        }\n        chamberGraphics.setLineDash([]);\n        \n        // === DECORATIVE ELEMENTS ===\n        // Corner accents\n        chamberGraphics.lineStyle(2 * HD_SCALE, this.currentTheme.glow.loaded, 0.4);\n        // Top left\n        chamberGraphics.lineBetween(\n            chamberX,\n            chamberY - chamberHeight/2 + 10 * HD_SCALE,\n            chamberX + 10 * HD_SCALE,\n            chamberY - chamberHeight/2\n        );\n        // Top right\n        chamberGraphics.lineBetween(\n            chamberX + chamberWidth - 10 * HD_SCALE,\n            chamberY - chamberHeight/2,\n            chamberX + chamberWidth,\n            chamberY - chamberHeight/2 + 10 * HD_SCALE\n        );\n        \n        this.arsenalContainer.add(chamberGraphics);\n        chamberGraphics.setDepth(-1); // Behind slots\n    }\n    \n    private createArsenalSlot(position: { x: number, y: number }, index: number): ArsenalSlot {\n        const container = this.scene.add.container(position.x, position.y);\n        \n        // Counter-rotate the container for opponent to keep content readable\n        if (this.isOpponent) {\n            container.setScale(1, -1);\n        }\n        \n        // Create slot background with weapon mount design\n        const background = this.scene.add.graphics();\n        this.drawArsenalSlotBackground(background, false);\n        \n        // Create power-up icon\n        const icon = this.scene.add.text(0, 0, '', {\n            fontSize: `${14 * HD_SCALE}px`,  // Further reduced for smaller slots\n            fontFamily: 'Arial'\n        });\n        icon.setOrigin(0.5);\n        icon.setShadow(2, 2, '#000000', 2, true, true);\n        \n        // Create count text\n        const countText = this.scene.add.text(\n            this.SLOT_SIZE/2 - 2,\n            this.SLOT_SIZE/2 - 2,\n            '',\n            {\n                fontSize: `${6 * HD_SCALE}px`,  // Further reduced for smaller slots\n                fontFamily: 'Arial Black',\n                color: '#FFFFFF',\n                stroke: '#000000',\n                strokeThickness: 2 * HD_SCALE\n            }\n        );\n        countText.setOrigin(1, 1);\n        \n        // Add key hint for slots 1-3 (only on desktop)\n        const isMobile = this.scene.game.device.input.touch;\n        if (!isMobile) {\n            const keyHint = this.createKeyHintBadge(index + 1);\n            keyHint.setPosition(-this.SLOT_SIZE/2 + 6, -this.SLOT_SIZE/2 + 6);\n            container.add(keyHint);\n        }\n        \n        container.add([background, icon, countText]);\n        \n        // Make interactive only for player\n        if (!this.isOpponent) {\n            const touchPadding = 6;\n            container.setInteractive(\n                new Phaser.Geom.Rectangle(\n                    -this.SLOT_SIZE/2 - touchPadding,\n                    -this.SLOT_SIZE/2 - touchPadding,\n                    this.SLOT_SIZE + touchPadding * 2,\n                    this.SLOT_SIZE + touchPadding * 2\n                ),\n                Phaser.Geom.Rectangle.Contains\n            );\n            \n            // Add hover/press effects\n            container.on('pointerdown', () => {\n                this.activateArsenalSlot(index);\n            });\n            \n            container.on('pointerover', () => {\n                const baseScale = this.isOpponent ? -1 : 1;\n                this.scene.tweens.add({\n                    targets: container,\n                    scaleX: 1.1,\n                    scaleY: 1.1 * baseScale,\n                    duration: 200,\n                    ease: 'Power2'\n                });\n            });\n            \n            container.on('pointerout', () => {\n                const baseScale = this.isOpponent ? -1 : 1;\n                this.scene.tweens.add({\n                    targets: container,\n                    scaleX: 1.0,\n                    scaleY: 1.0 * baseScale,\n                    duration: 200,\n                    ease: 'Power2'\n                });\n            });\n        }\n        \n        return {\n            container,\n            background,\n            icon,\n            countText,\n            position,\n            powerUpType: undefined,\n            count: 0,\n            isActive: false\n        };\n    }\n    \n    private drawArsenalSlotBackground(graphics: Phaser.GameObjects.Graphics, isActive: boolean): void {\n        graphics.clear();\n        \n        const size = this.SLOT_SIZE;\n        const halfSize = size / 2;\n        \n        if (!this.currentTheme) return;\n        \n        const colors = {\n            primary: this.currentTheme.primary,\n            secondary: this.currentTheme.secondary,\n            glow: this.currentTheme.glow.pulse,\n            rim: this.currentTheme.platform.rim,\n            detail: this.currentTheme.chamber.detail\n        };\n        \n        // === LAYER 1: Shadow/Depth ===\n        graphics.fillStyle(0x000000, 0.4);\n        graphics.fillCircle(2, 3, halfSize + 2);\n        \n        // === LAYER 2: Outer Ring (Mechanical) ===\n        graphics.fillStyle(this.currentTheme.platform.base, 0.7);\n        graphics.fillCircle(0, 0, halfSize + 1);\n        \n        // === LAYER 3: Main Chamber ===\n        graphics.fillStyle(this.currentTheme.chamber.inner, 0.8);\n        graphics.fillCircle(0, 0, halfSize - 2);\n        \n        // === LAYER 4: Inner Core ===\n        graphics.fillStyle(colors.secondary, 0.2);\n        graphics.fillCircle(0, 0, halfSize - 5 * HD_SCALE);\n        \n        // === LAYER 5: Tech Details ===\n        // Radial lines (like launcher queue)\n        graphics.lineStyle(0.5 * HD_SCALE, colors.detail, 0.3);\n        for (let i = 0; i < 8; i++) {\n            const angle = (Math.PI * 2 * i) / 8;\n            const innerR = halfSize - 8 * HD_SCALE;\n            const outerR = halfSize - 3 * HD_SCALE;\n            graphics.lineBetween(\n                Math.cos(angle) * innerR,\n                Math.sin(angle) * innerR,\n                Math.cos(angle) * outerR,\n                Math.sin(angle) * outerR\n            );\n        }\n        \n        // === LAYER 6: Premium Rims ===\n        // Outer rim\n        graphics.lineStyle(2 * HD_SCALE, isActive ? 0xFFD700 : colors.rim, isActive ? 1 : 0.8);\n        graphics.strokeCircle(0, 0, halfSize);\n        \n        // Middle rim\n        graphics.lineStyle(1 * HD_SCALE, colors.detail, 0.5);\n        graphics.strokeCircle(0, 0, halfSize - 3 * HD_SCALE);\n        \n        // Inner rim\n        graphics.lineStyle(1 * HD_SCALE, colors.rim, 0.3);\n        graphics.strokeCircle(0, 0, halfSize - 6 * HD_SCALE);\n        \n        // === LAYER 7: Active State Premium Effects ===\n        if (isActive) {\n            // Outer glow ring\n            graphics.lineStyle(4 * HD_SCALE, 0xFFD700, 0.2);\n            graphics.strokeCircle(0, 0, halfSize + 3 * HD_SCALE);\n            \n            // Middle glow\n            graphics.lineStyle(2 * HD_SCALE, 0xFFD700, 0.4);\n            graphics.strokeCircle(0, 0, halfSize + 1 * HD_SCALE);\n            \n            // Inner bright core\n            graphics.fillStyle(0xFFFFFF, 0.1);\n            graphics.fillCircle(0, 0, halfSize - 7 * HD_SCALE);\n            \n            // Highlight arc (like launcher)\n            graphics.lineStyle(1 * HD_SCALE, 0xFFFFFF, 0.6);\n            graphics.arc(0, 0, halfSize - 4 * HD_SCALE, -Math.PI * 0.7, -Math.PI * 0.3, false);\n            graphics.strokePath();\n        }\n        \n        // === LAYER 8: Glossy Highlight ===\n        graphics.fillStyle(0xFFFFFF, 0.15);\n        graphics.fillEllipse(\n            -halfSize * 0.3,\n            -halfSize * 0.4,\n            halfSize * 0.6,\n            halfSize * 0.4\n        );\n    }\n    \n    private createKeyHintBadge(key: number): Phaser.GameObjects.Container {\n        const badge = this.scene.add.container(0, 0);\n        \n        // Use theme color for badge\n        const badgeColor = this.currentTheme?.glow?.pulse || 0xFFD700;\n        \n        const bg = this.scene.add.circle(0, 0, 7 * HD_SCALE, badgeColor, 0.9);\n        bg.setStrokeStyle(1 * HD_SCALE, 0x000000, 1);\n        \n        const text = this.scene.add.text(0, 0, `${key}`, {\n            fontSize: `${6 * HD_SCALE}px`,  // Further reduced for smaller slots\n            fontFamily: 'Arial Black',\n            color: '#000000'\n        });\n        text.setOrigin(0.5);\n        \n        badge.add([bg, text]);\n        return badge;\n    }\n    \n    private setupArsenalListeners(): void {\n        // Listen for power-up collection\n        this.scene.events.on('power-up-collected', (data: any) => {\n            const shouldAdd = this.isOpponent ? \n                (data.owner === 'opponent') : \n                (data.owner === 'player');\n            \n            if (shouldAdd) {\n                this.addPowerUpToArsenal(data.type);\n            }\n        });\n        \n        // Keyboard controls only for player (only on desktop)\n        if (!this.isOpponent && !this.scene.game.device.input.touch) {\n            this.scene.input.keyboard?.on('keydown-ONE', () => this.activateArsenalSlot(0));\n            this.scene.input.keyboard?.on('keydown-TWO', () => this.activateArsenalSlot(1));\n            this.scene.input.keyboard?.on('keydown-THREE', () => this.activateArsenalSlot(2));\n        }\n    }\n    \n    private addPowerUpToArsenal(type: PowerUpType): void {\n        // Check if we already have this power-up\n        let slot = this.arsenalSlots.find(s => s.powerUpType === type);\n        \n        if (slot) {\n            // Increment count\n            slot.count++;\n            slot.countText.setText(slot.count > 1 ? `x${slot.count}` : '');\n        } else {\n            // Find empty slot\n            slot = this.arsenalSlots.find(s => !s.powerUpType);\n            \n            if (slot) {\n                slot.powerUpType = type;\n                slot.count = 1;\n                slot.icon.setText(this.powerUpIcons[type]);\n                \n                // Collection animation\n                this.showPowerUpCollectionEffect(slot);\n            }\n        }\n    }\n    \n    private activateArsenalSlot(index: number): void {\n        const slot = this.arsenalSlots[index];\n        \n        if (!slot || !slot.powerUpType || slot.count <= 0) {\n            // Empty slot feedback\n            if (slot) {\n                this.showEmptySlotFeedback(slot);\n            }\n            return;\n        }\n        \n        // Activate power-up\n        this.activatePowerUp(slot);\n    }\n    \n    private activatePowerUp(slot: ArsenalSlot): void {\n        if (!slot.powerUpType) return;\n        \n        // Visual activation sequence\n        this.showPowerUpActivation(slot);\n        \n        // Set active power-up\n        this.activePowerUp = slot.powerUpType;\n        \n        // Emit activation event\n        this.scene.events.emit('activate-power-up', {\n            type: slot.powerUpType\n        });\n        \n        // Decrease count\n        slot.count--;\n        \n        if (slot.count <= 0) {\n            // Clear slot\n            slot.powerUpType = undefined;\n            slot.icon.setText('');\n            slot.countText.setText('');\n            slot.isActive = false;\n        } else {\n            slot.countText.setText(slot.count > 1 ? `x${slot.count}` : '');\n        }\n        \n        // Start cooldown\n        this.startSlotCooldown(slot, 2000);\n    }\n    \n    private showPowerUpActivation(slot: ArsenalSlot): void {\n        // Create energy beam from slot to launcher\n        this.renderEnergyConduit(slot);\n        \n        // Chamber enhancement effect - maintain orientation\n        if (this.bubbleChamber) {\n            const baseScale = this.isOpponent ? -1 : 1;\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: { from: 1, to: 1.2, end: 1 },\n                scaleY: { from: baseScale, to: 1.2 * baseScale, end: baseScale },\n                duration: 300,\n                ease: 'Power2'\n            });\n        }\n        \n        // Slot activation burst\n        const burst = this.scene.add.graphics();\n        burst.fillStyle(0xFFD700, 0.6);\n        burst.fillCircle(slot.position.x, slot.position.y, this.SLOT_SIZE/2);\n        this.arsenalContainer?.add(burst);\n        \n        this.scene.tweens.add({\n            targets: burst,\n            scale: 2,\n            alpha: 0,\n            duration: 400,\n            ease: 'Power2',\n            onComplete: () => burst.destroy()\n        });\n    }\n    \n    private renderEnergyConduit(slot: ArsenalSlot): void {\n        if (!this.energyConduits) return;\n        \n        // Clear previous conduits\n        this.energyConduits.clear();\n        \n        // Draw energy beam\n        const startX = slot.position.x;\n        const startY = slot.position.y;\n        const endX = 0;\n        const endY = this.BUBBLE_POSITION_Y;\n        \n        // Animated energy beam\n        this.energyConduits.lineStyle(6 * HD_SCALE, 0xFFD700, 0.8);  // HD line width\n        this.energyConduits.lineBetween(startX, startY, endX, endY);\n        \n        // Create energy particles along the beam\n        for (let i = 0; i < 5; i++) {\n            const t = i / 4;\n            const px = startX + (endX - startX) * t;\n            const py = startY + (endY - startY) * t;\n            \n            const particle = this.scene.add.circle(px, py, 2 * HD_SCALE, 0xFFD700);\n            this.arsenalContainer?.add(particle);\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: endX,\n                y: endY,\n                scale: 0,\n                duration: 500,\n                delay: i * 50,\n                ease: 'Power2',\n                onComplete: () => particle.destroy()\n            });\n        }\n        \n        // Fade out conduit\n        this.scene.time.delayedCall(600, () => {\n            this.scene.tweens.add({\n                targets: this.energyConduits,\n                alpha: 0,\n                duration: 200,\n                onComplete: () => {\n                    this.energyConduits?.clear();\n                    this.energyConduits?.setAlpha(1);\n                }\n            });\n        });\n    }\n    \n    private showPowerUpCollectionEffect(slot: ArsenalSlot): void {\n        // Scale animation - maintain correct orientation for opponent\n        const baseScale = this.isOpponent ? -1 : 1;\n        this.scene.tweens.add({\n            targets: slot.container,\n            scaleX: { from: 1.3, to: 1 },\n            scaleY: { from: 1.3 * baseScale, to: baseScale },\n            duration: 300,\n            ease: 'Back.easeOut'\n        });\n        \n        // Glow effect\n        const collectFlash = this.scene.add.graphics();\n        collectFlash.fillStyle(0xFFD700, 0.5);\n        collectFlash.fillCircle(slot.position.x, slot.position.y, this.SLOT_SIZE);\n        this.arsenalContainer?.add(collectFlash);\n        \n        this.scene.tweens.add({\n            targets: collectFlash,\n            alpha: 0,\n            scale: 2,\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onComplete: () => collectFlash.destroy()\n        });\n    }\n    \n    private showEmptySlotFeedback(slot: ArsenalSlot): void {\n        // Red flash for empty slot\n        const flash = this.scene.add.graphics();\n        flash.fillStyle(0xFF0000, 0.3);\n        flash.fillCircle(0, 0, this.SLOT_SIZE/2);\n        slot.container.add(flash);\n        \n        this.scene.tweens.add({\n            targets: flash,\n            alpha: 0,\n            duration: 300,\n            onComplete: () => flash.destroy()\n        });\n    }\n    \n    private startSlotCooldown(slot: ArsenalSlot, duration: number): void {\n        // Create cooldown overlay\n        const overlay = this.scene.add.graphics();\n        overlay.fillStyle(0x000000, 0.7);\n        overlay.fillCircle(0, 0, this.SLOT_SIZE/2);\n        slot.container.add(overlay);\n        \n        // Progress arc\n        const progressArc = this.scene.add.graphics();\n        slot.container.add(progressArc);\n        \n        this.scene.tweens.add({\n            targets: { progress: 0 },\n            progress: 1,\n            duration: duration,\n            onUpdate: (tween) => {\n                const progress = tween.getValue();\n                progressArc.clear();\n                progressArc.lineStyle(6 * HD_SCALE, 0x4ECDC4, 0.8);  // HD line width\n                progressArc.beginPath();\n                progressArc.arc(0, 0, this.SLOT_SIZE/2 - (2 * HD_SCALE), -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * progress), false);\n                progressArc.strokePath();\n            },\n            onComplete: () => {\n                overlay.destroy();\n                progressArc.destroy();\n                this.drawArsenalSlotBackground(slot.background, false);\n            }\n        });\n    }\n    \n    /**\n     * Cleanup method\n     */\n    public override destroy(): void {\n        // Clean up arsenal\n        this.arsenalSlots.forEach(slot => {\n            this.scene.tweens.killTweensOf(slot.container);\n        });\n        \n        // Clean up animations\n        if (this.idleAnimation) {\n            this.idleAnimation.destroy();\n        }\n        if (this.chargingTween) {\n            this.chargingTween.destroy();\n        }\n        \n        // Remove event listeners\n        this.scene.events.off('power-up-collected');\n        this.scene.events.off('activate-power-up');\n        \n        super.destroy();\n    }\n}","import { IObjectiveConfig } from '@/types/ArenaTypes';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { AnimationBatcher } from '@/systems/visual/AnimationBatcher';\n\nexport class Objective extends Phaser.GameObjects.Container {\n    private chestBody: Phaser.GameObjects.Rectangle;\n    private chestLid: Phaser.GameObjects.Rectangle;\n    private chestLock: Phaser.GameObjects.Arc;\n    private shield: Phaser.GameObjects.Arc;\n    private glowEffect: Phaser.GameObjects.Arc;\n    private health: number;\n    private maxHealth: number;\n    private shielded: boolean = true;\n    // Store timer references for cleanup\n    private sparkleTimer?: Phaser.Time.TimerEvent;\n    private shimmerTimer?: Phaser.Time.TimerEvent;\n    private starBurstTimer?: Phaser.Time.TimerEvent;\n    private peekTimer?: Phaser.Time.TimerEvent;\n\n    constructor(scene: Phaser.Scene, config: IObjectiveConfig) {\n        super(scene, config.x, config.y);\n        \n        this.health = config.health;\n        this.maxHealth = config.health;\n        \n        // Multi-layered glow system (game industry standard)\n        // Outer glow - large and subtle\n        const outerGlow = scene.add.circle(0, 0, config.size / 2 + 15, 0xFFD700, 0.15);\n        this.add(outerGlow);\n        \n        // Middle glow - medium brightness\n        const middleGlow = scene.add.circle(0, 0, config.size / 2 + 8, 0xFFD700, 0.3);\n        this.add(middleGlow);\n        \n        // Inner glow - bright and focused\n        this.glowEffect = scene.add.circle(0, 0, config.size / 2 + 4, 0xFFD700, 0.5);\n        \n        // \"Breathing\" animation - industry standard for important objects\n        scene.tweens.add({\n            targets: [this.glowEffect, middleGlow, outerGlow],\n            scale: { from: 0.9, to: 1.15 },\n            alpha: { from: 0.4, to: 0.8 },\n            duration: 1500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Secondary pulse for extra attention\n        scene.tweens.add({\n            targets: outerGlow,\n            scale: { from: 1, to: 1.3 },\n            alpha: { from: 0.15, to: 0.05 },\n            duration: 2500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Quad.easeInOut'\n        });\n        \n        // Remove shield visual - chest is always the target!\n        this.shield = scene.add.circle(0, 0, config.size / 2 + 2, 0x00ffff, 0);\n        this.shield.setVisible(false);\n        this.shielded = false; // Chest is always a valid target\n        \n        // Create treasure chest\n        const chestSize = config.size * 0.7;\n        \n        // Chest body (main box) - no stroke\n        this.chestBody = scene.add.rectangle(0, 3, chestSize, chestSize * 0.8, 0x8B4513);\n        \n        // Chest lid (top part) - no stroke\n        this.chestLid = scene.add.rectangle(0, -5, chestSize * 1.1, chestSize * 0.4, 0xA0522D);\n        \n        // Chest lock (golden circle) - no stroke\n        this.chestLock = scene.add.circle(0, 3, chestSize * 0.15, 0xFFD700);\n        \n        // Add golden details\n        const detail1 = scene.add.rectangle(-chestSize * 0.3, 3, 2, chestSize * 0.6, 0xFFD700);\n        const detail2 = scene.add.rectangle(chestSize * 0.3, 3, 2, chestSize * 0.6, 0xFFD700);\n        const detail3 = scene.add.rectangle(0, 3, chestSize * 0.8, 2, 0xFFD700);\n        \n        this.add([this.glowEffect, this.shield, this.chestBody, detail1, detail2, detail3, this.chestLid, this.chestLock]);\n        \n        // Lock animation is now handled in the main animation section\n        \n        // Particle system - industry standard for objective highlighting\n        \n        // 1. OPTIMIZED: Batch sparkle creation (same visual, better performance)\n        this.sparkleTimer = scene.time.addEvent({\n            delay: 300, // Slightly less frequent but create more at once\n            repeat: -1,\n            callback: () => {\n                const sparkleCount = Phaser.Math.Between(2, 4); // More particles per batch\n                for (let i = 0; i < sparkleCount; i++) {\n                    const offsetX = Phaser.Math.Between(-config.size/2, config.size/2);\n                    const particle = scene.add.circle(\n                        offsetX,\n                        Phaser.Math.Between(-3, 3),\n                        Phaser.Math.Between(2, 4),\n                        Phaser.Utils.Array.GetRandom([0xFFD700, 0xFFA500, 0xFFFFAA, 0xFFE135]),\n                        1\n                    );\n                    this.add(particle);\n                    \n                    // Upward motion with slight drift\n                    scene.tweens.add({\n                        targets: particle,\n                        y: -config.size * 1.2,\n                        x: offsetX + Phaser.Math.Between(-8, 8),\n                        alpha: { from: 1, to: 0 },\n                        scale: { from: 1, to: 0.2 },\n                        duration: 1800,\n                        ease: 'Cubic.easeOut',\n                        delay: i * 100,\n                        onComplete: () => particle.destroy()\n                    });\n                }\n            }\n        });\n        \n        // 2. Orbital particles REMOVED - was causing floating particles issue\n        // Commented out to fix visual clutter\n        /*\n        for (let i = 0; i < 3; i++) {\n            const orbitRadius = config.size * 0.7;\n            const orbiter = scene.add.circle(\n                orbitRadius, 0, 3,\n                Phaser.Utils.Array.GetRandom([0xFFD700, 0xFFFFFF]),\n                0.8\n            );\n            this.add(orbiter);\n            \n            // Orbit animation\n            scene.tweens.add({\n                targets: orbiter,\n                angle: 360,\n                duration: 3000 + (i * 500),\n                repeat: -1,\n                ease: 'Linear'\n            });\n            \n            // Vertical bobbing\n            scene.tweens.add({\n                targets: orbiter,\n                y: Phaser.Math.Between(-5, 5),\n                duration: 1500 + (i * 200),\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut',\n                delay: i * 300\n            });\n        }\n        */\n        \n        // 3. Shimmer waves (used in Zelda, God of War, etc.) - Already optimized\n        this.shimmerTimer = scene.time.addEvent({\n            delay: 1500, // Already good frequency\n            repeat: -1,\n            callback: () => {\n                // Create expanding ring of light\n                const shimmer = scene.add.graphics();\n                shimmer.lineStyle(2, 0xFFFFFF, 0.8);\n                shimmer.strokeCircle(0, 0, config.size / 2);\n                this.add(shimmer);\n                \n                scene.tweens.add({\n                    targets: shimmer,\n                    scaleX: 2,\n                    scaleY: 2,\n                    alpha: 0,\n                    duration: 800,\n                    ease: 'Quad.easeOut',\n                    onComplete: () => shimmer.destroy()\n                });\n            }\n        });\n        \n        // 4. Screen-space particles for extra emphasis - Already optimized\n        this.starBurstTimer = scene.time.addEvent({\n            delay: 3000, // Already good frequency\n            repeat: -1,\n            callback: () => {\n                // Star burst every 3 seconds\n                for (let i = 0; i < 8; i++) {\n                    const angle = (i / 8) * Math.PI * 2;\n                    const distance = config.size * 0.4;\n                    const star = scene.add.star(\n                        Math.cos(angle) * distance,\n                        Math.sin(angle) * distance,\n                        4, 3, 6, 0xFFFFFF\n                    );\n                    star.setAlpha(0.9);\n                    this.add(star);\n                    \n                    scene.tweens.add({\n                        targets: star,\n                        x: Math.cos(angle) * config.size * 1.5,\n                        y: Math.sin(angle) * config.size * 1.5,\n                        alpha: 0,\n                        scale: 0,\n                        rotation: Math.PI * 2,\n                        duration: 1000,\n                        ease: 'Cubic.easeOut',\n                        delay: i * 50,\n                        onComplete: () => star.destroy()\n                    });\n                }\n            }\n        });\n        \n        // No ring - just particles for clean look\n        \n        this.setSize(config.size, config.size);\n        this.setDepth(Z_LAYERS.OBJECTIVE);\n        \n        // Enhanced chest animations (AAA game standards)\n        \n        // 1. \"Breathing\" animation - makes object feel alive\n        scene.tweens.add({\n            targets: this,\n            scaleX: { from: 0.98, to: 1.02 },\n            scaleY: { from: 0.98, to: 1.02 },\n            duration: 2000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // 2. Floating motion\n        scene.tweens.add({\n            targets: this,\n            y: config.y - 4,\n            duration: 2500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // 3. Subtle rocking for life\n        scene.tweens.add({\n            targets: this,\n            angle: { from: -1.5, to: 1.5 },\n            duration: 3200,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // 4. Lock highlight animation (focal point)\n        scene.tweens.add({\n            targets: this.chestLock,\n            scale: { from: 0.8, to: 1.3 },\n            alpha: { from: 0.7, to: 1 },\n            duration: 1200,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // 5. Chest lid occasional \"peek\" animation - Already optimized\n        this.peekTimer = scene.time.addEvent({\n            delay: 8000, // Already good frequency\n            repeat: -1,\n            callback: () => {\n                scene.tweens.add({\n                    targets: this.chestLid,\n                    y: this.chestLid.y - 3,\n                    angle: -5,\n                    duration: 300,\n                    yoyo: true,\n                    ease: 'Back.easeOut'\n                });\n            }\n        });\n        \n        // 6. Gold details shimmer\n        const details = [detail1, detail2, detail3];\n        details.forEach((detail, index) => {\n            scene.tweens.add({\n                targets: detail,\n                alpha: { from: 0.6, to: 1 },\n                duration: 800,\n                yoyo: true,\n                repeat: -1,\n                delay: index * 200,\n                ease: 'Quad.easeInOut'\n            });\n        });\n        \n        scene.add.existing(this);\n    }\n\n\n    public setShielded(shielded: boolean): void {\n        this.shielded = shielded;\n        \n        if (shielded) {\n            this.shield.setVisible(true);\n            this.scene.tweens.add({\n                targets: this.shield,\n                alpha: 0.5,\n                duration: 300,\n                ease: 'Power2'\n            });\n        } else {\n            // Shield broken animation\n            this.scene.tweens.add({\n                targets: this.shield,\n                alpha: 0,\n                scale: 1.5,\n                duration: 500,\n                ease: 'Power2',\n                onComplete: () => {\n                    this.shield.setVisible(false);\n                    this.showVulnerable();\n                }\n            });\n        }\n    }\n\n    private showVulnerable(): void {\n        // Glow brighter when vulnerable\n        this.scene.tweens.add({\n            targets: this.glowEffect,\n            scale: 1.3,\n            alpha: 0.8,\n            duration: 300,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Change chest color to indicate vulnerability\n        this.chestBody.setFillStyle(0xff6b6b);\n        this.chestLid.setFillStyle(0xff8888);\n    }\n\n    public hit(damage: number = 1): void {\n        this.health -= damage;\n        \n        // Play success objective sound when hit\n        this.scene.events.emit('objective-hit');\n        \n        // Impact animation\n        this.scene.tweens.add({\n            targets: this,\n            scaleX: 0.9,\n            scaleY: 0.9,\n            duration: 100,\n            yoyo: true,\n            ease: 'Power2'\n        });\n        \n        // Flash effect\n        const flash = this.scene.add.circle(this.x, this.y, 50, 0xffffff, 0.8);\n        this.scene.tweens.add({\n            targets: flash,\n            scale: 2,\n            alpha: 0,\n            duration: 300,\n            onComplete: () => flash.destroy()\n        });\n        \n        if (this.health <= 0) {\n            this.destroy();\n        }\n    }\n\n    public override destroy(): void {\n        // CRITICAL: Clean up all timers to prevent memory leak\n        if (this.sparkleTimer) {\n            this.sparkleTimer.destroy();\n            this.sparkleTimer = undefined;\n        }\n        if (this.shimmerTimer) {\n            this.shimmerTimer.destroy();\n            this.shimmerTimer = undefined;\n        }\n        if (this.starBurstTimer) {\n            this.starBurstTimer.destroy();\n            this.starBurstTimer = undefined;\n        }\n        if (this.peekTimer) {\n            this.peekTimer.destroy();\n            this.peekTimer = undefined;\n        }\n        \n        // Victory animation - chest opens\n        this.scene.tweens.add({\n            targets: this.chestLid,\n            y: -15,\n            rotation: -0.3,\n            duration: 500,\n            ease: 'Back.easeOut'\n        });\n        \n        // Chest disappears\n        this.scene.tweens.add({\n            targets: this,\n            scale: 1.5,\n            alpha: 0,\n            duration: 1000,\n            delay: 200,\n            ease: 'Power2',\n            onComplete: () => {\n                this.createVictoryParticles();\n                super.destroy();\n            }\n        });\n    }\n\n    private createVictoryParticles(): void {\n        // Create custom particles using circles instead of textures\n        for (let i = 0; i < 20; i++) {\n            const particle = this.scene.add.circle(\n                this.x, \n                this.y, \n                Phaser.Math.Between(3, 6),\n                Phaser.Utils.Array.GetRandom([0xffd700, 0xffa500, 0xff6347]),\n                1\n            );\n            \n            const angle = Math.random() * Math.PI * 2;\n            const speed = Phaser.Math.Between(100, 300);\n            const vx = Math.cos(angle) * speed;\n            const vy = Math.sin(angle) * speed;\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: particle.x + vx,\n                y: particle.y + vy,\n                alpha: 0,\n                scale: 0,\n                duration: 1000,\n                ease: 'Power2',\n                onComplete: () => particle.destroy()\n            });\n        }\n    }\n\n    public getHealth(): number {\n        return this.health;\n    }\n\n    public getMaxHealth(): number {\n        return this.maxHealth;\n    }\n\n    public isVulnerable(): boolean {\n        return !this.shielded;\n    }\n    \n    public isShielded(): boolean {\n        return this.shielded;\n    }\n    \n    public playVictoryAnimation(onComplete?: () => void): void {\n        // Stop any existing animations\n        this.scene.tweens.killTweensOf(this.chestLid);\n        this.scene.tweens.killTweensOf(this.glowEffect);\n        \n        // Hide shield immediately\n        this.shield.setVisible(false);\n        \n        // Glow bright gold (glowEffect is a circle, not graphics)\n        if (this.glowEffect instanceof Phaser.GameObjects.Arc) {\n            this.glowEffect.setFillStyle(0xFFD700, 1);\n        }\n        this.scene.tweens.add({\n            targets: this.glowEffect,\n            scale: 2,\n            alpha: 1,\n            duration: 300,\n            ease: 'Power2'\n        });\n        \n        // Open the chest lid\n        this.scene.tweens.add({\n            targets: this.chestLid,\n            y: -20,\n            angle: -45,\n            duration: 500,\n            ease: 'Back.easeOut',\n            delay: 200\n        });\n        \n        // Create treasure particles manually\n        const particleTimer = this.scene.time.addEvent({\n            delay: 50,\n            repeat: 20,\n            callback: () => {\n                for (let i = 0; i < 5; i++) {\n                    const particle = this.scene.add.circle(\n                        this.x + Phaser.Math.Between(-10, 10),\n                        this.y,\n                        Phaser.Math.Between(4, 8),\n                        Phaser.Utils.Array.GetRandom([0xFFD700, 0xFFA500, 0xFFFF00]),\n                        0.8\n                    );\n                    particle.setDepth(this.depth + 1);\n                    \n                    const angle = Phaser.Math.Between(-120, -60) * Math.PI / 180;\n                    const speed = Phaser.Math.Between(100, 300);\n                    const vx = Math.cos(angle) * speed;\n                    const vy = Math.sin(angle) * speed;\n                    \n                    this.scene.tweens.add({\n                        targets: particle,\n                        x: particle.x + vx,\n                        y: particle.y + vy - 200, // Simulate upward gravity\n                        alpha: 0,\n                        scale: 0,\n                        duration: 1500,\n                        ease: 'Power2',\n                        onComplete: () => particle.destroy()\n                    });\n                }\n            }\n        });\n        \n        // Shake effect\n        this.scene.cameras.main.shake(300, 0.01);\n        \n        // Scale pulse\n        this.scene.tweens.add({\n            targets: this,\n            scale: 1.2,\n            duration: 300,\n            yoyo: true,\n            ease: 'Power2',\n            onComplete: () => {\n                if (onComplete) onComplete();\n                \n                // Stop particle timer\n                this.scene.time.delayedCall(1000, () => {\n                    particleTimer.destroy();\n                });\n            }\n        });\n        \n        // Flash effect\n        this.scene.cameras.main.flash(500, 255, 215, 0);\n    }\n}","import Phaser from 'phaser';\n\nexport interface IInputPosition {\n    x: number;\n    y: number;\n    isActive: boolean;\n}\n\nexport class InputManager {\n    private scene: Phaser.Scene;\n    private pointer: Phaser.Input.Pointer;\n    private currentPosition: IInputPosition;\n    private sensitivity: number = 0.5; // Low sensitivity as per requirements\n    private isEnabled: boolean = true;\n    \n    constructor(scene: Phaser.Scene) {\n        this.scene = scene;\n        this.currentPosition = { x: 0, y: 0, isActive: false };\n        this.setupInput();\n    }\n    \n    private setupInput(): void {\n        // Get the main pointer (works for both mouse and touch)\n        this.pointer = this.scene.input.activePointer;\n        \n        // Enable input events\n        this.scene.input.on('pointermove', this.onPointerMove, this);\n        this.scene.input.on('pointerdown', this.onPointerDown, this);\n        this.scene.input.on('pointerup', this.onPointerUp, this);\n    }\n    \n    private onPointerMove(pointer: Phaser.Input.Pointer): void {\n        if (!this.isEnabled) return;\n        \n        // For initial setup, set position directly\n        if (this.currentPosition.x === 0 && this.currentPosition.y === 0) {\n            this.currentPosition.x = pointer.x;\n            this.currentPosition.y = pointer.y;\n        } else {\n            // Apply sensitivity to smooth out movement\n            const targetX = pointer.x;\n            const targetY = pointer.y;\n            \n            // Smooth interpolation with sensitivity\n            this.currentPosition.x += (targetX - this.currentPosition.x) * this.sensitivity;\n            this.currentPosition.y += (targetY - this.currentPosition.y) * this.sensitivity;\n        }\n    }\n    \n    private onPointerDown(_pointer: Phaser.Input.Pointer): void {\n        if (!this.isEnabled) return;\n        this.currentPosition.isActive = true;\n    }\n    \n    private onPointerUp(_pointer: Phaser.Input.Pointer): void {\n        this.currentPosition.isActive = false;\n    }\n    \n    public getPosition(): IInputPosition {\n        return this.currentPosition;\n    }\n    \n    public getPointerPosition(): { x: number; y: number } {\n        return {\n            x: this.currentPosition.x,\n            y: this.currentPosition.y\n        };\n    }\n    \n    public getAngleFrom(fromX: number, fromY: number): number {\n        const dx = this.currentPosition.x - fromX;\n        const dy = this.currentPosition.y - fromY;\n        \n        // Calculate angle in radians\n        let angle = Math.atan2(dy, dx);\n        \n        // Convert to degrees\n        let degrees = Phaser.Math.RadToDeg(angle);\n        \n        // Normalize to 0-360 range\n        if (degrees < 0) degrees += 360;\n        \n        return degrees;\n    }\n    \n    public getAngleFromWithConstraints(fromX: number, fromY: number, minAngle: number = 15, maxAngle: number = 165): number {\n        let angle = this.getAngleFrom(fromX, fromY);\n        \n        // Apply constraints (assuming 0° is right, 90° is down, 180° is left, 270° is up)\n        // For shooting upward, we want to constrain between 195° (15° from left) and 345° (15° from right)\n        // Adjusting for upward shooting from bottom\n        const constrainedMin = 180 + minAngle; // 195°\n        const constrainedMax = 360 - minAngle;  // 345°\n        \n        // Handle the constraint across the 0° boundary\n        if (angle >= 0 && angle <= 180) {\n            // Left side constraint\n            if (angle < 90) {\n                angle = constrainedMax;\n            } else {\n                angle = constrainedMin;\n            }\n        } else {\n            // Apply normal constraints\n            angle = Phaser.Math.Clamp(angle, constrainedMin, constrainedMax);\n        }\n        \n        return angle;\n    }\n    \n    public setEnabled(enabled: boolean): void {\n        this.isEnabled = enabled;\n    }\n    \n    public isPointerActive(): boolean {\n        return this.currentPosition.isActive;\n    }\n    \n    public setSensitivity(sensitivity: number): void {\n        this.sensitivity = Phaser.Math.Clamp(sensitivity, 0.1, 1.0);\n    }\n    \n    public update(): void {\n        // Update current position if pointer is not active (for mouse hover)\n        if (!this.currentPosition.isActive && this.pointer) {\n            this.currentPosition.x = this.pointer.x;\n            this.currentPosition.y = this.pointer.y;\n        }\n    }\n    \n    public destroy(): void {\n        this.scene.input.off('pointermove', this.onPointerMove, this);\n        this.scene.input.off('pointerdown', this.onPointerDown, this);\n        this.scene.input.off('pointerup', this.onPointerUp, this);\n    }\n}","import Phaser from 'phaser';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\nimport { BubbleColor } from '@/types/ArenaTypes';\n\ninterface ITrajectoryDot {\n    dot: Phaser.GameObjects.Arc;\n    targetAlpha: number;\n}\n\nexport class TrajectoryPreview {\n    private scene: Phaser.Scene;\n    private launcher: Launcher;\n    private dots: ITrajectoryDot[] = [];\n    private dotPool: Phaser.GameObjects.Arc[] = [];\n    private currentBubbleColor: number = 0xFFFFFF;\n    \n    // Preview settings\n    private readonly DOT_COUNT = 22; // More dots for longer preview\n    private readonly DOT_SIZE = 4 * HD_SCALE;\n    private readonly DOT_SPACING = 25 * HD_SCALE; // Slightly more spacing\n    private readonly PREVIEW_PERCENTAGE = 0.45; // Show more of the trajectory\n    private readonly MAX_PREVIEW_DISTANCE = 550 * HD_SCALE; // Much longer preview\n    private readonly SHOOT_SPEED = 600 * HD_SCALE;\n    \n    // Animation\n    private animationTime: number = 0;\n    private isVisible: boolean = false;\n    \n    // Bounds for wall collision\n    private bounds: Phaser.Geom.Rectangle;\n    \n    constructor(scene: Phaser.Scene, launcher: Launcher) {\n        this.scene = scene;\n        this.launcher = launcher;\n        \n        this.bounds = new Phaser.Geom.Rectangle(\n            0,\n            0,\n            scene.cameras.main.width,\n            scene.cameras.main.height\n        );\n        \n        this.createDotPool();\n    }\n    \n    private createDotPool(): void {\n        for (let i = 0; i < this.DOT_COUNT; i++) {\n            const dot = this.scene.add.circle(\n                0, 0,\n                this.DOT_SIZE,\n                0xffffff,\n                0\n            );\n            dot.setDepth(Z_LAYERS.UI - 1);\n            dot.setVisible(false);\n            this.dotPool.push(dot);\n        }\n    }\n    \n    public show(angle: number, bubbleColor?: number): void {\n        if (!this.isVisible) {\n            this.isVisible = true;\n            if (bubbleColor !== undefined) {\n                this.currentBubbleColor = bubbleColor;\n            }\n            this.calculateTrajectory(angle);\n        }\n    }\n    \n    public hide(): void {\n        this.isVisible = false;\n        this.dots.forEach(({ dot }) => {\n            dot.setVisible(false);\n            dot.setAlpha(0);\n        });\n        this.dots = [];\n    }\n    \n    private calculateTrajectory(angle: number): void {\n        // Clear previous dots\n        this.hide();\n        this.isVisible = true;\n        \n        // Starting position\n        let x = this.launcher.x;\n        let y = this.launcher.y - (35 * HD_SCALE); // Scaled bubble position\n        \n        // Calculate velocity from angle\n        // The launcher's getAimDirection uses the angle directly\n        // In world coordinates: 0° = right, 90° = down, 180° = left, 270° = up\n        const radians = Phaser.Math.DegToRad(angle);\n        let vx = Math.cos(radians) * this.SHOOT_SPEED;\n        let vy = Math.sin(radians) * this.SHOOT_SPEED;\n        \n        // Normalize to unit vector for stepping\n        const magnitude = Math.sqrt(vx * vx + vy * vy);\n        vx = (vx / magnitude) * this.DOT_SPACING;\n        vy = (vy / magnitude) * this.DOT_SPACING;\n        \n        // Calculate trajectory points\n        const maxDots = Math.floor(this.DOT_COUNT * this.PREVIEW_PERCENTAGE);\n        let dotIndex = 0;\n        let totalDistance = 0;\n        \n        while (dotIndex < maxDots && totalDistance < this.MAX_PREVIEW_DISTANCE) {\n            // Move to next position\n            x += vx;\n            y += vy;\n            totalDistance += this.DOT_SPACING;\n            \n            // Check for wall collisions\n            const radius = 16; // Bubble radius\n            \n            // Left wall bounce\n            if (x - radius <= this.bounds.left) {\n                x = this.bounds.left + radius;\n                vx = Math.abs(vx);\n            }\n            \n            // Right wall bounce\n            if (x + radius >= this.bounds.right) {\n                x = this.bounds.right - radius;\n                vx = -Math.abs(vx);\n            }\n            \n            // Top wall (stop preview here)\n            if (y - radius <= this.bounds.top) {\n                break;\n            }\n            \n            // Place dot\n            if (dotIndex < this.dotPool.length) {\n                const dot = this.dotPool[dotIndex];\n                dot.setPosition(x, y);\n                dot.setVisible(true);\n                // Calculate fade based on distance\n                const fadeStart = 0.3; // Start more visible\n                const fadeEnd = 0.8; // End still visible\n                const fadeProgress = dotIndex / maxDots;\n                const fadeFactor = fadeStart + (fadeEnd - fadeStart) * fadeProgress;\n                const targetAlpha = 0.95 * (1 - fadeFactor); // Slightly higher visibility\n                \n                this.dots.push({ dot, targetAlpha });\n                dotIndex++;\n            }\n        }\n    }\n    \n    public update(angle: number, delta: number, bubbleColor?: number): void {\n        if (!this.isVisible) return;\n        \n        if (bubbleColor !== undefined) {\n            this.currentBubbleColor = bubbleColor;\n        }\n        \n        // Recalculate trajectory\n        this.calculateTrajectory(angle);\n        \n        // Animate dots\n        this.animationTime += delta;\n        const animSpeed = 0.003;\n        \n        this.dots.forEach(({ dot, targetAlpha }, index) => {\n            // Create moving wave effect\n            const waveOffset = index * 0.15;\n            const wave = Math.sin(this.animationTime * animSpeed + waveOffset);\n            const animatedAlpha = targetAlpha * (0.75 + wave * 0.25); // Slightly more visible\n            \n            // Pulsing size effect - subtle for thinner dots\n            const sizeWave = 1 + wave * 0.2;\n            dot.setScale(sizeWave);\n            \n            // Apply alpha\n            dot.setAlpha(animatedAlpha);\n            \n            // Create gradient based on bubble color\n            const colorProgress = index / this.dots.length;\n            \n            // Get RGB components from bubble color\n            const baseColor = Phaser.Display.Color.IntegerToColor(this.currentBubbleColor);\n            \n            // Create gradient by darkening the color progressively\n            const red = Math.floor(baseColor.red * (1 - colorProgress * 0.4)); // Darken red\n            const green = Math.floor(baseColor.green * (1 - colorProgress * 0.4)); // Darken green  \n            const blue = Math.floor(baseColor.blue * (1 - colorProgress * 0.4)); // Darken blue\n            \n            const color = Phaser.Display.Color.GetColor(red, green, blue);\n            dot.setFillStyle(color);\n            \n            // Add stroke with bubble color for extra visibility\n            dot.setStrokeStyle(1, this.currentBubbleColor, 0.4); // Slightly more visible stroke\n        });\n    }\n    \n    public destroy(): void {\n        this.hide();\n        this.dotPool.forEach(dot => dot.destroy());\n        this.dotPool = [];\n    }\n}","import Phaser from 'phaser';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { BubbleColor } from '@/types/ArenaTypes';\nimport { InputManager } from '@/systems/input/InputManager';\nimport { TrajectoryPreview } from './TrajectoryPreview';\n// BubbleQueue removed - integrated into Launcher\nimport { GridAttachmentSystem } from './GridAttachmentSystem';\nimport { BubbleGrid } from './BubbleGrid';\nimport { ARENA_CONFIG, Z_LAYERS, BUBBLE_CONFIG } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\n\nexport interface IProjectile {\n    bubble: Bubble;\n    velocity: Phaser.Math.Vector2;\n    isActive: boolean;\n}\n\nexport class ShootingSystem {\n    private scene: Phaser.Scene;\n    private inputManager: InputManager;\n    private playerLauncher: Launcher;\n    private opponentLauncher?: Launcher;\n    \n    // Shooting mechanics\n    private projectiles: IProjectile[] = [];\n    private currentBubble: Bubble | null = null;\n    private nextBubbleColors: BubbleColor[] = []; // Store next 2-3 colors for launcher rings\n    private availableColors: BubbleColor[] = [\n        BubbleColor.RED,\n        BubbleColor.BLUE, \n        BubbleColor.GREEN,\n        BubbleColor.YELLOW,\n        BubbleColor.PURPLE\n    ];\n    private canShoot: boolean = true;\n    private cooldownTime: number = 1000; // 1 second in milliseconds\n    private shootSpeed: number = 600 * HD_SCALE; // Scaled speed\n    \n    // Arena boundaries for bouncing\n    private bounds: Phaser.Geom.Rectangle;\n    \n    // Cooldown indicator\n    private cooldownBar?: Phaser.GameObjects.Graphics;\n    private cooldownBarBg?: Phaser.GameObjects.Rectangle;\n    \n    // Trajectory preview\n    private trajectoryPreview: TrajectoryPreview;\n    \n    // Grid attachment\n    private gridAttachmentSystem?: GridAttachmentSystem;\n    private bubbleGrid?: BubbleGrid;\n    \n    constructor(\n        scene: Phaser.Scene,\n        inputManager: InputManager,\n        playerLauncher: Launcher,\n        gridAttachmentSystem?: GridAttachmentSystem,\n        bubbleGrid?: BubbleGrid\n    ) {\n        this.scene = scene;\n        this.inputManager = inputManager;\n        this.playerLauncher = playerLauncher;\n        this.gridAttachmentSystem = gridAttachmentSystem;\n        this.bubbleGrid = bubbleGrid;\n        \n        // Set arena bounds for wall bouncing\n        this.bounds = new Phaser.Geom.Rectangle(\n            0,\n            0,\n            scene.cameras.main.width,\n            scene.cameras.main.height\n        );\n        \n        // Initialize trajectory preview\n        this.trajectoryPreview = new TrajectoryPreview(scene, playerLauncher);\n        \n        // Initialize next bubble colors for integrated queue\n        this.generateNextBubbleColors();\n        \n        this.setupShooting();\n    }\n    \n    private setupShooting(): void {\n        // Listen for pointer events\n        this.scene.input.on('pointerdown', this.onPointerDown, this);\n        this.scene.input.on('pointerup', this.onShoot, this);\n        \n        // Listen for AI shoot events\n        this.scene.events.on('ai-shoot', this.onAIShoot, this);\n        \n        // Create cooldown indicator\n        this.createCooldownIndicator();\n        \n        // Initialize bubble queue\n        this.loadNextBubble();\n        \n        // Initialize launcher rings with queue colors\n        this.playerLauncher.updateQueueColors(this.nextBubbleColors);\n    }\n    \n    public setOpponentLauncher(launcher: Launcher): void {\n        this.opponentLauncher = launcher;\n    }\n    \n    private onPointerDown(): void {\n        // Always show trajectory preview when pressing\n        const angle = this.playerLauncher.getAimAngle();\n        \n        // Get bubble color - use current if available, otherwise use next\n        let bubbleColor = 0xFFFFFF; // Default white\n        if (this.currentBubble) {\n            bubbleColor = this.currentBubble.getColor();\n        } else if (this.nextBubbleColors.length > 0) {\n            bubbleColor = this.nextBubbleColors[0];\n        }\n        \n        this.trajectoryPreview.show(angle, bubbleColor);\n    }\n    \n    private createCooldownIndicator(): void {\n        const launcherY = this.playerLauncher.y + 40;\n        \n        // Background bar\n        this.cooldownBarBg = this.scene.add.rectangle(\n            this.playerLauncher.x,\n            launcherY,\n            80,\n            6,\n            0x2c3e50\n        );\n        this.cooldownBarBg.setStrokeStyle(1, 0x34495e);\n        this.cooldownBarBg.setDepth(Z_LAYERS.UI);\n        this.cooldownBarBg.setVisible(false);\n        \n        // Progress bar\n        this.cooldownBar = this.scene.add.graphics();\n        this.cooldownBar.setDepth(Z_LAYERS.UI);\n    }\n    \n    private startCooldownAnimation(): void {\n        this.cooldownBarBg?.setVisible(true);\n        \n        if (!this.cooldownBar) return;\n        \n        const barX = this.playerLauncher.x - 40;\n        const barY = this.playerLauncher.y + 37;\n        const barWidth = 80;\n        const barHeight = 6;\n        \n        // Animate cooldown bar\n        this.scene.tweens.add({\n            targets: { progress: 0 },\n            progress: 1,\n            duration: this.cooldownTime,\n            ease: 'Linear',\n            onUpdate: (tween) => {\n                const progress = tween.getValue();\n                this.cooldownBar?.clear();\n                this.cooldownBar?.fillStyle(0x27ae60, 1);\n                this.cooldownBar?.fillRect(\n                    barX,\n                    barY,\n                    barWidth * progress,\n                    barHeight\n                );\n            },\n            onComplete: () => {\n                this.cooldownBar?.clear();\n            }\n        });\n    }\n    \n    /**\n     * Generates next bubble colors for the integrated queue system\n     */\n    private generateNextBubbleColors(): void {\n        // Generate 3 colors: current + next 2\n        this.nextBubbleColors = [];\n        for (let i = 0; i < 3; i++) {\n            const randomColor = this.availableColors[Math.floor(Math.random() * this.availableColors.length)];\n            this.nextBubbleColors.push(randomColor);\n        }\n        \n        // console.log('ShootingSystem: Generated next bubble colors:', this.nextBubbleColors);\n    }\n    \n    /**\n     * Loads next bubble using integrated queue system\n     */\n    private loadNextBubble(): void {\n        // Get current color (first in queue)\n        const currentColor = this.nextBubbleColors[0] || BubbleColor.BLUE;\n        \n        // console.log('ShootingSystem: Loading bubble color:', currentColor);\n        \n        // Load bubble into launcher\n        this.playerLauncher.loadBubble(currentColor);\n        \n        // Get the loaded bubble from the launcher\n        this.currentBubble = this.playerLauncher.getLoadedBubble();\n        \n        // Shift queue and add new color\n        this.nextBubbleColors.shift(); // Remove current color\n        const newColor = this.availableColors[Math.floor(Math.random() * this.availableColors.length)];\n        this.nextBubbleColors.push(newColor); // Add new color at end\n        \n        // Update launcher queue rings with new colors\n        this.playerLauncher.updateQueueColors(this.nextBubbleColors);\n        \n        // console.log('ShootingSystem: Updated queue colors:', this.nextBubbleColors);\n    }\n    \n    private onShoot(): void {\n        // Hide trajectory preview\n        this.trajectoryPreview.hide();\n        \n        if (!this.canShoot || !this.currentBubble) return;\n        \n        // No turn checking - allow simultaneous shooting\n        \n        // Get launcher angle and direction\n        const angle = this.playerLauncher.getAimAngle();\n        const direction = this.playerLauncher.getAimDirection();\n        \n        // Create velocity vector\n        const velocity = new Phaser.Math.Vector2(\n            direction.x * this.shootSpeed,\n            direction.y * this.shootSpeed\n        );\n        \n        // Remove bubble from launcher before shooting\n        this.playerLauncher.clearLoadedBubble();\n        \n        // Position bubble at launcher's world position for shooting\n        this.currentBubble.setPosition(\n            this.playerLauncher.x,\n            this.playerLauncher.y - 35 // Match bubble position in launcher\n        );\n        \n        // Set bubble to normal size and mark as player shot\n        this.currentBubble.setScale(1);\n        this.currentBubble.setShooter('player');\n        // Return depth to projectile layer\n        this.currentBubble.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        \n        // Add to active projectiles\n        this.projectiles.push({\n            bubble: this.currentBubble,\n            velocity: velocity,\n            isActive: true\n        });\n        \n        // Emit shooting started event\n        this.scene.events.emit('shooting-started');\n        \n        // Emit bubble shoot event for sound system\n        this.scene.events.emit('bubble-shoot');\n        \n        // Play launcher animation with the color of the bubble being shot\n        const shotBubbleColor = this.currentBubble.getColor();\n        this.playerLauncher.animateShoot(shotBubbleColor);\n        \n        // Start cooldown with visual indicator\n        this.canShoot = false;\n        this.startCooldownAnimation();\n        \n        this.scene.time.delayedCall(this.cooldownTime, () => {\n            this.canShoot = true;\n            this.playerLauncher.setHighlight(false);\n            this.cooldownBarBg?.setVisible(false);\n            // Load next bubble after cooldown completes (like opponent)\n            this.loadNextBubble();\n        });\n        \n        // Visual feedback during cooldown\n        this.playerLauncher.setHighlight(true);\n        \n        // Clear current bubble immediately\n        this.currentBubble = null;\n    }\n    \n    private onAIShoot = (data: any): void => {\n        if (!this.opponentLauncher) return;\n        \n        // console.log('ShootingSystem: AI shooting angle=' + data.angle + ' color=0x' + data.color.toString(16));\n        \n        // Use the bubble that AI already has loaded (if provided)\n        let aiBubble: Bubble;\n        if (data.bubble) {\n            // Use the existing bubble from AI\n            aiBubble = data.bubble;\n            aiBubble.setShooter('ai');\n            aiBubble.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        } else {\n            // Fallback: create new bubble (shouldn't happen)\n            // console.warn('ShootingSystem: AI bubble not provided, creating new one');\n            aiBubble = new Bubble(\n                this.scene,\n                this.opponentLauncher.x,\n                this.opponentLauncher.y + 35, // Match bubble position (inverted for opponent)\n                data.color\n            );\n            aiBubble.setShooter('ai');\n            aiBubble.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        }\n        \n        // Calculate velocity based on angle\n        // AI uses standard math angles where:\n        // 0° = right, 90° = down, 180° = left, 270° = up\n        // No conversion needed!\n        const radians = Phaser.Math.DegToRad(data.angle);\n        const velocity = new Phaser.Math.Vector2(\n            Math.cos(radians) * this.shootSpeed,\n            Math.sin(radians) * this.shootSpeed\n        );\n        \n        // console.log(`ShootingSystem: Velocity x=${velocity.x.toFixed(1)} y=${velocity.y.toFixed(1)}`);\n        \n        // Create projectile\n        const projectile: IProjectile = {\n            bubble: aiBubble,\n            velocity: velocity,\n            isActive: true\n        };\n        \n        this.projectiles.push(projectile);\n        \n        // Emit shooting started event\n        this.scene.events.emit('shooting-started', { isAI: true });\n        \n        // Emit AI bubble shoot event for sound system\n        this.scene.events.emit('bubble-shoot', { isAI: true });\n        \n        // Visual feedback on opponent launcher\n        this.opponentLauncher.setHighlight(true);\n        this.scene.time.delayedCall(200, () => {\n            this.opponentLauncher.setHighlight(false);\n        });\n    }\n    \n    public update(delta: number): void {\n        // Update trajectory preview if aiming\n        if (this.inputManager.isPointerActive()) {\n            const angle = this.playerLauncher.getAimAngle();\n            \n            // Get bubble color - use current if available, otherwise use next\n            let bubbleColor = 0xFFFFFF; // Default white\n            if (this.currentBubble) {\n                bubbleColor = this.currentBubble.getColor();\n            } else if (this.nextBubbleColors.length > 0) {\n                bubbleColor = this.nextBubbleColors[0];\n            }\n            \n            this.trajectoryPreview.update(angle, delta, bubbleColor);\n        }\n        \n        // Check for projectile-to-projectile collisions\n        this.checkProjectileCollisions();\n        \n        // Update all active projectiles\n        for (let i = this.projectiles.length - 1; i >= 0; i--) {\n            const projectile = this.projectiles[i];\n            \n            if (!projectile.isActive) {\n                // Remove inactive projectiles\n                this.projectiles.splice(i, 1);\n                continue;\n            }\n            \n            // Update bubble position\n            projectile.bubble.x += projectile.velocity.x * (delta / 1000);\n            projectile.bubble.y += projectile.velocity.y * (delta / 1000);\n            \n            // Emit position update for chest collision detection\n            this.scene.events.emit('bubble-position-update', projectile.bubble);\n            \n            // Check if this bubble was marked as hit (chest collision)\n            if (!projectile.bubble.visible) {\n                projectile.isActive = false;\n                continue;\n            }\n            \n            // Check for grid collision if attachment system is available\n            if (this.gridAttachmentSystem) {\n                const hitBubble = this.gridAttachmentSystem.checkCollision(projectile.bubble);\n                if (hitBubble) {\n                    // Play attach sound immediately on collision detection\n                    this.scene.events.emit('bubble-attach-collision');\n                    \n                    // Find attachment position\n                    const attachPos = this.gridAttachmentSystem.findAttachmentPosition(\n                        projectile.bubble, \n                        hitBubble\n                    );\n                    \n                    if (attachPos) {\n                        // Validate that the position is reasonable (not too far from hit point)\n                        const pixelPos = this.bubbleGrid?.hexToPixel(attachPos);\n                        if (pixelPos) {\n                            const distance = Phaser.Math.Distance.Between(\n                                projectile.bubble.x, projectile.bubble.y,\n                                pixelPos.x, pixelPos.y\n                            );\n                            \n                            // Only attach if distance is reasonable (within 2 bubble diameters)\n                            if (distance < BUBBLE_CONFIG.SIZE * 2) {\n                                projectile.isActive = false;\n                                \n                                // Stop the bubble's movement immediately\n                                projectile.velocity.x = 0;\n                                projectile.velocity.y = 0;\n                                \n                                // Attach to grid with callback\n                                this.gridAttachmentSystem.attachToGrid(projectile.bubble, attachPos, () => {\n                                    // Emit shooting complete event after attachment\n                                    this.scene.events.emit('shooting-complete');\n                                });\n                                \n                                continue;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Check for wall collisions\n            this.checkWallCollision(projectile);\n            \n            // Check if bubble went out of bounds\n            if (projectile.bubble.y < -50 || projectile.bubble.y > this.bounds.height + 50) {\n                projectile.isActive = false;\n                projectile.bubble.destroy();\n            }\n        }\n    }\n    \n    private checkProjectileCollisions(): void {\n        const radius = BUBBLE_CONFIG.SIZE / 2;\n        \n        // Check each projectile against all others\n        for (let i = 0; i < this.projectiles.length; i++) {\n            const proj1 = this.projectiles[i];\n            if (!proj1.isActive) continue;\n            \n            for (let j = i + 1; j < this.projectiles.length; j++) {\n                const proj2 = this.projectiles[j];\n                if (!proj2.isActive) continue;\n                \n                // Calculate distance between projectiles\n                const distance = Phaser.Math.Distance.Between(\n                    proj1.bubble.x, proj1.bubble.y,\n                    proj2.bubble.x, proj2.bubble.y\n                );\n                \n                // Check if collision occurred\n                if (distance < radius * 2) {\n                    // Calculate collision normal\n                    const dx = proj2.bubble.x - proj1.bubble.x;\n                    const dy = proj2.bubble.y - proj1.bubble.y;\n                    const len = Math.sqrt(dx * dx + dy * dy);\n                    \n                    if (len > 0) {\n                        // Normalize\n                        const nx = dx / len;\n                        const ny = dy / len;\n                        \n                        // Separate bubbles\n                        const overlap = (radius * 2) - distance;\n                        proj1.bubble.x -= nx * overlap * 0.5;\n                        proj1.bubble.y -= ny * overlap * 0.5;\n                        proj2.bubble.x += nx * overlap * 0.5;\n                        proj2.bubble.y += ny * overlap * 0.5;\n                        \n                        // Calculate relative velocity\n                        const relVelX = proj2.velocity.x - proj1.velocity.x;\n                        const relVelY = proj2.velocity.y - proj1.velocity.y;\n                        const speed = relVelX * nx + relVelY * ny;\n                        \n                        // Don't resolve if velocities are separating\n                        if (speed < 0) continue;\n                        \n                        // Apply elastic collision with some damping\n                        const impulse = speed * 0.8; // 0.8 = restitution coefficient\n                        \n                        proj1.velocity.x += impulse * nx;\n                        proj1.velocity.y += impulse * ny;\n                        proj2.velocity.x -= impulse * nx;\n                        proj2.velocity.y -= impulse * ny;\n                        \n                        // Add small random deviation to prevent stuck bubbles\n                        proj1.velocity.x += (Math.random() - 0.5) * 20;\n                        proj1.velocity.y += (Math.random() - 0.5) * 20;\n                        proj2.velocity.x += (Math.random() - 0.5) * 20;\n                        proj2.velocity.y += (Math.random() - 0.5) * 20;\n                        \n                        // Emit projectile collision event for sound/haptics\n                        this.scene.events.emit('projectile-collision');\n                    }\n                }\n            }\n        }\n    }\n    \n    private checkWallCollision(projectile: IProjectile): void {\n        const bubble = projectile.bubble;\n        const radius = BUBBLE_CONFIG.SIZE / 2;\n        \n        // Left wall\n        if (bubble.x - radius <= this.bounds.left) {\n            bubble.x = this.bounds.left + radius;\n            projectile.velocity.x = Math.abs(projectile.velocity.x); // Bounce right\n            this.scene.events.emit('wall-bounce');\n        }\n        \n        // Right wall\n        if (bubble.x + radius >= this.bounds.right) {\n            bubble.x = this.bounds.right - radius;\n            projectile.velocity.x = -Math.abs(projectile.velocity.x); // Bounce left\n            this.scene.events.emit('wall-bounce');\n        }\n        \n        // Top wall - bubble explodes when reaching opponent side\n        if (bubble.y - radius <= this.bounds.top) {\n            // Bubble reached the top (opponent zone), explode it\n            projectile.isActive = false;\n            bubble.pop();\n            \n            // TODO: Future feature - if bubble passes near opponent launcher, apply slow debuff\n        }\n    }\n    \n    public isReady(): boolean {\n        return this.canShoot;\n    }\n    \n    public getProjectileCount(): number {\n        return this.projectiles.length;\n    }\n    \n    public destroy(): void {\n        this.scene.input.off('pointerdown', this.onPointerDown, this);\n        this.scene.input.off('pointerup', this.onShoot, this);\n        \n        // Clean up trajectory preview\n        this.trajectoryPreview?.destroy();\n        \n        // Clean up projectiles\n        this.projectiles.forEach(p => {\n            if (p.bubble) p.bubble.destroy();\n        });\n        this.projectiles = [];\n        \n        // Clean up current bubble\n        if (this.currentBubble) {\n            this.currentBubble.destroy();\n        }\n        \n        // Queue is now integrated into launcher - no separate cleanup needed\n        \n        // Clean up cooldown indicator\n        this.cooldownBar?.destroy();\n        this.cooldownBarBg?.destroy();\n    }\n}","import { Scene } from 'phaser';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { BubbleGrid } from './BubbleGrid';\nimport { IHexPosition, ArenaZone } from '@/types/ArenaTypes';\nimport { BUBBLE_CONFIG, Z_LAYERS } from '@/config/ArenaConfig';\nimport { MatchDetectionSystem } from './MatchDetectionSystem';\n\nexport class GridAttachmentSystem {\n    private scene: Scene;\n    private bubbleGrid: BubbleGrid;\n    private gridBubbles: Bubble[] = [];\n    private attachmentInProgress: boolean = false;\n    private attachmentQueue: Array<{ bubble: Bubble; hexPos: IHexPosition; onComplete?: () => void }> = [];\n    private matchDetectionSystem?: MatchDetectionSystem;\n    private spatialGrid: Map<string, Bubble[]> = new Map(); // Spatial partitioning for faster collision\n    private gridPositions: Map<string, Bubble> = new Map(); // Track positions\n    \n    constructor(scene: Scene, bubbleGrid: BubbleGrid) {\n        this.scene = scene;\n        this.bubbleGrid = bubbleGrid;\n    }\n    \n    public setMatchDetectionSystem(matchDetectionSystem: MatchDetectionSystem): void {\n        this.matchDetectionSystem = matchDetectionSystem;\n    }\n    \n    /**\n     * Register a bubble as part of the grid\n     */\n    public addGridBubble(bubble: Bubble): void {\n        if (!this.gridBubbles.includes(bubble)) {\n            this.gridBubbles.push(bubble);\n            this.updateSpatialGrid(); // Update spatial partitioning\n        }\n    }\n    \n    /**\n     * Remove a bubble from the grid\n     */\n    public removeGridBubble(bubble: Bubble): void {\n        const index = this.gridBubbles.indexOf(bubble);\n        if (index > -1) {\n            this.gridBubbles.splice(index, 1);\n            this.updateSpatialGrid(); // Update spatial partitioning\n        }\n    }\n    \n    /**\n     * Check collision between projectile and grid bubbles - OPTIMIZED\n     */\n    public checkCollision(projectile: Bubble): Bubble | null {\n        const projectilePos = { x: projectile.x, y: projectile.y };\n        // Use bubble diameter for collision detection\n        const collisionRadius = BUBBLE_CONFIG.SIZE - 2; // Slightly less than diameter for proper touching\n        \n        // Check objective collision first (if near center)\n        const centerPixel = this.bubbleGrid.hexToPixel({ q: 0, r: 0, s: 0 });\n        const centerDistance = Phaser.Math.Distance.Between(\n            projectilePos.x, projectilePos.y,\n            centerPixel.x, centerPixel.y\n        );\n        \n        // If very close to center and no bubble there, attach to center\n        if (centerDistance < BUBBLE_CONFIG.SIZE && !this.isPositionOccupied({ q: 0, r: 0, s: 0 })) {\n            // Create a virtual bubble at center for attachment reference\n            const virtualBubble = new Bubble(\n                this.scene,\n                centerPixel.x,\n                centerPixel.y,\n                0x000000\n            );\n            virtualBubble.setGridPosition({ q: 0, r: 0, s: 0 });\n            virtualBubble.setVisible(false);\n            return virtualBubble;\n        }\n        \n        // OPTIMIZED: Only check nearby bubbles using spatial partitioning\n        const nearbyBubbles = this.getNearbyBubbles(projectilePos.x, projectilePos.y);\n        \n        for (const gridBubble of nearbyBubbles) {\n            if (!gridBubble.visible) continue;\n            \n            const distance = Phaser.Math.Distance.Between(\n                projectilePos.x, projectilePos.y,\n                gridBubble.x, gridBubble.y\n            );\n            \n            // Check if bubbles are touching\n            if (distance < collisionRadius) {\n                return gridBubble;\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Get bubbles near a position using spatial partitioning\n     */\n    private getNearbyBubbles(x: number, y: number): Bubble[] {\n        // Use a simple grid-based spatial partitioning\n        const gridSize = BUBBLE_CONFIG.SIZE * 2; // Cell size\n        const cellX = Math.floor(x / gridSize);\n        const cellY = Math.floor(y / gridSize);\n        \n        const nearby: Bubble[] = [];\n        \n        // Check current cell and adjacent cells (3x3 grid)\n        for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n                const key = `${cellX + dx},${cellY + dy}`;\n                const cellBubbles = this.spatialGrid.get(key);\n                if (cellBubbles) {\n                    nearby.push(...cellBubbles);\n                }\n            }\n        }\n        \n        return nearby;\n    }\n    \n    /**\n     * Update spatial grid when bubbles are added/removed\n     */\n    private updateSpatialGrid(): void {\n        this.spatialGrid.clear();\n        const gridSize = BUBBLE_CONFIG.SIZE * 2;\n        \n        for (const bubble of this.gridBubbles) {\n            if (!bubble.visible) continue;\n            \n            const cellX = Math.floor(bubble.x / gridSize);\n            const cellY = Math.floor(bubble.y / gridSize);\n            const key = `${cellX},${cellY}`;\n            \n            if (!this.spatialGrid.has(key)) {\n                this.spatialGrid.set(key, []);\n            }\n            this.spatialGrid.get(key)!.push(bubble);\n        }\n    }\n    \n    /**\n     * Find best attachment position based on impact\n     */\n    public findAttachmentPosition(projectile: Bubble, hitBubble: Bubble): IHexPosition | null {\n        // Get hex position of hit bubble\n        const hitHexPos = hitBubble.getGridPosition();\n        if (!hitHexPos) {\n            console.warn('Hit bubble has no grid position');\n            return null;\n        }\n        \n        // console.log('Hit bubble at hex:', hitHexPos, 'pixel:', { x: hitBubble.x, y: hitBubble.y });\n        // console.log('Projectile at:', { x: projectile.x, y: projectile.y });\n        \n        // Calculate impact angle\n        const dx = projectile.x - hitBubble.x;\n        const dy = projectile.y - hitBubble.y;\n        const angle = Math.atan2(dy, dx);\n        const angleDeg = (angle * 180 / Math.PI + 360) % 360;\n        \n        // console.log('Impact angle:', angleDeg.toFixed(1), 'degrees');\n        \n        // For offset grid, we need to consider the row offset when getting neighbors\n        // In an offset grid, odd rows have different neighbor offsets\n        const isOddRow = Math.abs(hitHexPos.r) % 2 === 1;\n        \n        // Define neighbor offsets for offset grid\n        // Even rows and odd rows have different neighbor patterns\n        let neighborOffsets: Array<{q: number, r: number, angle: number}> = [];\n        \n        if (!isOddRow) {\n            // Even row neighbors\n            neighborOffsets = [\n                { q: 0, r: -1, angle: 270 },  // Top\n                { q: 1, r: 0, angle: 0 },     // Right  \n                { q: 0, r: 1, angle: 90 },    // Bottom\n                { q: -1, r: 1, angle: 135 },  // Bottom-left\n                { q: -1, r: 0, angle: 180 },  // Left\n                { q: -1, r: -1, angle: 225 }  // Top-left\n            ];\n        } else {\n            // Odd row neighbors (offset by half)\n            neighborOffsets = [\n                { q: 0, r: -1, angle: 270 },  // Top\n                { q: 1, r: -1, angle: 315 },  // Top-right\n                { q: 1, r: 0, angle: 0 },     // Right\n                { q: 1, r: 1, angle: 45 },    // Bottom-right\n                { q: 0, r: 1, angle: 90 },    // Bottom\n                { q: -1, r: 0, angle: 180 }   // Left\n            ];\n        }\n        \n        // Find the best neighbor based on impact angle\n        let bestNeighbor: IHexPosition | null = null;\n        let minAngleDiff = 360;\n        \n        for (const offset of neighborOffsets) {\n            const neighbor: IHexPosition = {\n                q: hitHexPos.q + offset.q,\n                r: hitHexPos.r + offset.r,\n                s: 0 // Not used in offset grid\n            };\n            \n            // Skip if position is occupied\n            if (this.isPositionOccupied(neighbor)) {\n                // console.log('Position occupied:', neighbor);\n                continue;\n            }\n            \n            // Calculate angle difference\n            let angleDiff = Math.abs(angleDeg - offset.angle);\n            if (angleDiff > 180) angleDiff = 360 - angleDiff;\n            \n            // console.log('Checking neighbor:', neighbor, 'angle:', offset.angle, 'diff:', angleDiff.toFixed(1));\n            \n            // Choose the neighbor with the closest angle match\n            if (angleDiff < minAngleDiff) {\n                minAngleDiff = angleDiff;\n                bestNeighbor = neighbor;\n            }\n        }\n        \n        if (bestNeighbor) {\n            const pixelPos = this.bubbleGrid.hexToPixel(bestNeighbor);\n            // console.log('Best attachment position - hex:', bestNeighbor, 'pixel:', pixelPos);\n        } else {\n            console.warn('No valid attachment position found');\n        }\n        \n        return bestNeighbor;\n    }\n    \n    /**\n     * Find best available position near target\n     */\n    private findBestAvailablePosition(targetHex: IHexPosition, bubble: Bubble): IHexPosition | null {\n        // First check if target is available\n        if (!this.isPositionOccupied(targetHex) && this.isValidPosition(targetHex)) {\n            return targetHex;\n        }\n        \n        // console.log('Target position occupied or invalid, searching alternatives');\n        \n        // Search in expanding rings for available position\n        for (let ring = 1; ring <= 3; ring++) {\n            const ringPositions = this.bubbleGrid.getRing(targetHex, ring);\n            \n            // Find closest available position in this ring\n            let bestPos: IHexPosition | null = null;\n            let minDistance = Infinity;\n            \n            for (const pos of ringPositions) {\n                if (!this.isPositionOccupied(pos) && this.isValidPosition(pos)) {\n                    const pixelPos = this.bubbleGrid.hexToPixel(pos);\n                    const distance = Phaser.Math.Distance.Between(\n                        bubble.x, bubble.y,\n                        pixelPos.x, pixelPos.y\n                    );\n                    \n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        bestPos = pos;\n                    }\n                }\n            }\n            \n            if (bestPos) {\n                // console.log(`Found available position at ring ${ring}:`, bestPos);\n                return bestPos;\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Check if position is valid (has at least one neighbor)\n     */\n    private isValidPosition(hexPos: IHexPosition): boolean {\n        // Center position is always valid\n        if (hexPos.q === 0 && hexPos.r === 0) return true;\n        \n        // Check if position has at least one neighbor bubble\n        const neighbors = this.bubbleGrid.getNeighbors(hexPos);\n        return neighbors.some(neighbor => this.isPositionOccupied(neighbor));\n    }\n    \n    /**\n     * Check if a hex position is occupied - OPTIMIZED\n     */\n    private isPositionOccupied(hexPos: IHexPosition): boolean {\n        // OPTIMIZED: Use position map for O(1) lookup instead of O(n) iteration\n        const key = this.hexToKey(hexPos);\n        if (this.gridPositions.has(key)) {\n            const bubble = this.gridPositions.get(key);\n            return bubble ? bubble.visible : false;\n        }\n        \n        // Fallback: Check by pixel proximity only for nearby bubbles\n        const pixelPos = this.bubbleGrid.hexToPixel(hexPos);\n        const threshold = BUBBLE_CONFIG.SIZE * 0.8;\n        const nearbyBubbles = this.getNearbyBubbles(pixelPos.x, pixelPos.y);\n        \n        return nearbyBubbles.some(bubble => {\n            if (!bubble.visible) return false;\n            \n            const distance = Phaser.Math.Distance.Between(\n                bubble.x, bubble.y,\n                pixelPos.x, pixelPos.y\n            );\n            \n            return distance < threshold;\n        });\n    }\n    \n    /**\n     * Convert hex position to string key\n     */\n    private hexToKey(hexPos: IHexPosition): string {\n        return `${hexPos.q},${hexPos.r}`;\n    }\n    \n    /**\n     * Attach bubble to grid at specified position\n     */\n    public attachToGrid(bubble: Bubble, hexPos: IHexPosition, onComplete?: () => void): void {\n        if (this.attachmentInProgress) {\n            // console.warn('Attachment already in progress, queueing bubble');\n            // Queue this attachment for later\n            this.attachmentQueue.push({ bubble, hexPos, onComplete });\n            return;\n        }\n        \n        // Validate and find best position\n        hexPos = this.findBestAvailablePosition(hexPos, bubble);\n        \n        if (!hexPos) {\n            console.warn('No valid position found, destroying bubble');\n            bubble.destroy();\n            if (onComplete) onComplete();\n            return;\n        }\n        \n        this.attachmentInProgress = true;\n        \n        // Get exact pixel position for this hex coordinate\n        const pixelPos = this.bubbleGrid.hexToPixel(hexPos);\n        \n        // console.log('Attaching bubble to hex:', hexPos, 'pixel:', pixelPos);\n        \n        // Clean up any existing bubbles that might be misaligned at this position\n        this.cleanupMisalignedBubbles(hexPos, bubble);\n        \n        // Set grid position BEFORE moving\n        bubble.setGridPosition(hexPos);\n        \n        // Update position map for O(1) lookups\n        const key = this.hexToKey(hexPos);\n        this.gridPositions.set(key, bubble);\n        \n        // Add to grid bubbles immediately to prevent double-occupation\n        this.addGridBubble(bubble);\n        \n        // Animate to position\n        const distance = Phaser.Math.Distance.Between(\n            bubble.x, bubble.y,\n            pixelPos.x, pixelPos.y\n        );\n        \n        // Use shorter duration for closer distances\n        const duration = Math.min(200, Math.max(50, distance * 0.5));\n        \n        // Sound is now played earlier in ShootingSystem on collision detection\n        \n        this.scene.tweens.add({\n            targets: bubble,\n            x: pixelPos.x,\n            y: pixelPos.y,\n            duration: duration,\n            ease: 'Power2',\n            onComplete: () => {\n                // Enhanced attachment feedback\n                this.createAttachmentEffect(bubble);\n                \n                // Small bounce effect\n                this.scene.tweens.add({\n                    targets: bubble,\n                    scaleX: 1.15,\n                    scaleY: 1.15,\n                    duration: 80,\n                    ease: 'Back.easeOut',\n                    yoyo: true\n                });\n            }\n        });\n        \n        // Delay slightly before checking matches to ensure position is settled\n        this.scene.time.delayedCall(duration + 100, async () => {\n            // console.log('Attachment complete, checking for matches...');\n            \n            // Verify bubble is properly positioned\n            const finalPixelPos = this.bubbleGrid.hexToPixel(hexPos);\n            if (Phaser.Math.Distance.Between(bubble.x, bubble.y, finalPixelPos.x, finalPixelPos.y) > 5) {\n                // console.warn('Bubble not properly positioned, correcting...');\n                bubble.setPosition(finalPixelPos.x, finalPixelPos.y);\n            }\n            \n            // Check for matches FIRST\n            if (this.matchDetectionSystem) {\n                // console.log('MatchDetectionSystem available, checking bubble color:', bubble.getColor()?.toString(16));\n                await this.matchDetectionSystem.checkForMatches(bubble);\n            } else {\n                console.warn('MatchDetectionSystem not available!');\n            }\n            \n            // Then check for disconnected bubbles\n            this.checkDisconnectedBubbles();\n            \n            this.attachmentInProgress = false;\n            \n            // Emit bubble attached event with data\n            // Only emit if bubble is visible and has a valid position\n            if (bubble.visible && bubble.getGridPosition()) {\n                this.scene.events.emit('bubble-attached', { bubble, position: hexPos });\n            }\n            \n            // If no matches, emit matches-resolved\n            this.scene.time.delayedCall(100, () => {\n                this.scene.events.emit('matches-resolved');\n            });\n            \n            if (onComplete) {\n                onComplete();\n            }\n            \n            // Process queued attachments\n            if (this.attachmentQueue.length > 0) {\n                const next = this.attachmentQueue.shift();\n                if (next) {\n                    this.scene.time.delayedCall(50, () => {\n                        this.attachToGrid(next.bubble, next.hexPos, next.onComplete);\n                    });\n                }\n            }\n        });\n    }\n    \n    /**\n     * Create visual effect when bubble attaches\n     */\n    private createAttachmentEffect(bubble: Bubble): void {\n        const color = bubble.getColor();\n        \n        // Create a ring effect at attachment point\n        const ring = this.scene.add.circle(bubble.x, bubble.y, BUBBLE_CONFIG.SIZE / 2, color, 0);\n        ring.setStrokeStyle(2, color, 0.6);\n        ring.setDepth(bubble.depth - 1);\n        \n        // Animate ring expansion\n        this.scene.tweens.add({\n            targets: ring,\n            scale: 1.5,\n            alpha: 0,\n            duration: 300,\n            ease: 'Power2',\n            onComplete: () => {\n                ring.destroy();\n            }\n        });\n        \n        // Small particle burst\n        for (let i = 0; i < 4; i++) {\n            const particle = this.scene.add.circle(\n                bubble.x,\n                bubble.y,\n                2,\n                color,\n                0.8\n            );\n            \n            const angle = (Math.PI * 2 * i) / 4;\n            const distance = 20;\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: bubble.x + Math.cos(angle) * distance,\n                y: bubble.y + Math.sin(angle) * distance,\n                scale: 0,\n                alpha: 0,\n                duration: 250,\n                ease: 'Power2',\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n    }\n    \n    /**\n     * Clean up any misaligned bubbles at position\n     */\n    private cleanupMisalignedBubbles(hexPos: IHexPosition, newBubble: Bubble): void {\n        const pixelPos = this.bubbleGrid.hexToPixel(hexPos);\n        const threshold = BUBBLE_CONFIG.SIZE * 0.9;\n        \n        // Find and remove any bubbles too close to this position\n        const toRemove: Bubble[] = [];\n        \n        this.gridBubbles.forEach(bubble => {\n            if (bubble === newBubble || !bubble.visible) return;\n            \n            const distance = Phaser.Math.Distance.Between(\n                bubble.x, bubble.y,\n                pixelPos.x, pixelPos.y\n            );\n            \n            if (distance < threshold) {\n                // console.warn('Found overlapping bubble, removing it:', bubble.getGridPosition());\n                toRemove.push(bubble);\n            }\n        });\n        \n        // Remove overlapping bubbles\n        toRemove.forEach(bubble => {\n            this.removeGridBubble(bubble);\n            bubble.destroy();\n        });\n    }\n    \n    /**\n     * Check for disconnected bubbles after attachment\n     */\n    private checkDisconnectedBubbles(): void {\n        const disconnected = this.findDisconnectedGroups();\n        \n        // Apply bidirectional gravity based on Y position, not zone\n        const allDisconnected: Bubble[] = [];\n        disconnected.forEach((bubbles) => {\n            allDisconnected.push(...bubbles);\n        });\n        \n        if (allDisconnected.length > 0) {\n            this.applyBidirectionalGravity(allDisconnected);\n        }\n    }\n    \n    /**\n     * Find all disconnected bubble groups by zone\n     */\n    public findDisconnectedGroups(): Map<ArenaZone, Bubble[]> {\n        const disconnected = new Map<ArenaZone, Bubble[]>();\n        disconnected.set(ArenaZone.PLAYER, []);\n        disconnected.set(ArenaZone.OPPONENT, []);\n        disconnected.set(ArenaZone.OBJECTIVE, []);\n        \n        // Mark all bubbles as unvisited\n        const visited = new Set<Bubble>();\n        const connected = new Set<Bubble>();\n        \n        // Find bubbles adjacent to the objective (center position)\n        const centerHex: IHexPosition = { q: 0, r: 0, s: 0 };\n        const anchors: Bubble[] = [];\n        \n        // Get bubbles at center and immediate neighbors as anchors\n        const centerBubble = this.getBubbleAtPosition(centerHex);\n        if (centerBubble) {\n            anchors.push(centerBubble);\n        }\n        \n        // Get neighbors of center as additional anchors\n        const centerNeighbors = this.bubbleGrid.getNeighbors(centerHex);\n        centerNeighbors.forEach(neighborHex => {\n            const bubble = this.getBubbleAtPosition(neighborHex);\n            if (bubble) {\n                anchors.push(bubble);\n            }\n        });\n        \n        // If no anchors (no bubbles near objective), all bubbles are disconnected\n        if (anchors.length === 0) {\n            // console.log('No anchors found - all bubbles are floating!');\n            this.gridBubbles.forEach(bubble => {\n                if (bubble.visible) {\n                    const zone = this.getZoneForBubble(bubble);\n                    disconnected.get(zone)?.push(bubble);\n                }\n            });\n            return disconnected;\n        }\n        \n        // console.log(`Found ${anchors.length} anchor bubbles near objective`);\n        \n        // Flood fill from each anchor to find connected bubbles\n        anchors.forEach(anchor => {\n            this.floodFill(anchor, visited, connected);\n        });\n        \n        // console.log(`${connected.size} bubbles are connected to objective`);\n        \n        // Any unvisited bubbles are disconnected and should fall\n        this.gridBubbles.forEach(bubble => {\n            if (!connected.has(bubble) && bubble.visible) {\n                const zone = this.getZoneForBubble(bubble);\n                disconnected.get(zone)?.push(bubble);\n            }\n        });\n        \n        // Log disconnected counts\n        disconnected.forEach((bubbles, zone) => {\n            if (bubbles.length > 0) {\n                // console.log(`${bubbles.length} disconnected bubbles in ${zone} zone`);\n            }\n        });\n        \n        return disconnected;\n    }\n    \n    /**\n     * Flood fill to find connected bubbles\n     */\n    private floodFill(bubble: Bubble, visited: Set<Bubble>, connected: Set<Bubble>): void {\n        if (visited.has(bubble)) return;\n        visited.add(bubble);\n        connected.add(bubble);\n        \n        const hexPos = bubble.getGridPosition();\n        if (!hexPos) return;\n        \n        // Get neighbors\n        const neighbors = this.bubbleGrid.getNeighbors(hexPos);\n        \n        // Check each neighbor\n        neighbors.forEach(neighborHex => {\n            const neighborBubble = this.getBubbleAtPosition(neighborHex);\n            if (neighborBubble && !visited.has(neighborBubble)) {\n                this.floodFill(neighborBubble, visited, connected);\n            }\n        });\n    }\n    \n    /**\n     * Get bubble at specific hex position\n     */\n    private getBubbleAtPosition(hexPos: IHexPosition): Bubble | null {\n        return this.gridBubbles.find(bubble => {\n            const pos = bubble.getGridPosition();\n            return pos && pos.q === hexPos.q && pos.r === hexPos.r;\n        }) || null;\n    }\n    \n    /**\n     * Determine which zone a bubble is in based on Y position\n     */\n    private getZoneForBubble(bubble: Bubble): ArenaZone {\n        const screenHeight = this.scene.cameras.main.height;\n        const objectiveTop = screenHeight * 0.4; // 40% from top\n        const objectiveBottom = screenHeight * 0.6; // 60% from top\n        \n        if (bubble.y < objectiveTop) {\n            return ArenaZone.OPPONENT;\n        } else if (bubble.y > objectiveBottom) {\n            return ArenaZone.PLAYER;\n        } else {\n            return ArenaZone.OBJECTIVE;\n        }\n    }\n    \n    /**\n     * Apply bidirectional gravity to disconnected bubbles\n     */\n    public applyBidirectionalGravity(bubbles: Bubble[]): void {\n        const centerY = this.scene.cameras.main.centerY;\n        \n        // Group bubbles by their fall direction\n        const fallingUp: Bubble[] = [];\n        const fallingDown: Bubble[] = [];\n        \n        bubbles.forEach(bubble => {\n            if (bubble.y < centerY) {\n                // Bubbles above center fall up\n                fallingUp.push(bubble);\n            } else {\n                // Bubbles below center fall down\n                fallingDown.push(bubble);\n            }\n        });\n        \n        // Animate each group with appropriate direction\n        if (fallingUp.length > 0) {\n            // console.log(`${fallingUp.length} bubbles falling UP (above center)`);\n            this.animateFallingBubbles(fallingUp, 'up');\n        }\n        \n        if (fallingDown.length > 0) {\n            // console.log(`${fallingDown.length} bubbles falling DOWN (below center)`);\n            this.animateFallingBubbles(fallingDown, 'down');\n        }\n    }\n    \n    /**\n     * Animate bubbles falling in specified direction\n     */\n    private animateFallingBubbles(bubbles: Bubble[], direction: 'up' | 'down'): void {\n        const outOfBounds = direction === 'down' \n            ? this.scene.cameras.main.height + 100\n            : -100;\n        \n        // Sort bubbles by distance from center for cascade effect\n        const centerX = this.scene.cameras.main.centerX;\n        bubbles.sort((a, b) => {\n            const distA = Math.abs(a.x - centerX);\n            const distB = Math.abs(b.x - centerX);\n            return distA - distB;\n        });\n        \n        bubbles.forEach((bubble, index) => {\n            // Remove from grid immediately\n            this.removeGridBubble(bubble);\n            const oldPos = bubble.getGridPosition();\n            if (oldPos) {\n                const key = this.hexToKey(oldPos);\n                this.gridPositions.delete(key);\n            }\n            bubble.setGridPosition(null);\n            \n            // Add slight random horizontal movement for natural falling\n            const horizontalDrift = Phaser.Math.Between(-30, 30);\n            const rotationSpeed = Phaser.Math.Between(-Math.PI * 2, Math.PI * 2);\n            \n            // Flash before falling\n            bubble.setTint(0xFFFFFF);\n            this.scene.time.delayedCall(100, () => {\n                bubble.clearTint();\n            });\n            \n            // Animate falling with physics-like acceleration\n            this.scene.tweens.add({\n                targets: bubble,\n                y: outOfBounds,\n                x: bubble.x + horizontalDrift,\n                rotation: rotationSpeed,\n                scale: 0.8,\n                alpha: 0.3,\n                duration: 800 + index * 20, // Vary duration for natural effect\n                ease: 'Quad.easeIn',\n                delay: index * 30, // Stagger the falls for cascade effect\n                onComplete: () => {\n                    // Award points based on position\n                    // Bubbles falling from opponent side (up direction) give more points\n                    const points = direction === 'up' ? 15 : 10;\n                    \n                    this.scene.events.emit('bubble-dropped', { \n                        direction: direction, \n                        points: points,\n                        color: bubble.getColor()\n                    });\n                    \n                    // Return to pool\n                    bubble.returnToPool();\n                }\n            });\n        });\n        \n        // Add screen shake for large groups\n        if (bubbles.length >= 5) {\n            this.scene.cameras.main.shake(150, 0.002);\n        }\n    }\n    \n    /**\n     * Get all grid bubbles\n     */\n    public getGridBubbles(): Bubble[] {\n        return this.gridBubbles;\n    }\n    \n    /**\n     * Clear all grid bubbles\n     */\n    public clearGrid(): void {\n        this.gridBubbles = [];\n    }\n    \n    /**\n     * Debug: Visualize connections\n     */\n    public debugDrawConnections(graphics: Phaser.GameObjects.Graphics): void {\n        graphics.lineStyle(1, 0x00ff00, 0.5);\n        \n        this.gridBubbles.forEach(bubble => {\n            const hexPos = bubble.getGridPosition();\n            if (!hexPos) return;\n            \n            const neighbors = this.bubbleGrid.getNeighbors(hexPos);\n            neighbors.forEach(neighborHex => {\n                const neighborBubble = this.getBubbleAtPosition(neighborHex);\n                if (neighborBubble) {\n                    graphics.lineBetween(\n                        bubble.x, bubble.y,\n                        neighborBubble.x, neighborBubble.y\n                    );\n                }\n            });\n        });\n    }\n    \n    /**\n     * Fast O(1) check if a grid position has a bubble\n     * Used for performance optimization in updateObjectiveShield\n     */\n    public hasGridPosition(gridKey: string): boolean {\n        return this.gridPositions.has(gridKey);\n    }\n}","import { Scene } from 'phaser';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { BubbleGrid } from './BubbleGrid';\nimport { GridAttachmentSystem } from './GridAttachmentSystem';\nimport { BubbleColor, IHexPosition, ArenaZone } from '@/types/ArenaTypes';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { MysteryBubble } from '@/gameObjects/MysteryBubble';\n\nexport class MatchDetectionSystem {\n    private scene: Scene;\n    private bubbleGrid: BubbleGrid;\n    private gridAttachmentSystem: GridAttachmentSystem;\n    \n    // Match settings\n    private minimumMatchSize: number = 3;\n    private isProcessing: boolean = false;\n    \n    // Scoring\n    private totalScore: number = 0;\n    private combo: number = 0;\n    private lastMatchTime: number = 0;\n    private comboTimeout: number = 2000; // 2 seconds\n    \n    constructor(\n        scene: Scene,\n        bubbleGrid: BubbleGrid,\n        gridAttachmentSystem: GridAttachmentSystem\n    ) {\n        this.scene = scene;\n        this.bubbleGrid = bubbleGrid;\n        this.gridAttachmentSystem = gridAttachmentSystem;\n    }\n    \n    /**\n     * Check for matches after a bubble attaches\n     */\n    public async checkForMatches(attachedBubble: Bubble): Promise<void> {\n        if (this.isProcessing || !attachedBubble.visible) return;\n        \n        const color = attachedBubble.getColor();\n        if (color === undefined || color === null) {\n            // Only log critical errors\n            console.error('Bubble has no color, skipping match detection');\n            return;\n        }\n        \n        this.isProcessing = true;\n        \n        // Find connected bubbles of same color\n        const matches = this.findColorMatches(attachedBubble, color);\n        \n        if (matches.size >= this.minimumMatchSize) {\n            \n            // Calculate center position BEFORE any animations or removal\n            // Use world positions to account for any container transformations\n            let avgX = 0, avgY = 0;\n            let bubbleColor: BubbleColor | undefined;\n            matches.forEach(bubble => {\n                // Get world position of each bubble\n                const worldPos = bubble.getWorldTransformMatrix();\n                avgX += worldPos.tx;\n                avgY += worldPos.ty;\n                if (!bubbleColor) {\n                    bubbleColor = bubble.getColor();\n                }\n            });\n            avgX /= matches.size;\n            avgY /= matches.size;\n            \n            // Determine if this was an AI or player match based on the attached bubble\n            const isAIMatch = attachedBubble.getShooter() === 'ai';\n            \n            // Highlight matches briefly before removing\n            this.highlightMatches(Array.from(matches));\n            \n            // Wait a moment to show the highlight\n            await new Promise(resolve => setTimeout(resolve, 200));\n            \n            // Update combo\n            this.updateCombo();\n            \n            // Calculate score\n            const score = this.calculateScore(matches);\n            this.totalScore += score;\n            \n            // Emit match found event for sound system\n            this.scene.events.emit('match-found', {\n                matchSize: matches.size,\n                combo: this.combo,\n                isAI: isAIMatch,\n                x: avgX,\n                y: avgY,\n                bubbleColor: bubbleColor\n            });\n            \n            // Emit score update event BEFORE removal animations\n            this.scene.events.emit('score-update', {\n                score: this.totalScore,\n                delta: score,\n                combo: this.combo,\n                isAI: isAIMatch,\n                matchSize: matches.size,\n                x: avgX,\n                y: avgY,\n                bubbleColor: bubbleColor\n            });\n            \n            // Emit bubble explosion event for visual effects\n            // Create splatters at each bubble position for more realistic effect\n            if (bubbleColor !== undefined) {\n                // Collect all bubble positions\n                const positions: { x: number, y: number }[] = [];\n                matches.forEach(bubble => {\n                    const worldPos = bubble.getWorldTransformMatrix();\n                    positions.push({ x: worldPos.tx, y: worldPos.ty });\n                });\n                \n                // Emit event with all positions\n                this.scene.events.emit('bubble-exploded', {\n                    x: avgX,  // Keep center for compatibility\n                    y: avgY,\n                    positions: positions,  // All individual positions\n                    color: bubbleColor,\n                    comboMultiplier: matches.size\n                });\n                \n                // Emit audio event for pleasant pop sounds\n                this.scene.events.emit('bubbles-popped', {\n                    color: bubbleColor,\n                    count: matches.size\n                });\n            }\n            \n            // Remove matched bubbles (Mystery bubbles will activate their power-ups when destroyed)\n            // Pass !isAIMatch to indicate if it was a player shot\n            await this.removeMatches(Array.from(matches), !isAIMatch);\n            \n            // Check for floating bubbles after removal\n            this.checkFloatingBubbles();\n            \n            // Emit match event\n            this.scene.events.emit('match-completed', {\n                count: matches.size,\n                score: score,\n                totalScore: this.totalScore,\n                combo: this.combo\n            });\n        }\n        \n        this.isProcessing = false;\n    }\n    \n    /**\n     * Find all connected bubbles of the same color (Mystery bubbles match any color)\n     */\n    private findColorMatches(startBubble: Bubble, targetColor: BubbleColor): Set<Bubble> {\n        const matches = new Set<Bubble>();\n        const visited = new Set<Bubble>();\n        const queue: Bubble[] = [startBubble];\n        \n        while (queue.length > 0) {\n            const current = queue.shift()!;\n            \n            // Skip if already visited\n            if (visited.has(current)) continue;\n            visited.add(current);\n            \n            // Check if bubble color matches target color\n            const colorMatches = current.getColor() === targetColor;\n            \n            // Skip if wrong color or not visible\n            // Mystery Bubbles must ALSO match the color, they're not wildcards\n            if (!current.visible || !colorMatches) {\n                continue;\n            }\n            \n            // Add to matches\n            matches.add(current);\n            \n            // Get neighbors\n            const neighbors = this.getNeighborBubbles(current);\n            for (const neighbor of neighbors) {\n                if (!visited.has(neighbor)) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        return matches;\n    }\n    \n    /**\n     * Get neighboring bubbles\n     */\n    private getNeighborBubbles(bubble: Bubble): Bubble[] {\n        const neighbors: Bubble[] = [];\n        const hexPos = bubble.getGridPosition();\n        if (!hexPos) return neighbors;\n        \n        // Get hex neighbors\n        const hexNeighbors = this.bubbleGrid.getNeighbors(hexPos);\n        const gridBubbles = this.gridAttachmentSystem.getGridBubbles();\n        \n        for (const neighborHex of hexNeighbors) {\n            const neighborBubble = gridBubbles.find(b => {\n                const pos = b.getGridPosition();\n                return pos && \n                       pos.q === neighborHex.q && \n                       pos.r === neighborHex.r &&\n                       b.visible;\n            });\n            \n            if (neighborBubble) {\n                neighbors.push(neighborBubble);\n            }\n        }\n        \n        return neighbors;\n    }\n    \n    /**\n     * Highlight bubbles that are about to be matched\n     */\n    private highlightMatches(bubbles: Bubble[]): void {\n        bubbles.forEach(bubble => {\n            // Kill any existing tweens on this bubble to prevent conflicts\n            this.scene.tweens.killTweensOf(bubble);\n            \n            // Create a pulsing effect\n            this.scene.tweens.add({\n                targets: bubble,\n                scaleX: 1.2,\n                scaleY: 1.2,\n                duration: 100,\n                yoyo: true,\n                repeat: 1,\n                ease: 'Sine.easeInOut'\n            });\n            \n            // Add a glow effect\n            bubble.setTint(0xFFFFFF);\n        });\n    }\n    \n    /**\n     * Remove matched bubbles with animation\n     */\n    private async removeMatches(bubbles: Bubble[], isPlayerShot: boolean): Promise<void> {\n        // First, check for and handle Mystery Bubbles BEFORE removal\n        bubbles.forEach(bubble => {\n            if (bubble instanceof MysteryBubble) {\n                // console.log('Found MysteryBubble in matches, collecting power-up for', isPlayerShot ? 'player' : 'opponent');\n                (bubble as MysteryBubble).collectPowerUp(isPlayerShot);\n            }\n        });\n        \n        // Sort bubbles by distance from center for staggered animation\n        const centerX = bubbles.reduce((sum, b) => sum + b.x, 0) / bubbles.length;\n        const centerY = bubbles.reduce((sum, b) => sum + b.y, 0) / bubbles.length;\n        \n        bubbles.sort((a, b) => {\n            const distA = Phaser.Math.Distance.Between(a.x, a.y, centerX, centerY);\n            const distB = Phaser.Math.Distance.Between(b.x, b.y, centerX, centerY);\n            return distA - distB;\n        });\n        \n        // Score popup is handled by ComboManager now\n        \n        // Determine animation style based on match size\n        const matchSize = bubbles.length;\n        const animationStyle = this.getPopAnimationStyle(matchSize);\n        \n        // Animate removal\n        const promises: Promise<void>[] = [];\n        \n        bubbles.forEach((bubble, index) => {\n            const promise = new Promise<void>((resolve) => {\n                // Kill any existing tweens to prevent conflicts\n                this.scene.tweens.killTweensOf(bubble);\n                \n                // Clear tint and ensure bubble is in correct state\n                bubble.clearTint();\n                bubble.setVisible(true);\n                bubble.setAlpha(1);\n                bubble.setScale(1);\n                \n                // Particle effect only for 4+ matches\n                if (matchSize >= 4) {\n                    const bubbleColor = bubble.getColor();\n                    if (bubbleColor !== undefined && bubbleColor !== null) {\n                        this.createParticles(bubble.x, bubble.y, bubbleColor);\n                    }\n                }\n                \n                // Different animations based on combo size\n                if (matchSize === 3) {\n                    // Simple fade for 3-match\n                    this.scene.tweens.add({\n                        targets: bubble,\n                        scale: 0.8,\n                        alpha: 0,\n                        duration: 150,\n                        ease: 'Power2',\n                        delay: index * 15,\n                        onComplete: () => {\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                } else if (matchSize === 4) {\n                    // Gentle pop for 4-match\n                    this.scene.tweens.add({\n                        targets: bubble,\n                        scale: 1.2,\n                        alpha: 0,\n                        duration: 200,\n                        ease: 'Back.easeOut',\n                        delay: index * 20,\n                        onComplete: () => {\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                } else if (matchSize === 5) {\n                    // Bouncy pop for 5-match\n                    this.scene.tweens.add({\n                        targets: bubble,\n                        scale: { from: 1, to: 1.4 },\n                        alpha: 0,\n                        y: bubble.y - 10,\n                        duration: 250,\n                        ease: 'Bounce.easeOut',\n                        delay: index * 25,\n                        onComplete: () => {\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                } else if (matchSize === 6) {\n                    // Spiral out for 6-match\n                    const angle = (index / bubbles.length) * Math.PI * 2;\n                    this.scene.tweens.add({\n                        targets: bubble,\n                        x: bubble.x + Math.cos(angle) * 30,\n                        y: bubble.y + Math.sin(angle) * 30,\n                        scale: 1.5,\n                        alpha: 0,\n                        angle: 180,\n                        duration: 300,\n                        ease: 'Cubic.easeOut',\n                        delay: index * 20,\n                        onComplete: () => {\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                } else {\n                    // Explosive scatter for 7+ match\n                    const explosionAngle = Math.random() * Math.PI * 2;\n                    const explosionDistance = Phaser.Math.Between(50, 100);\n                    \n                    // Ensure bubble is properly set up before animation\n                    bubble.clearTint();\n                    bubble.setVisible(true);\n                    bubble.setAlpha(1);\n                    \n                    this.scene.tweens.add({\n                        targets: bubble,\n                        x: bubble.x + Math.cos(explosionAngle) * explosionDistance,\n                        y: bubble.y + Math.sin(explosionAngle) * explosionDistance,\n                        scale: 0,  // Simplified to just scale to 0\n                        alpha: 0,\n                        angle: 360,\n                        duration: 400,\n                        ease: 'Power3.easeOut',\n                        delay: index * 10,\n                        onComplete: () => {\n                            // Make sure bubble is properly cleaned up\n                            bubble.setVisible(false);\n                            bubble.clearTint();\n                            bubble.setScale(1);\n                            bubble.setAlpha(1);\n                            bubble.setAngle(0);\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                }\n            });\n            promises.push(promise);\n        });\n        \n        // Screen shake only for large matches\n        if (bubbles.length >= 6) {\n            this.scene.cameras.main.shake(150, 0.002);\n        }\n        \n        await Promise.all(promises);\n    }\n    \n    private getPopAnimationStyle(matchSize: number): string {\n        if (matchSize === 3) return 'fade';\n        if (matchSize === 4) return 'pop';\n        if (matchSize === 5) return 'bounce';\n        if (matchSize === 6) return 'spiral';\n        return 'explode';\n    }\n    \n    /**\n     * Check for floating bubbles after removal\n     */\n    private checkFloatingBubbles(): void {\n        const disconnected = this.gridAttachmentSystem.findDisconnectedGroups();\n        \n        // Collect all disconnected bubbles\n        const allDisconnected: Bubble[] = [];\n        disconnected.forEach((bubbles) => {\n            allDisconnected.push(...bubbles);\n        });\n        \n        if (allDisconnected.length > 0) {\n            // Calculate center position for bonus display\n            let avgX = 0, avgY = 0;\n            allDisconnected.forEach(bubble => {\n                avgX += bubble.x;\n                avgY += bubble.y;\n            });\n            avgX /= allDisconnected.length;\n            avgY /= allDisconnected.length;\n            \n            // Count bubbles by direction\n            const centerY = this.scene.cameras.main.centerY;\n            const upwardBubbles = allDisconnected.filter(b => b.y < centerY).length;\n            const downwardBubbles = allDisconnected.filter(b => b.y >= centerY).length;\n            \n            // Calculate bonus score (10 points per orphan bubble)\n            const bonusPerBubble = 10;\n            const totalOrphanBonus = allDisconnected.length * bonusPerBubble;\n            \n            if (totalOrphanBonus > 0) {\n                this.totalScore += totalOrphanBonus;\n                \n                // DISABLED: Visual feedback now handled by UnifiedFeedbackSystem\n                // this.showOrphanBonus(avgX, avgY, allDisconnected.length, totalOrphanBonus);\n                \n                // Emit floating bubbles drop event for sound system\n                this.scene.events.emit('floating-bubbles-drop', {\n                    count: allDisconnected.length,\n                    x: avgX,\n                    y: avgY\n                });\n                \n                // Emit score update for orphan bonus with adjusted Y position\n                // Determine shooter based on which side had more bubbles\n                const isAIBonus = upwardBubbles > downwardBubbles;\n                \n                this.scene.events.emit('score-update', {\n                    score: this.totalScore,\n                    delta: totalOrphanBonus,\n                    combo: 0,\n                    isAI: isAIBonus,\n                    matchSize: 0, // 0 indicates orphan bonus\n                    x: avgX,\n                    y: avgY + 40, // Offset down to avoid overlap with match score\n                    isOrphanBonus: true,\n                    metadata: {\n                        dropCount: allDisconnected.length\n                    }\n                });\n            }\n            \n            // Apply bidirectional gravity\n            this.gridAttachmentSystem.applyBidirectionalGravity(allDisconnected);\n        }\n    }\n    \n    /**\n     * Show orphan bonus visual feedback\n     */\n    private showOrphanBonus(x: number, y: number, count: number, bonus: number): void {\n        // Offset y position to avoid overlapping with combo displays\n        const adjustedY = y + 30; // Move down to avoid overlap\n        \n        // Create container for bonus display\n        const bonusContainer = this.scene.add.container(x, adjustedY);\n        bonusContainer.setDepth(Z_LAYERS.UI + 15); // Higher depth to ensure visibility\n        \n        // Create comic-style drop bonus text\n        const dropText = this.scene.add.text(0, -8, 'DROP BONUS', {\n            fontSize: '18px',\n            color: '#00FFFF',\n            fontFamily: 'Impact, Arial Black', // Comic style\n            fontStyle: 'bold',\n            stroke: '#000000',\n            strokeThickness: 3\n        });\n        dropText.setOrigin(0.5);\n        dropText.setShadow(1, 1, '#0066CC', 2, true, true);\n        \n        // Create points text with comic style\n        const pointsText = this.scene.add.text(0, 12, `+${bonus}`, {\n            fontSize: '22px',\n            color: '#FFD700',\n            fontFamily: 'Impact, Arial Black', // Comic style\n            fontStyle: 'bold',\n            stroke: '#000000',\n            strokeThickness: 3\n        });\n        pointsText.setOrigin(0.5);\n        \n        bonusContainer.add([dropText, pointsText]);\n        bonusContainer.setScale(0);\n        \n        // Elegant entrance animation\n        this.scene.tweens.add({\n            targets: bonusContainer,\n            scale: { from: 0, to: 1.1 },\n            duration: 250,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                // Subtle settle\n                this.scene.tweens.add({\n                    targets: bonusContainer,\n                    scale: 1,\n                    duration: 100,\n                    ease: 'Sine.easeInOut'\n                });\n            }\n        });\n        \n        // Float down instead of up to differentiate from combo text\n        this.scene.time.delayedCall(700, () => {\n            this.scene.tweens.add({\n                targets: bonusContainer,\n                y: adjustedY + 40, // Float down\n                alpha: 0,\n                scale: 0.9,\n                duration: 600,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    bonusContainer.destroy(true);\n                }\n            });\n        });\n        \n        // Create sparkle particles at adjusted position\n        this.createDropParticles(x, adjustedY, count);\n    }\n    \n    private createDropParticles(x: number, y: number, count: number): void {\n        const particleCount = Math.min(count * 3, 15);\n        \n        for (let i = 0; i < particleCount; i++) {\n            const particle = this.scene.add.circle(\n                x + Phaser.Math.Between(-20, 20),\n                y + Phaser.Math.Between(-20, 20),\n                3,\n                0x00FFFF,\n                0.8\n            );\n            particle.setDepth(Z_LAYERS.UI + 5);\n            \n            // Sparkle animation\n            this.scene.tweens.add({\n                targets: particle,\n                y: particle.y - Phaser.Math.Between(30, 60),\n                alpha: 0,\n                scale: 0,\n                duration: Phaser.Math.Between(500, 800),\n                delay: i * 20,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n    }\n    \n    /**\n     * Calculate score for matches\n     */\n    private calculateScore(matches: Set<Bubble>): number {\n        let score = 0;\n        \n        // Base score (10 per bubble)\n        score = matches.size * 10;\n        \n        // Size bonus\n        if (matches.size > 3) {\n            score += (matches.size - 3) * 5;\n        }\n        \n        // Combo multiplier\n        if (this.combo > 0) {\n            score = Math.floor(score * (1 + this.combo * 0.2));\n        }\n        \n        // Zone bonus\n        let zoneMultiplier = 1;\n        matches.forEach(bubble => {\n            const zone = this.getZone(bubble);\n            if (zone === ArenaZone.OPPONENT) {\n                zoneMultiplier = Math.max(zoneMultiplier, 2);\n            } else if (zone === ArenaZone.OBJECTIVE) {\n                zoneMultiplier = Math.max(zoneMultiplier, 1.5);\n            }\n        });\n        \n        score = Math.floor(score * zoneMultiplier);\n        \n        return score;\n    }\n    \n    /**\n     * Update combo counter\n     */\n    private updateCombo(): void {\n        const now = Date.now();\n        \n        if (now - this.lastMatchTime < this.comboTimeout) {\n            this.combo++;\n        } else {\n            this.combo = 0;\n        }\n        \n        this.lastMatchTime = now;\n    }\n    \n    /**\n     * Get zone for bubble\n     */\n    private getZone(bubble: Bubble): ArenaZone {\n        const screenHeight = this.scene.cameras.main.height;\n        const objectiveTop = screenHeight * 0.4;\n        const objectiveBottom = screenHeight * 0.6;\n        \n        if (bubble.y < objectiveTop) {\n            return ArenaZone.OPPONENT;\n        } else if (bubble.y > objectiveBottom) {\n            return ArenaZone.PLAYER;\n        } else {\n            return ArenaZone.OBJECTIVE;\n        }\n    }\n    \n    /**\n     * Create particle effects\n     */\n    private createParticles(x: number, y: number, color: BubbleColor): void {\n        const particleCount = 6;\n        \n        for (let i = 0; i < particleCount; i++) {\n            const particle = this.scene.add.circle(\n                x, y, 4,\n                color,\n                1\n            );\n            particle.setDepth(Z_LAYERS.BUBBLES);\n            \n            const angle = (i / particleCount) * Math.PI * 2;\n            const speed = Phaser.Math.Between(50, 150);\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: x + Math.cos(angle) * speed,\n                y: y + Math.sin(angle) * speed,\n                alpha: 0,\n                scale: 0,\n                duration: 400,\n                ease: 'Power2',\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n    }\n    \n    // Score popup removed - handled by ComboManager\n    \n    /**\n     * Get current score\n     */\n    public getScore(): number {\n        return this.totalScore;\n    }\n    \n    /**\n     * Reset system\n     */\n    public reset(): void {\n        this.totalScore = 0;\n        this.combo = 0;\n        this.lastMatchTime = 0;\n        this.isProcessing = false;\n    }\n}","import Phaser from 'phaser';\nimport { Launcher } from '@/gameObjects/Launcher';\n// BubbleQueue removed - integrated into Launcher\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { BubbleColor } from '@/types/ArenaTypes';\nimport { BUBBLE_CONFIG, ARENA_CONFIG, Z_LAYERS } from '@/config/ArenaConfig';\n\nexport enum AIDifficulty {\n    EASY = 'EASY',\n    MEDIUM = 'MEDIUM',\n    HARD = 'HARD'\n}\n\ninterface IShootTarget {\n    angle: number;\n    useWallBounce: 'none' | 'left' | 'right';\n    targetBubble?: Bubble;\n    score: number;\n    reasoning: string;\n    potentialFalls?: number; // Number of bubbles that would fall\n    totalValue?: number; // Total value including falls\n}\n\nexport class AIOpponentSystem {\n    private scene: Phaser.Scene;\n    private launcher: Launcher;\n    private currentBubble: Bubble | null = null; // Track loaded bubble\n    private nextBubbleColors: BubbleColor[] = []; // Store next 2-3 colors for launcher rings\n    private availableColors: BubbleColor[] = [\n        BubbleColor.RED,\n        BubbleColor.BLUE, \n        BubbleColor.GREEN,\n        BubbleColor.YELLOW,\n        BubbleColor.PURPLE\n    ];\n    private isActive: boolean = false;\n    private shootTimer?: Phaser.Time.TimerEvent;\n    private difficulty: AIDifficulty = AIDifficulty.HARD;\n    private isOnCooldown: boolean = false;\n    private readonly COOLDOWN_TIME: number = 1000; // Same as player - 1 second\n    private readonly SHOOT_SPEED: number = 600; // Same as player\n    \n    constructor(scene: Phaser.Scene, launcher: Launcher) {\n        this.scene = scene;\n        this.launcher = launcher;\n        \n        // Initialize next bubble colors for integrated queue\n        this.generateNextBubbleColors();\n        \n        // Listen for shooting complete to know when we can shoot again\n        this.scene.events.on('shooting-complete', this.onShootingComplete, this);\n    }\n    \n    public setDifficulty(difficulty: AIDifficulty): void {\n        this.difficulty = difficulty;\n    }\n    \n    public start(): void {\n        this.isActive = true;\n        // console.log('AI: Starting with difficulty', this.difficulty);\n        \n        // Set initial downward angle for opponent\n        this.launcher.setAimAngle(90); // 90 degrees = straight down for opponent\n        \n        // Load first bubble\n        this.loadNextBubble();\n        // Start thinking about first shot\n        this.scheduleNextShot();\n    }\n    \n    public stop(): void {\n        this.isActive = false;\n        if (this.shootTimer) {\n            this.shootTimer.destroy();\n            this.shootTimer = undefined;\n        }\n        \n        // Clean up current bubble when stopping\n        if (this.currentBubble) {\n            this.currentBubble.destroy();\n            this.currentBubble = null;\n        }\n    }\n    \n    /**\n     * Generates next bubble colors for the integrated queue system\n     */\n    private generateNextBubbleColors(): void {\n        // Generate 3 colors: current + next 2\n        this.nextBubbleColors = [];\n        for (let i = 0; i < 3; i++) {\n            const randomColor = this.availableColors[Math.floor(Math.random() * this.availableColors.length)];\n            this.nextBubbleColors.push(randomColor);\n        }\n        \n        // console.log('AI: Generated next bubble colors:', this.nextBubbleColors);\n    }\n    \n    /**\n     * Loads next bubble using integrated queue system\n     */\n    private loadNextBubble(): void {\n        // Get current color (first in queue)\n        const currentColor = this.nextBubbleColors[0] || BubbleColor.BLUE;\n        \n        // console.log(`AI loadNextBubble: Loading bubble color ${currentColor} hex=0x${currentColor.toString(16)}`);\n        \n        // Load bubble into launcher\n        this.launcher.loadBubble(currentColor);\n        \n        // Get the loaded bubble from the launcher\n        this.currentBubble = this.launcher.getLoadedBubble();\n        \n        // Shift queue and add new color\n        this.nextBubbleColors.shift(); // Remove current color\n        const newColor = this.availableColors[Math.floor(Math.random() * this.availableColors.length)];\n        this.nextBubbleColors.push(newColor); // Add new color at end\n        \n        // Update launcher queue rings with new colors\n        this.launcher.updateQueueColors(this.nextBubbleColors);\n        \n        // console.log('AI: Updated queue colors:', this.nextBubbleColors);\n    }\n    \n    private scheduleNextShot(): void {\n        if (!this.isActive || this.isOnCooldown) return;\n        \n        // Decision time based on difficulty (thinking time, not shooting speed)\n        let thinkingTime: number;\n        switch (this.difficulty) {\n            case AIDifficulty.EASY:\n                thinkingTime = 3000 + Math.random() * 2000; // 3-5 seconds to think\n                break;\n            case AIDifficulty.MEDIUM:\n                thinkingTime = 2000 + Math.random() * 1000; // 2-3 seconds to think\n                break;\n            case AIDifficulty.HARD:\n                thinkingTime = 1000 + Math.random() * 500; // 1-1.5 seconds (still quick but more thoughtful)\n                break;\n        }\n        \n        this.shootTimer = this.scene.time.delayedCall(thinkingTime, () => {\n            if (this.isActive && !this.isOnCooldown) {\n                this.performShot();\n            }\n        });\n    }\n    \n    private performShot(): void {\n        if (this.isOnCooldown || !this.currentBubble) return;\n        \n        const color = this.currentBubble.getColor();\n        const bubbleId = this.currentBubble.getData('bubbleId');\n        \n        // Find best shot based on difficulty\n        const target = this.calculateBestShot(color);\n        \n        // console.log(`🎯 AI shooting: ID=${bubbleId} ${this.getColorName(color)} at ${target.angle.toFixed(1)}° (${target.reasoning}) score=${target.score}`);\n        \n        // Update launcher aim\n        this.launcher.setAimAngle(target.angle);\n        \n        // Store the bubble for shooting (don't destroy it yet!)\n        const bubbleToShoot = this.currentBubble;\n        this.currentBubble = null;\n        \n        // Remove bubble from launcher before shooting\n        this.launcher.clearLoadedBubble();\n        \n        // Animate the launcher shooting with the bubble color\n        this.launcher.animateShoot(color);\n        \n        // Position bubble at launcher's world position for shooting\n        bubbleToShoot.setPosition(\n            this.launcher.x,\n            this.launcher.y + 30  // Opponent shoots from below\n        );\n        \n        // Reset bubble for shooting\n        bubbleToShoot.setScale(1);\n        bubbleToShoot.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        \n        // Emit shoot event WITH THE BUBBLE\n        this.scene.events.emit('ai-shoot', {\n            angle: target.angle,\n            color: color,\n            bubble: bubbleToShoot  // Pass the actual bubble!\n        });\n        \n        // Start cooldown (same as player!)\n        this.isOnCooldown = true;\n        this.scene.time.delayedCall(this.COOLDOWN_TIME, () => {\n            this.isOnCooldown = false;\n            // Load next bubble after cooldown\n            this.loadNextBubble();\n            // Schedule next shot after cooldown\n            this.scheduleNextShot();\n        });\n    }\n    \n    private calculateBestShot(color: BubbleColor): IShootTarget {\n        const gridBubbles = this.getGridBubbles();\n        const sameColorBubbles = gridBubbles.filter(b => b.getColor() === color);\n        \n        // BALANCED: Use all same color bubbles for smart AI\n        const closestBubbles = sameColorBubbles; // Use all for now to keep AI smart\n        \n        let bestTarget: IShootTarget | null = null;\n        \n        if (this.difficulty === AIDifficulty.HARD) {\n            // PRIORITY 1: Check if we can hit the objective directly!\n            const objectiveShot = this.checkObjectiveShot();\n            if (objectiveShot) {\n                // console.log(`  🎯 WINNING SHOT AVAILABLE! Direct path to objective!`);\n                return objectiveShot;\n            }\n            // PRIORITY 2: Smart targeting for strategic eliminations\n            let allTargets: IShootTarget[] = [];\n            \n            // First, check if we should prioritize clearing path to objective\n            const objectiveExposed = this.isObjectiveExposed();\n            if (!objectiveExposed) {\n                // console.log(`  🏯 Objective is protected - need to clear path`);\n                // Prioritize bubbles near the objective\n                const centerX = this.scene.cameras.main.centerX;\n                const centerY = this.scene.cameras.main.centerY;\n                \n                // Find bubbles blocking the objective\n                const blockingBubbles = sameColorBubbles.filter(b => {\n                    const dist = Phaser.Math.Distance.Between(b.x, b.y, centerX, centerY);\n                    return dist < BUBBLE_CONFIG.SIZE * 4; // Near objective\n                });\n                \n                if (blockingBubbles.length > 0) {\n                    // console.log(`  🎯 Found ${blockingBubbles.length} same-color bubbles near objective`);\n                    sameColorBubbles.unshift(...blockingBubbles); // Prioritize these\n                }\n            }\n            \n            if (closestBubbles.length > 0) {\n                // OPTIMIZED: Only analyze closest bubbles, not ALL\n                for (const targetBubble of closestBubbles) {\n                    // OPTIMIZED: Try 3 key angles for good coverage\n                    const angles = [\n                        this.calculateAngleToTarget(targetBubble.x, targetBubble.y),\n                        this.calculateAngleToTarget(targetBubble.x, targetBubble.y - BUBBLE_CONFIG.SIZE),\n                        this.calculateAngleToTarget(targetBubble.x - BUBBLE_CONFIG.SIZE * 0.5, targetBubble.y)\n                    ];\n                    \n                    for (const angle of angles) {\n                        if (angle >= 15 && angle <= 165) {\n                            const targetPos = { x: targetBubble.x, y: targetBubble.y };\n                            // OPTIMIZED: Better trajectory check\n                            if (this.isTrajectoryLikelyClear(angle, targetPos)) {\n                                // OPTIMIZED: Use smarter match counting\n                                const matchSize = this.countPotentialMatch(targetBubble, color);\n                                const potentialFalls = matchSize >= 3 ? 2 : 0; // Simple fall estimation\n                                \n                                // Check distance to objective for priority\n                                const centerX = this.scene.cameras.main.centerX;\n                                const centerY = this.scene.cameras.main.centerY;\n                                const distToObjective = Phaser.Math.Distance.Between(targetBubble.x, targetBubble.y, centerX, centerY);\n                                const nearObjective = distToObjective < BUBBLE_CONFIG.SIZE * 4;\n                                \n                                // Higher base score if near objective\n                                const baseScore = nearObjective ? 200 + (matchSize * 30) : 100 + (matchSize * 20);\n                                const fallBonus = potentialFalls * 300;\n                                \n                                allTargets.push({\n                                    angle: angle,\n                                    useWallBounce: 'none',\n                                    targetBubble: targetBubble,\n                                    score: baseScore + fallBonus,\n                                    totalValue: baseScore + fallBonus,\n                                    potentialFalls: potentialFalls,\n                                    reasoning: `match-${matchSize}${potentialFalls > 0 ? ` causing ${potentialFalls} falls` : ''}${nearObjective ? ' NEAR OBJECTIVE' : ''}`\n                                });\n                                \n                                // Found a good shot, but keep looking for better ones\n                                break; // But still check other bubbles\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // OPTIMIZED: Include basic wall bounce for smart plays\n            if (closestBubbles.length > 0 && closestBubbles.length < 5) {\n                // Only check wall bounces when there are few targets\n                const bounceTargets = this.findWallBounceTargets(color, closestBubbles.slice(0, 3));\n                allTargets.push(...bounceTargets);\n            }\n            \n            // Pick the best target from all analyzed\n            if (allTargets.length > 0) {\n                allTargets.sort((a, b) => (b.totalValue || b.score) - (a.totalValue || a.score));\n                bestTarget = allTargets[0];\n                // console.log(`  📊 Analyzed ${allTargets.length} possible shots`);\n                // console.log(`  🎯 Best shot: ${bestTarget.reasoning} (score: ${bestTarget.totalValue || bestTarget.score})`);\n            }\n        }\n        \n        // If no strategic shot found (or easier difficulty), find ANY valid shot\n        if (!bestTarget) {\n            bestTarget = this.findStraightShotTarget(sameColorBubbles);\n        }\n        \n        // If still no direct shot, try ANY bubble we can hit\n        if (!bestTarget) {\n            const allBubbles = this.getGridBubbles();\n            for (const bubble of allBubbles) {\n                const angle = this.calculateAngleToTarget(bubble.x, bubble.y);\n                if (angle >= 15 && angle <= 165) {\n                    const targetPos = { x: bubble.x, y: bubble.y };\n                    if (this.isTrajectoryLikelyClear(angle, targetPos)) {\n                        bestTarget = {\n                            angle: angle,\n                            useWallBounce: 'none',\n                            score: 10,\n                            reasoning: 'any available target'\n                        };\n                        break;\n                    }\n                }\n            }\n        }\n        \n        // Absolutely last resort - shoot at safe angles\n        if (!bestTarget) {\n            const safeAngles = [85, 90, 95, 75, 105];\n            const randomAngle = safeAngles[Math.floor(Math.random() * safeAngles.length)];\n            bestTarget = {\n                angle: randomAngle,\n                useWallBounce: 'none',\n                score: 0,\n                reasoning: 'safe fallback'\n            };\n        }\n        \n        return bestTarget;\n    }\n    \n    private findStraightShotTarget(sameColorBubbles: Bubble[]): IShootTarget | null {\n        // Find any bubble we can hit directly\n        const gridBubbles = this.getGridBubbles();\n        const allTargets = sameColorBubbles.length > 0 ? sameColorBubbles : gridBubbles;\n        \n        for (const bubble of allTargets) {\n            const angle = this.calculateAngleToTarget(bubble.x, bubble.y);\n            \n            // Check if angle is within launcher constraints\n            if (angle >= 15 && angle <= 165) {\n                const targetPos = { x: bubble.x, y: bubble.y };\n                if (this.isTrajectoryLikelyClear(angle, targetPos)) {\n                    return {\n                        angle: angle,\n                        useWallBounce: 'none',\n                        targetBubble: bubble,\n                        score: 50,\n                        reasoning: `direct shot to ${this.getColorName(bubble.getColor())}`\n                    };\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n    private findTargetsViaWallBounce(color: BubbleColor): IShootTarget[] {\n        const targets: IShootTarget[] = [];\n        const gridBubbles = this.getGridBubbles();\n        const sameColorBubbles = gridBubbles.filter(b => b.getColor() === color);\n        \n        // Check each same-color bubble for possible wall bounces\n        for (const bubble of sameColorBubbles) {\n            // Check possible attachment points around the bubble\n            const attachPoints = this.getAttachmentPoints(bubble);\n            \n            for (const point of attachPoints) {\n                // Check how many same-color bubbles would be connected from this point\n                const wouldConnect = this.countConnectedBubbles(point, color, sameColorBubbles);\n                \n                if (wouldConnect >= 2) { // Would make at least match-3\n                    const angle = this.calculateAngleToTarget(point.x, point.y);\n                    \n                    // Check if angle is valid and trajectory is clear\n                    if (angle >= 15 && angle <= 165 && this.isTrajectoryLikelyClear(angle, point)) {\n                        targets.push({\n                            angle: angle,\n                            useWallBounce: 'none',\n                            targetBubble: bubble,\n                            score: 100 + wouldConnect * 50,\n                            reasoning: `match-${wouldConnect + 1}`\n                        });\n                    }\n                }\n            }\n        }\n        \n        // Sort by score (best first)\n        return targets.sort((a, b) => b.score - a.score);\n    }\n    \n    private findWallBounceTargets(color: BubbleColor, sameColorBubbles: Bubble[]): IShootTarget[] {\n        const targets: IShootTarget[] = [];\n        const screenWidth = this.scene.cameras.main.width;\n        \n        for (const bubble of sameColorBubbles) {\n            // Left wall bounce\n            const mirrorX = -bubble.x; // Mirror across left wall\n            const leftBounceAngle = this.calculateAngleToTarget(mirrorX, bubble.y);\n            if (leftBounceAngle >= 100 && leftBounceAngle <= 165) { // Must aim left\n                targets.push({\n                    angle: leftBounceAngle,\n                    useWallBounce: 'left',\n                    targetBubble: bubble,\n                    score: 80,\n                    reasoning: 'left wall bounce'\n                });\n            }\n            \n            // Right wall bounce\n            const mirrorX2 = screenWidth + (screenWidth - bubble.x); // Mirror across right wall\n            const rightBounceAngle = this.calculateAngleToTarget(mirrorX2, bubble.y);\n            if (rightBounceAngle >= 15 && rightBounceAngle <= 80) { // Must aim right\n                targets.push({\n                    angle: rightBounceAngle,\n                    useWallBounce: 'right',\n                    targetBubble: bubble,\n                    score: 80,\n                    reasoning: 'right wall bounce'\n                });\n            }\n        }\n        \n        return targets.sort((a, b) => b.score - a.score);\n    }\n    \n    private findBestWallBounce(color: BubbleColor, targets: Bubble[]): IShootTarget | null {\n        for (const bubble of targets) {\n            // Try left wall bounce\n            const leftMirrorX = -bubble.x;\n            const leftAngle = this.calculateAngleToTarget(leftMirrorX, bubble.y);\n            if (leftAngle >= 100 && leftAngle <= 165) {\n                // Verify the bounce path is clear\n                const bouncePoint = { x: 0, y: this.launcher.y + Math.tan(leftAngle * Math.PI / 180) * this.launcher.x };\n                if (this.isTrajectoryLikelyClear(leftAngle, bouncePoint)) {\n                    return {\n                        angle: leftAngle,\n                        useWallBounce: 'left',\n                        score: 100,\n                        reasoning: `left bounce to ${this.getColorName(color)}`\n                    };\n                }\n            }\n            \n            // Try right wall bounce\n            const screenWidth = this.scene.cameras.main.width;\n            const rightMirrorX = screenWidth + (screenWidth - bubble.x);\n            const rightAngle = this.calculateAngleToTarget(rightMirrorX, bubble.y);\n            if (rightAngle >= 15 && rightAngle <= 80) {\n                // Verify the bounce path is clear\n                const bouncePoint = { x: screenWidth, y: this.launcher.y + Math.tan(rightAngle * Math.PI / 180) * (screenWidth - this.launcher.x) };\n                if (this.isTrajectoryLikelyClear(rightAngle, bouncePoint)) {\n                    return {\n                        angle: rightAngle,\n                        useWallBounce: 'right',\n                        score: 100,\n                        reasoning: `right bounce to ${this.getColorName(color)}`\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    \n    private getAttachmentPoints(bubble: Bubble): { x: number, y: number }[] {\n        const points: { x: number, y: number }[] = [];\n        const size = BUBBLE_CONFIG.SIZE;\n        \n        // Six hexagonal neighbor positions\n        const offsets = [\n            { x: size, y: 0 },        // Right\n            { x: -size, y: 0 },       // Left\n            { x: size/2, y: -size * 0.866 },   // Top-right\n            { x: -size/2, y: -size * 0.866 },  // Top-left\n            { x: size/2, y: size * 0.866 },    // Bottom-right\n            { x: -size/2, y: size * 0.866 }    // Bottom-left\n        ];\n        \n        for (const offset of offsets) {\n            points.push({\n                x: bubble.x + offset.x,\n                y: bubble.y + offset.y\n            });\n        }\n        \n        return points;\n    }\n    \n    private countConnectedBubbles(point: { x: number, y: number }, color: BubbleColor, bubbles: Bubble[]): number {\n        let count = 0;\n        const threshold = BUBBLE_CONFIG.SIZE * 1.1;\n        \n        for (const bubble of bubbles) {\n            const dist = Phaser.Math.Distance.Between(point.x, point.y, bubble.x, bubble.y);\n            if (dist < threshold) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    private calculateAngleToTarget(targetX: number, targetY: number): number {\n        const dx = targetX - this.launcher.x;\n        const dy = targetY - this.launcher.y;\n        \n        // Calculate angle in radians, then convert to degrees\n        // Using Math.atan2 which gives angle from -PI to PI\n        let angle = Math.atan2(dy, dx);\n        \n        // Convert to degrees\n        angle = angle * (180 / Math.PI);\n        \n        // Normalize to 0-360 range\n        if (angle < 0) angle += 360;\n        \n        return angle;\n    }\n    \n    private isTrajectoryClear(angle: number, target: { x: number, y: number }): boolean {\n        // OPTIMIZED: Reduced trajectory simulation\n        const radians = angle * (Math.PI / 180);\n        const velocity = {\n            x: Math.cos(radians) * this.SHOOT_SPEED,\n            y: Math.sin(radians) * this.SHOOT_SPEED\n        };\n        \n        let testX = this.launcher.x;\n        let testY = this.launcher.y;\n        const targetDist = Phaser.Math.Distance.Between(this.launcher.x, this.launcher.y, target.x, target.y);\n        \n        // OPTIMIZED: Check reasonable points (10 instead of 20)\n        const steps = 10;\n        const stepDist = targetDist / steps;\n        \n        for (let i = 1; i < steps; i++) {\n            const t = (stepDist * i) / this.SHOOT_SPEED;\n            testX = this.launcher.x + velocity.x * t;\n            testY = this.launcher.y + velocity.y * t;\n            \n            // Check if we hit any bubble before reaching target\n            const gridBubbles = this.getGridBubbles();\n            for (const bubble of gridBubbles) {\n                const dist = Phaser.Math.Distance.Between(testX, testY, bubble.x, bubble.y);\n                if (dist < BUBBLE_CONFIG.SIZE * 0.8) {\n                    // Check if this is our target\n                    const targetDist = Phaser.Math.Distance.Between(bubble.x, bubble.y, target.x, target.y);\n                    if (targetDist > BUBBLE_CONFIG.SIZE) {\n                        return false; // Hit something else first\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    private getGridBubbles(): Bubble[] {\n        // Get all bubbles from the grid\n        const bubbles: Bubble[] = [];\n        this.scene.children.list.forEach(child => {\n            if (child instanceof Bubble && child.visible && child.getGridPosition()) {\n                bubbles.push(child);\n            }\n        });\n        return bubbles;\n    }\n    \n    private getColorName(color: BubbleColor): string {\n        switch(color) {\n            case BubbleColor.RED: return 'RED';\n            case BubbleColor.BLUE: return 'BLUE';\n            case BubbleColor.GREEN: return 'GREEN';\n            case BubbleColor.YELLOW: return 'YELLOW';\n            case BubbleColor.PURPLE: return 'PURPLE';\n            case BubbleColor.MYSTERY: return 'MYSTERY';\n            default: return 'UNKNOWN';\n        }\n    }\n    \n    /**\n     * OPTIMIZED: Get strategic bubbles for analysis (not just closest)\n     */\n    private getClosestBubbles(bubbles: Bubble[], limit: number): Bubble[] {\n        // Sort by strategic value: closer to objective and easier to hit\n        const centerX = this.scene.cameras.main.centerX;\n        const centerY = this.scene.cameras.main.centerY;\n        \n        const sorted = bubbles.sort((a, b) => {\n            // Consider both distance to launcher AND distance to objective\n            const distA = Phaser.Math.Distance.Between(this.launcher.x, this.launcher.y, a.x, a.y);\n            const distB = Phaser.Math.Distance.Between(this.launcher.x, this.launcher.y, b.x, b.y);\n            \n            const objDistA = Phaser.Math.Distance.Between(a.x, a.y, centerX, centerY);\n            const objDistB = Phaser.Math.Distance.Between(b.x, b.y, centerX, centerY);\n            \n            // Prioritize bubbles near objective but also reachable\n            const scoreA = distA * 0.3 + objDistA * 0.7;\n            const scoreB = distB * 0.3 + objDistB * 0.7;\n            \n            return scoreA - scoreB;\n        });\n        return sorted.slice(0, limit);\n    }\n    \n    /**\n     * OPTIMIZED: Quick trajectory check without full simulation\n     */\n    private isTrajectoryLikelyClear(angle: number, target: { x: number, y: number }): boolean {\n        // More lenient path checking for better AI performance\n        const gridBubbles = this.getGridBubbles();\n        const radians = angle * Math.PI / 180;\n        const direction = {\n            x: Math.cos(radians),\n            y: Math.sin(radians)\n        };\n        \n        const targetDist = Phaser.Math.Distance.Between(this.launcher.x, this.launcher.y, target.x, target.y);\n        \n        // Check only a few key points along the path\n        for (let t = 0.3; t < 0.9; t += 0.3) {\n            const checkX = this.launcher.x + direction.x * targetDist * t;\n            const checkY = this.launcher.y + direction.y * targetDist * t;\n            \n            // Check if any bubble blocks this point\n            for (const bubble of gridBubbles) {\n                if (!bubble.visible) continue;\n                const dist = Phaser.Math.Distance.Between(checkX, checkY, bubble.x, bubble.y);\n                if (dist < BUBBLE_CONFIG.SIZE * 0.7) { // More lenient collision\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * OPTIMIZED: Quick match count without recursion\n     */\n    private quickCountPotentialMatch(targetBubble: Bubble, shootColor: BubbleColor): number {\n        // Just count immediate neighbors of same color\n        const neighbors = this.getNeighborBubbles(targetBubble);\n        let count = 1; // Include the shot itself\n        for (const neighbor of neighbors) {\n            if (neighbor.getColor() === shootColor) {\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    private countPotentialMatch(targetBubble: Bubble, shootColor: BubbleColor): number {\n        const visited = new Set<Bubble>();\n        const toCheck = [targetBubble];\n        let matchCount = 1; // Count the shot bubble itself\n        \n        // Find all connected same-color bubbles\n        while (toCheck.length > 0) {\n            const current = toCheck.pop()!;\n            if (visited.has(current)) continue;\n            visited.add(current);\n            \n            // Only count if same color as what we're shooting\n            if (current.getColor() === shootColor) {\n                if (current !== targetBubble) matchCount++;\n                \n                // Check neighbors\n                const neighbors = this.getNeighborBubbles(current);\n                for (const neighbor of neighbors) {\n                    if (!visited.has(neighbor) && neighbor.getColor() === shootColor) {\n                        toCheck.push(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return matchCount;\n    }\n    \n    private predictFallsFromShot(targetBubble: Bubble, shootColor: BubbleColor): number {\n        // Simulate what would happen if we made this match\n        const matchSize = this.countPotentialMatch(targetBubble, shootColor);\n        \n        if (matchSize < 3) return 0; // No match, no falls\n        \n        // This is a simplified prediction - in reality we'd need to simulate the full match and fall\n        // For now, estimate based on position\n        const neighbors = this.getNeighborBubbles(targetBubble);\n        let potentialFalls = 0;\n        \n        for (const neighbor of neighbors) {\n            if (neighbor.getColor() !== shootColor) {\n                // Check if this bubble would be disconnected\n                const supportingNeighbors = this.getNeighborBubbles(neighbor);\n                const wouldLoseSupport = supportingNeighbors.filter(n => \n                    n === targetBubble || n.getColor() === shootColor\n                ).length >= supportingNeighbors.length - 1;\n                \n                if (wouldLoseSupport) {\n                    potentialFalls++;\n                }\n            }\n        }\n        \n        return potentialFalls;\n    }\n    \n    private getNeighborBubbles(bubble: Bubble): Bubble[] {\n        const neighbors: Bubble[] = [];\n        const gridBubbles = this.getGridBubbles();\n        const threshold = BUBBLE_CONFIG.SIZE * 1.1;\n        \n        for (const other of gridBubbles) {\n            if (other === bubble) continue;\n            const dist = Phaser.Math.Distance.Between(bubble.x, bubble.y, other.x, other.y);\n            if (dist < threshold) {\n                neighbors.push(other);\n            }\n        }\n        \n        return neighbors;\n    }\n    \n    private checkObjectiveShot(): IShootTarget | null {\n        const centerX = this.scene.cameras.main.centerX;\n        const centerY = this.scene.cameras.main.centerY;\n        \n        // Calculate angle to objective\n        const angle = this.calculateAngleToTarget(centerX, centerY);\n        \n        // Check if angle is valid\n        if (angle >= 15 && angle <= 165) {\n            // Check if path is clear\n            const target = { x: centerX, y: centerY };\n            if (this.isTrajectoryLikelyClear(angle, target)) {\n                return {\n                    angle: angle,\n                    useWallBounce: 'none',\n                    score: 10000, // Winning shot!\n                    reasoning: '🏆 DIRECT HIT ON OBJECTIVE!'\n                };\n            }\n        }\n        \n        return null;\n    }\n    \n    private isObjectiveExposed(): boolean {\n        const centerX = this.scene.cameras.main.centerX;\n        const centerY = this.scene.cameras.main.centerY;\n        const gridBubbles = this.getGridBubbles();\n        \n        // Check if any bubbles are very close to objective\n        for (const bubble of gridBubbles) {\n            const dist = Phaser.Math.Distance.Between(bubble.x, bubble.y, centerX, centerY);\n            if (dist < BUBBLE_CONFIG.SIZE * 1.5) {\n                return false; // Objective is protected\n            }\n        }\n        \n        return true; // Objective is exposed\n    }\n    \n    private onShootingComplete = (): void => {\n        // AI doesn't need to do anything special here\n        // The cooldown is already handled in performShot\n    }\n    \n    public destroy(): void {\n        this.stop();\n        // Queue is now integrated into launcher - no separate cleanup needed\n        this.scene.events.off('shooting-complete', this.onShootingComplete);\n    }\n}","import Phaser from 'phaser';\nimport { HD_SCALE } from '@/config/GameConfig';\n\nexport interface ScoreDisplayConfig {\n    player: {\n        position: 'bottom-left';\n        color: number;\n    };\n    opponent: {\n        position: 'top-right';\n        color: number;\n    };\n}\n\nexport class EnhancedScoreDisplay extends Phaser.GameObjects.Container {\n    private playerScore: number = 0;\n    private opponentScore: number = 0;\n    private playerScoreText: Phaser.GameObjects.Text;\n    private opponentScoreText: Phaser.GameObjects.Text;\n    private playerNameText: Phaser.GameObjects.Text;\n    private opponentNameText: Phaser.GameObjects.Text;\n    \n    // Score animation tracking\n    private playerDisplayScore: number = 0;\n    private opponentDisplayScore: number = 0;\n    private playerTargetScore: number = 0;\n    private opponentTargetScore: number = 0;\n    \n    // Winning indicators\n    private playerLeadIndicator: Phaser.GameObjects.Text;\n    private opponentLeadIndicator: Phaser.GameObjects.Text;\n    private currentLeader: 'player' | 'opponent' | 'tie' = 'tie';\n    \n    // Container backgrounds\n    private playerContainer: Phaser.GameObjects.Container;\n    private opponentContainer: Phaser.GameObjects.Container;\n    \n    constructor(scene: Phaser.Scene) {\n        super(scene, 0, 0);\n        \n        // Create player score display (bottom-left)\n        this.createPlayerDisplay();\n        \n        // Create opponent score display (top-right)\n        this.createOpponentDisplay();\n        \n        this.setDepth(1000);\n        scene.add.existing(this);\n    }\n    \n    private createPlayerDisplay(): void {\n        // Clean positioning with HD scaling\n        const padding = 15 * HD_SCALE;\n        const bottomOffset = 30 * HD_SCALE;\n        const containerWidth = 70 * HD_SCALE;  // Reduced from 90\n        const containerHeight = 40 * HD_SCALE;  // Reduced from 50\n        \n        const x = padding;\n        const y = this.scene.cameras.main.height - bottomOffset - containerHeight;\n        \n        this.playerContainer = this.scene.add.container(x, y);\n        \n        // Clean modern background\n        const bg = this.scene.add.graphics();\n        bg.fillStyle(0x1A1A2E, 0.9); // Dark blue-gray\n        bg.fillRoundedRect(0, 0, containerWidth, containerHeight, 8 * HD_SCALE);\n        bg.lineStyle(2 * HD_SCALE, 0x16C79A, 1); // Clean teal border\n        bg.strokeRoundedRect(0, 0, containerWidth, containerHeight, 8 * HD_SCALE);\n        \n        // Player label\n        this.playerNameText = this.scene.add.text(8 * HD_SCALE, 6 * HD_SCALE, 'PLAYER', {\n            fontSize: `${7 * HD_SCALE}px`,  // Reduced from 9\n            color: '#16C79A',\n            fontFamily: 'Arial',\n            fontStyle: 'bold'\n        });\n        \n        // Score text\n        this.playerScoreText = this.scene.add.text(8 * HD_SCALE, 18 * HD_SCALE, '0', {\n            fontSize: `${12 * HD_SCALE}px`,  // Reduced from 16\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        });\n        \n        // Lead indicator (simple crown emoji)\n        this.playerLeadIndicator = this.scene.add.text(containerWidth - 15 * HD_SCALE, containerHeight / 2, '👑', {\n            fontSize: `${9 * HD_SCALE}px`,  // Reduced from 12\n            fontFamily: 'Arial'\n        });\n        this.playerLeadIndicator.setOrigin(0.5);\n        this.playerLeadIndicator.setVisible(false);\n        \n        this.playerContainer.add([bg, this.playerNameText, this.playerScoreText, this.playerLeadIndicator]);\n        this.add(this.playerContainer);\n    }\n    \n    private createOpponentDisplay(): void {\n        // Clean positioning with HD scaling\n        const padding = 15 * HD_SCALE;\n        const topOffset = 35 * HD_SCALE;\n        const containerWidth = 70 * HD_SCALE;  // Reduced from 90\n        const containerHeight = 40 * HD_SCALE;  // Reduced from 50\n        \n        const x = this.scene.cameras.main.width - padding - containerWidth;\n        const y = topOffset;\n        \n        this.opponentContainer = this.scene.add.container(x, y);\n        \n        // Clean modern background\n        const bg = this.scene.add.graphics();\n        bg.fillStyle(0x1A1A2E, 0.9); // Dark blue-gray\n        bg.fillRoundedRect(0, 0, containerWidth, containerHeight, 8 * HD_SCALE);\n        bg.lineStyle(2 * HD_SCALE, 0xF45866, 1); // Clean red border\n        bg.strokeRoundedRect(0, 0, containerWidth, containerHeight, 8 * HD_SCALE);\n        \n        // Opponent label\n        this.opponentNameText = this.scene.add.text(containerWidth - 8 * HD_SCALE, 6 * HD_SCALE, 'OPPONENT', {\n            fontSize: `${7 * HD_SCALE}px`,  // Reduced from 9\n            color: '#F45866',\n            fontFamily: 'Arial',\n            fontStyle: 'bold'\n        });\n        this.opponentNameText.setOrigin(1, 0);\n        \n        // Score text\n        this.opponentScoreText = this.scene.add.text(containerWidth - 8 * HD_SCALE, 18 * HD_SCALE, '0', {\n            fontSize: `${12 * HD_SCALE}px`,  // Reduced from 16\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        });\n        this.opponentScoreText.setOrigin(1, 0);\n        \n        // Lead indicator (simple crown emoji)\n        this.opponentLeadIndicator = this.scene.add.text(15 * HD_SCALE, containerHeight / 2, '👑', {\n            fontSize: `${9 * HD_SCALE}px`,  // Reduced from 12\n            fontFamily: 'Arial'\n        });\n        this.opponentLeadIndicator.setOrigin(0.5);\n        this.opponentLeadIndicator.setVisible(false);\n        \n        this.opponentContainer.add([bg, this.opponentNameText, this.opponentScoreText, this.opponentLeadIndicator]);\n        this.add(this.opponentContainer);\n    }\n    \n    public updatePlayerScore(newScore: number, instant: boolean = false): void {\n        this.playerTargetScore = newScore;\n        \n        if (instant) {\n            this.playerDisplayScore = newScore;\n            this.playerScoreText.setText(this.formatScore(newScore));\n            return;\n        }\n        \n        // Animate score with rolling effect\n        this.scene.tweens.add({\n            targets: this,\n            playerDisplayScore: newScore,\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onUpdate: () => {\n                this.playerScoreText.setText(this.formatScore(Math.floor(this.playerDisplayScore)));\n            },\n            onComplete: () => {\n                // Pulse effect on completion\n                this.pulseScore(this.playerScoreText);\n                // Check who's winning\n                this.updateLeaderIndicator();\n            }\n        });\n    }\n    \n    public updateOpponentScore(newScore: number, instant: boolean = false): void {\n        this.opponentTargetScore = newScore;\n        \n        if (instant) {\n            this.opponentDisplayScore = newScore;\n            this.opponentScoreText.setText(this.formatScore(newScore));\n            return;\n        }\n        \n        // Animate score with rolling effect\n        this.scene.tweens.add({\n            targets: this,\n            opponentDisplayScore: newScore,\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onUpdate: () => {\n                this.opponentScoreText.setText(this.formatScore(Math.floor(this.opponentDisplayScore)));\n            },\n            onComplete: () => {\n                // Pulse effect on completion\n                this.pulseScore(this.opponentScoreText);\n                // Check who's winning\n                this.updateLeaderIndicator();\n            }\n        });\n    }\n    \n    private pulseScore(scoreText: Phaser.GameObjects.Text): void {\n        this.scene.tweens.add({\n            targets: scoreText,\n            scale: 1.1,\n            duration: 150,\n            yoyo: true,\n            ease: 'Power2'\n        });\n    }\n    \n    private formatScore(score: number): string {\n        // Add thousand separators\n        return score.toLocaleString();\n    }\n    \n    public getPlayerScore(): number {\n        return this.playerTargetScore;\n    }\n    \n    public getOpponentScore(): number {\n        return this.opponentTargetScore;\n    }\n    \n    public reset(): void {\n        this.playerScore = 0;\n        this.opponentScore = 0;\n        this.playerDisplayScore = 0;\n        this.opponentDisplayScore = 0;\n        this.playerTargetScore = 0;\n        this.opponentTargetScore = 0;\n        this.playerScoreText.setText('0');\n        this.opponentScoreText.setText('0');\n    }\n    \n    \n    private updateLeaderIndicator(): void {\n        const playerScore = this.playerTargetScore;\n        const opponentScore = this.opponentTargetScore;\n        \n        let newLeader: 'player' | 'opponent' | 'tie' = 'tie';\n        \n        if (playerScore > opponentScore) {\n            newLeader = 'player';\n        } else if (opponentScore > playerScore) {\n            newLeader = 'opponent';\n        }\n        \n        if (newLeader !== this.currentLeader) {\n            // Update leader indicators\n            this.playerLeadIndicator.setVisible(newLeader === 'player');\n            this.opponentLeadIndicator.setVisible(newLeader === 'opponent');\n            \n            // Simple glow effect for winner\n            if (newLeader === 'player') {\n                this.animateLeader(this.playerLeadIndicator);\n                this.playerContainer.setScale(1.02);\n                this.opponentContainer.setScale(1);\n            } else if (newLeader === 'opponent') {\n                this.animateLeader(this.opponentLeadIndicator);\n                this.opponentContainer.setScale(1.02);\n                this.playerContainer.setScale(1);\n            } else {\n                this.playerContainer.setScale(1);\n                this.opponentContainer.setScale(1);\n            }\n            \n            this.currentLeader = newLeader;\n        }\n    }\n    \n    private animateLeader(indicator: Phaser.GameObjects.Text): void {\n        // Simple bounce animation for crown\n        this.scene.tweens.add({\n            targets: indicator,\n            scale: { from: 0, to: 1 },\n            duration: 300,\n            ease: 'Back.easeOut'\n        });\n        \n        // Subtle rotation\n        this.scene.tweens.add({\n            targets: indicator,\n            angle: { from: -10, to: 10 },\n            duration: 2000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.InOut'\n        });\n    }\n    \n    public destroy(): void {\n        // Kill any active tweens\n        if (this.scene && this.scene.tweens) {\n            this.scene.tweens.killTweensOf(this);\n            this.scene.tweens.killTweensOf(this.playerScoreText);\n            this.scene.tweens.killTweensOf(this.opponentScoreText);\n            this.scene.tweens.killTweensOf(this.playerLeadIndicator);\n            this.scene.tweens.killTweensOf(this.opponentLeadIndicator);\n            this.scene.tweens.killTweensOf(this.playerContainer);\n            this.scene.tweens.killTweensOf(this.opponentContainer);\n        }\n        super.destroy();\n    }\n}","import { Scene } from 'phaser';\n\nexport enum ComboTier {\n    NORMAL = '',         // 3 matches - no text\n    COMBO_2 = 'COMBO x2', // 4 matches\n    COMBO_3 = 'COMBO x3', // 5 matches\n    COMBO_4 = 'COMBO x4', // 6 matches\n    COMBO_5 = 'COMBO x5'  // 7+ matches\n}\n\nexport interface ComboConfig {\n    tier: ComboTier;\n    multiplier: number;\n    color: number;\n    minBubbles: number;\n}\n\nexport class ComboManager {\n    private scene: Scene;\n    private currentCombo: number = 0;\n    private comboMultiplier: number = 1.0;\n    private lastMatchTime: number = 0;\n    private comboTimeout: number = 2000; // 2 seconds\n    private comboContainers: Phaser.GameObjects.Container[] = [];\n    \n    // Scoring configuration - linear and balanced\n    private readonly BASE_POINTS: { [key: number]: number } = {\n        3: 10,    // Standard match\n        4: 20,    // Good match  \n        5: 30,    // Great match\n        6: 40,    // Excellent match\n        7: 50     // Perfect match\n    };\n    \n    private readonly COMBO_CONFIGS: ComboConfig[] = [\n        { tier: ComboTier.NORMAL, multiplier: 1.0, color: 0xFFD700, minBubbles: 3 },\n        { tier: ComboTier.COMBO_2, multiplier: 1.2, color: 0x00FF00, minBubbles: 4 },\n        { tier: ComboTier.COMBO_3, multiplier: 1.5, color: 0x00BFFF, minBubbles: 5 },\n        { tier: ComboTier.COMBO_4, multiplier: 1.8, color: 0xFF4500, minBubbles: 6 },\n        { tier: ComboTier.COMBO_5, multiplier: 2.0, color: 0xFF1493, minBubbles: 7 }\n    ];\n    \n    private readonly CHAIN_BONUS: { [key: number]: number } = {\n        2: 1.1,   // +10%\n        3: 1.2,   // +20%\n        4: 1.3    // +30%\n    };\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n    }\n    \n    private createComboDisplay(x: number, y: number): Phaser.GameObjects.Container {\n        const comboContainer = this.scene.add.container(x, y);\n        comboContainer.setDepth(1200); // Higher depth for combo visibility\n        \n        // Create comic-style combo text for mobile\n        const comboText = this.scene.add.text(0, 0, '', {\n            fontSize: '24px',\n            color: '#FFFFFF',\n            fontFamily: 'Impact, Arial Black', // Comic style font\n            fontStyle: 'bold',\n            stroke: '#000000',\n            strokeThickness: 4\n        });\n        comboText.setOrigin(0.5);\n        comboText.setShadow(3, 3, '#000000', 5, true, true);\n        \n        comboContainer.add(comboText);\n        this.comboContainers.push(comboContainer);\n        \n        return comboContainer;\n    }\n    \n    public calculateScore(matchSize: number, x?: number, y?: number, bubbleColor?: number): number {\n        // Get base points\n        const basePoints = this.BASE_POINTS[Math.min(matchSize, 7)] || this.BASE_POINTS[7];\n        \n        // Check if this is a chain combo\n        const now = Date.now();\n        const isChain = (now - this.lastMatchTime) < this.comboTimeout;\n        \n        if (isChain) {\n            this.currentCombo++;\n        } else {\n            this.currentCombo = 1;\n        }\n        \n        this.lastMatchTime = now;\n        \n        // Get combo configuration\n        const comboConfig = this.getComboConfig(matchSize);\n        this.comboMultiplier = comboConfig.multiplier;\n        \n        // Get chain bonus\n        const chainBonus = this.CHAIN_BONUS[Math.min(this.currentCombo, 4)] || this.CHAIN_BONUS[4];\n        \n        // Calculate final score\n        const finalScore = Math.floor(basePoints * this.comboMultiplier * chainBonus);\n        \n        // DISABLED: Visual effects now handled by UnifiedFeedbackSystem\n        // if (x !== undefined && y !== undefined) {\n        //     this.showCombo(comboConfig, finalScore, x, y, matchSize, bubbleColor);\n        // }\n        \n        return finalScore;\n    }\n    \n    public getComboConfig(matchSize: number): ComboConfig {\n        // Find the appropriate combo tier based on match size\n        for (let i = this.COMBO_CONFIGS.length - 1; i >= 0; i--) {\n            if (matchSize >= this.COMBO_CONFIGS[i].minBubbles) {\n                return this.COMBO_CONFIGS[i];\n            }\n        }\n        return this.COMBO_CONFIGS[0];\n    }\n    \n    private showCombo(config: ComboConfig, points: number, x: number, y: number, matchSize: number, bubbleColor?: number): void {\n        // Create combo display at the match location\n        const comboContainer = this.createComboDisplay(x, y);\n        \n        // Get the text object before adding background\n        const comboText = comboContainer.list[0] as Phaser.GameObjects.Text;\n        \n        // Add background effect based on combo size\n        if (matchSize >= 4) {\n            this.addComboBackground(comboContainer, matchSize, bubbleColor || config.color);\n        }\n        \n        // Use bubble color if provided, otherwise use config color\n        const displayColor = bubbleColor || config.color;\n        \n        // For normal matches (3), just show points\n        // For combos (4+), show combo text and points\n        if (matchSize === 3) {\n            // Just show points for basic matches\n            comboText.setText(`+${points}`);\n            comboText.setTint(displayColor);\n            comboText.setFontSize(20);\n        } else {\n            // Show combo text with comic styling and bubble color\n            comboText.setText(config.tier);\n            comboText.setTint(displayColor);\n            comboText.setFontSize(28);\n            comboText.setStyle({\n                fontSize: '28px',\n                fontFamily: 'Impact, Arial Black',\n                fontStyle: 'bold',\n                stroke: '#000000',\n                strokeThickness: 5\n            });\n            \n            // Add points below combo text with comic style\n            const pointsText = this.scene.add.text(0, 26, `+${points}`, {\n                fontSize: '20px',\n                color: '#FFD700',\n                fontFamily: 'Impact, Arial Black',\n                fontStyle: 'bold',\n                stroke: '#000000',\n                strokeThickness: 3\n            });\n            pointsText.setOrigin(0.5);\n            pointsText.setShadow(2, 2, '#FF6600', 3, true, true);\n            comboContainer.add(pointsText);\n        }\n        \n        // Show and animate (smaller scale for mobile)\n        comboContainer.setVisible(true);\n        comboContainer.setScale(0);\n        comboContainer.setAlpha(1);\n        \n        // Elegant entrance animation\n        this.scene.tweens.add({\n            targets: comboContainer,\n            scale: { from: 0, to: 1.1 },\n            duration: 200,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                // Subtle settle\n                this.scene.tweens.add({\n                    targets: comboContainer,\n                    scale: 1,\n                    duration: 100,\n                    ease: 'Sine.easeInOut'\n                });\n            }\n        });\n        \n        // Float up animation - more pronounced to separate from drop bonus\n        this.scene.tweens.add({\n            targets: comboContainer,\n            y: comboContainer.y - 60, // Float higher from current position\n            duration: 1000,\n            ease: 'Cubic.easeOut'\n        });\n        \n        // Fade out after delay\n        this.scene.time.delayedCall(800, () => {\n            this.scene.tweens.add({\n                targets: comboContainer,\n                alpha: 0,\n                y: comboContainer.y - 20, // Continue floating up from current position\n                scale: 0.9,\n                duration: 400,\n                ease: 'Cubic.easeIn',\n                onComplete: () => {\n                    // Clean up\n                    const index = this.comboContainers.indexOf(comboContainer);\n                    if (index > -1) {\n                        this.comboContainers.splice(index, 1);\n                    }\n                    comboContainer.destroy(true);\n                }\n            });\n        });\n        \n        // Delay particle effects to appear after combo text\n        this.scene.time.delayedCall(300, () => {\n            // Create particles with bubble color\n            this.createParticleEffect(x, y, config, bubbleColor);\n            \n            // Add impact flash for big combos\n            if (matchSize >= 6) {\n                this.createImpactFlash(x, y, config);\n            }\n        });\n        \n        // Add effects based on combo tier\n        if (matchSize >= 5) {\n            this.addComboStars(config, comboContainer, matchSize, bubbleColor);\n        }\n        \n        // Screen shake intensity based on combo\n        if (matchSize >= 7) {\n            this.scene.cameras.main.shake(200, 0.008);\n            this.scene.cameras.main.flash(100, 255, 255, 255, false);\n        } else if (matchSize >= 6) {\n            this.scene.cameras.main.shake(150, 0.005);\n            this.scene.cameras.main.flash(50, 255, 200, 100, false);\n        } else if (matchSize >= 5) {\n            this.scene.cameras.main.shake(100, 0.003);\n        }\n    }\n    \n    private addComboStars(config: ComboConfig, container: Phaser.GameObjects.Container, matchSize: number, bubbleColor?: number): void {\n        const starCount = Math.min(matchSize - 4, 3); // 1-3 stars based on combo size\n        const starY = -20; // Closer to text\n        \n        for (let i = 0; i < starCount; i++) {\n            const starX = (i - (starCount - 1) / 2) * 20; // Smaller spacing\n            const star = this.scene.add.star(starX, starY, 5, 4, 8, bubbleColor || config.color); // Smaller stars\n            star.setAlpha(0.8);\n            \n            container.add(star);\n            \n            // Rotate stars\n            this.scene.tweens.add({\n                targets: star,\n                angle: 360,\n                duration: 1000,\n                ease: 'Linear'\n            });\n            \n            // Pulse stars\n            this.scene.tweens.add({\n                targets: star,\n                scale: { from: 0.5, to: 0.8 },\n                alpha: { from: 0.8, to: 1 },\n                duration: 300,\n                yoyo: true,\n                repeat: 1,\n                ease: 'Sine.easeInOut'\n            });\n        }\n    }\n    \n    public createParticleEffect(x: number, y: number, config: ComboConfig, bubbleColor?: number): void {\n        // Progressive particle count based on combo size\n        let particleCount;\n        if (config.minBubbles === 3) {\n            particleCount = 8; // Very subtle for 3\n        } else if (config.minBubbles === 4) {\n            particleCount = 16; // Small burst for 4\n        } else if (config.minBubbles === 5) {\n            particleCount = 30; // Medium burst for 5\n        } else if (config.minBubbles === 6) {\n            particleCount = 50; // Large burst for 6\n        } else {\n            particleCount = 80; // Massive for 7+\n        }\n        \n        // Create different effects based on combo tier\n        if (config.minBubbles >= 7) {\n            // MEGA COMBO - Fire explosion!\n            this.createFireExplosion(x, y, config, bubbleColor);\n        } else if (config.minBubbles >= 6) {\n            // Big combos get special effects\n            this.createExplosionEffect(x, y, config, bubbleColor);\n        } else if (config.minBubbles >= 5) {\n            // Medium combos get burst\n            this.createColorBurst(x, y, config, bubbleColor);\n        }\n        \n        // Particle size and speed based on combo\n        const particleSize = config.minBubbles === 3 ? [1, 2] : \n                           config.minBubbles === 4 ? [2, 3] :\n                           config.minBubbles === 5 ? [2, 4] :\n                           [3, 6];\n        \n        const speedRange = config.minBubbles === 3 ? [30, 60] :\n                          config.minBubbles === 4 ? [40, 100] :\n                          config.minBubbles === 5 ? [60, 150] :\n                          [80, 250];\n        \n        // Standard particle burst with bubble colors\n        for (let i = 0; i < particleCount; i++) {\n            // Always use bubble color as primary\n            const baseColor = bubbleColor || config.color;\n            // Mix with lighter/darker shades for variety\n            const shadeVariation = Phaser.Math.Between(-0.2, 0.2);\n            const particleColor = Phaser.Display.Color.Interpolate.ColorWithColor(\n                Phaser.Display.Color.ValueToColor(baseColor),\n                Phaser.Display.Color.ValueToColor(0xFFFFFF),\n                100,\n                Math.abs(shadeVariation) * 100\n            );\n            const finalColor = Phaser.Display.Color.GetColor(particleColor.r, particleColor.g, particleColor.b);\n            \n            const particle = this.scene.add.circle(\n                x, y, \n                Phaser.Math.Between(particleSize[0], particleSize[1]),\n                finalColor,\n                config.minBubbles === 3 ? 0.6 : 1\n            );\n            particle.setDepth(1150); // Higher depth for particles\n            \n            const angle = (Math.PI * 2 * i) / particleCount;\n            const speed = Phaser.Math.Between(speedRange[0], speedRange[1]);\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: x + Math.cos(angle) * speed,\n                y: y + Math.sin(angle) * speed,\n                alpha: 0,\n                scale: { from: 1, to: 0 },\n                duration: config.minBubbles === 3 ? 400 : Phaser.Math.Between(600, 1000),\n                ease: 'Power2.easeOut',\n                delay: i * (config.minBubbles === 3 ? 2 : 5),\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n        \n        // Add glow effect only for combos 5+\n        if (config.minBubbles >= 5) {\n            this.createGlowEffect(x, y, config);\n        }\n    }\n    \n    private createExplosionEffect(x: number, y: number, config: ComboConfig, bubbleColor?: number): void {\n        const explosionColor = bubbleColor || config.color;\n        \n        // Create expanding ring with bubble color\n        const ring = this.scene.add.graphics();\n        ring.lineStyle(3, explosionColor, 1);\n        ring.strokeCircle(0, 0, 20);\n        ring.setPosition(x, y);\n        ring.setDepth(1049);\n        ring.setScale(0);\n        \n        // Animate ring expansion\n        this.scene.tweens.add({\n            targets: ring,\n            scale: 3,\n            alpha: 0,\n            duration: 600,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                ring.destroy();\n            }\n        });\n        \n        // Create star burst for perfect combos\n        if (config.minBubbles >= 7) {\n            for (let i = 0; i < 8; i++) {\n                const angle = (Math.PI * 2 * i) / 8;\n                const star = this.scene.add.star(\n                    x + Math.cos(angle) * 20,\n                    y + Math.sin(angle) * 20,\n                    5, 3, 6,\n                    bubbleColor || config.color\n                );\n                star.setDepth(1051);\n                star.setScale(0);\n                \n                this.scene.tweens.add({\n                    targets: star,\n                    x: x + Math.cos(angle) * 100,\n                    y: y + Math.sin(angle) * 100,\n                    scale: { from: 0, to: 1 },\n                    alpha: { from: 1, to: 0 },\n                    angle: 360,\n                    duration: 800,\n                    delay: i * 50,\n                    ease: 'Cubic.easeOut',\n                    onComplete: () => {\n                        star.destroy();\n                    }\n                });\n            }\n        }\n    }\n    \n    private createGlowEffect(x: number, y: number, config: ComboConfig): void {\n        // Create multiple glow layers for depth\n        for (let i = 0; i < 3; i++) {\n            const glow = this.scene.add.circle(x, y, 20 + i * 10, config.color, 0.4 - i * 0.1);\n            glow.setDepth(1048 - i);\n            glow.setScale(0);\n            \n            // Pulse and fade with delay\n            this.scene.tweens.add({\n                targets: glow,\n                scale: 2 + i * 0.5,\n                alpha: 0,\n                duration: 600 + i * 100,\n                delay: i * 50,\n                ease: 'Sine.easeOut',\n                onComplete: () => {\n                    glow.destroy();\n                }\n            });\n        }\n    }\n    \n    private createColorBurst(x: number, y: number, config: ComboConfig): void {\n        // Create rainbow burst for medium combos\n        const colors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x9400D3];\n        const burstCount = 12;\n        \n        for (let i = 0; i < burstCount; i++) {\n            const angle = (Math.PI * 2 * i) / burstCount;\n            const color = colors[i % colors.length];\n            \n            // Create streak\n            const streak = this.scene.add.rectangle(\n                x, y, 40, 4, color\n            );\n            streak.setOrigin(0, 0.5);\n            streak.setRotation(angle);\n            streak.setDepth(1049);\n            streak.setScale(0, 1);\n            \n            // Animate streak\n            this.scene.tweens.add({\n                targets: streak,\n                scaleX: 2,\n                alpha: { from: 1, to: 0 },\n                duration: 500,\n                ease: 'Power2.easeOut',\n                onComplete: () => {\n                    streak.destroy();\n                }\n            });\n        }\n    }\n    \n    private addComboBackground(container: Phaser.GameObjects.Container, matchSize: number, color: number): void {\n        if (matchSize >= 7) {\n            // Fire/explosion background for mega combos\n            const fireGradient = this.scene.add.graphics();\n            fireGradient.fillStyle(0xFF6B00, 0.3);\n            fireGradient.fillCircle(0, 0, 40);\n            fireGradient.fillStyle(0xFF0000, 0.2);\n            fireGradient.fillCircle(0, 0, 50);\n            fireGradient.setDepth(-1);\n            \n            // Pulsing animation\n            this.scene.tweens.add({\n                targets: fireGradient,\n                scale: { from: 0.8, to: 1.2 },\n                alpha: { from: 0.3, to: 0.6 },\n                duration: 300,\n                yoyo: true,\n                repeat: 2,\n                ease: 'Sine.easeInOut'\n            });\n            \n            container.addAt(fireGradient, 0);\n            \n            // Add fire particles around text\n            for (let i = 0; i < 6; i++) {\n                const angle = (Math.PI * 2 * i) / 6;\n                const dist = 25;\n                const fireParticle = this.scene.add.circle(\n                    Math.cos(angle) * dist,\n                    Math.sin(angle) * dist,\n                    3,\n                    0xFF4500,\n                    0.8\n                );\n                container.add(fireParticle);\n                \n                this.scene.tweens.add({\n                    targets: fireParticle,\n                    scale: { from: 0.5, to: 1.5 },\n                    alpha: { from: 0.8, to: 0 },\n                    duration: 600,\n                    delay: i * 50,\n                    ease: 'Power2.easeOut'\n                });\n            }\n        } else if (matchSize >= 6) {\n            // Electric burst background\n            const burst = this.scene.add.graphics();\n            burst.fillStyle(color, 0.2);\n            burst.fillCircle(0, 0, 35);\n            burst.lineStyle(2, color, 0.5);\n            burst.strokeCircle(0, 0, 35);\n            burst.setDepth(-1);\n            \n            this.scene.tweens.add({\n                targets: burst,\n                scale: { from: 0, to: 1.1 },\n                alpha: { from: 0.5, to: 0.2 },\n                duration: 400,\n                ease: 'Back.easeOut'\n            });\n            \n            container.addAt(burst, 0);\n        } else if (matchSize >= 5) {\n            // Star burst background\n            const starBurst = this.scene.add.star(0, 0, 8, 15, 30, color);\n            starBurst.setAlpha(0.25);\n            starBurst.setDepth(-1);\n            \n            this.scene.tweens.add({\n                targets: starBurst,\n                angle: 360,\n                scale: { from: 0, to: 1.2 },\n                alpha: { from: 0.4, to: 0.1 },\n                duration: 800,\n                ease: 'Power2.easeOut'\n            });\n            \n            container.addAt(starBurst, 0);\n        } else {\n            // Simple glow for 4-match\n            const glow = this.scene.add.circle(0, 0, 25, color, 0.15);\n            glow.setDepth(-1);\n            \n            this.scene.tweens.add({\n                targets: glow,\n                scale: { from: 0, to: 1 },\n                alpha: { from: 0.3, to: 0.1 },\n                duration: 500,\n                ease: 'Sine.easeOut'\n            });\n            \n            container.addAt(glow, 0);\n        }\n    }\n    \n    \n    private createFireExplosion(x: number, y: number, config: ComboConfig, bubbleColor?: number): void {\n        // Create epic fire effect for mega combos\n        const baseColor = bubbleColor || config.color;\n        // Create fire-tinted variations of the bubble color\n        const fireColors = [\n            baseColor,\n            Phaser.Display.Color.Interpolate.ColorWithColor(\n                Phaser.Display.Color.ValueToColor(baseColor),\n                Phaser.Display.Color.ValueToColor(0xFF0000),\n                100, 30\n            ),\n            Phaser.Display.Color.Interpolate.ColorWithColor(\n                Phaser.Display.Color.ValueToColor(baseColor),\n                Phaser.Display.Color.ValueToColor(0xFFD700),\n                100, 50\n            )\n        ].map(c => c.color !== undefined ? c.color : Phaser.Display.Color.GetColor(c.r, c.g, c.b));\n        const particleCount = 50;\n        \n        // Create fire shockwave with bubble color\n        const shockwave = this.scene.add.graphics();\n        shockwave.lineStyle(5, baseColor, 1);\n        shockwave.strokeCircle(0, 0, 30);\n        shockwave.setPosition(x, y);\n        shockwave.setDepth(1048);\n        shockwave.setScale(0);\n        \n        // Animate shockwave\n        this.scene.tweens.add({\n            targets: shockwave,\n            scale: 4,\n            alpha: 0,\n            duration: 400,\n            ease: 'Power2.easeOut',\n            onComplete: () => {\n                shockwave.destroy();\n            }\n        });\n        \n        // Create fire particles\n        for (let i = 0; i < particleCount; i++) {\n            const fireColor = fireColors[Math.floor(Math.random() * fireColors.length)];\n            const size = Phaser.Math.Between(3, 8);\n            \n            const flame = this.scene.add.circle(\n                x + Phaser.Math.Between(-20, 20),\n                y + Phaser.Math.Between(-20, 20),\n                size,\n                fireColor\n            );\n            flame.setDepth(1051);\n            \n            const angle = Math.random() * Math.PI * 2;\n            const speed = Phaser.Math.Between(100, 300);\n            const targetX = x + Math.cos(angle) * speed;\n            const targetY = y + Math.sin(angle) * speed - Phaser.Math.Between(50, 150); // Fire rises\n            \n            // Animate flame\n            this.scene.tweens.add({\n                targets: flame,\n                x: targetX,\n                y: targetY,\n                alpha: { from: 1, to: 0 },\n                scale: { from: 1.5, to: 0 },\n                duration: Phaser.Math.Between(600, 1000),\n                delay: i * 10,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    flame.destroy();\n                }\n            });\n            \n            // Add glow to each flame\n            const glow = this.scene.add.circle(flame.x, flame.y, size * 2, fireColor, 0.3);\n            glow.setDepth(1050);\n            \n            this.scene.tweens.add({\n                targets: glow,\n                x: targetX,\n                y: targetY,\n                alpha: 0,\n                scale: 2,\n                duration: Phaser.Math.Between(600, 1000),\n                delay: i * 10,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    glow.destroy();\n                }\n            });\n        }\n        \n        // Add fire text effect\n        if (config.minBubbles >= 7) {\n            const fireText = this.scene.add.text(x, y - 50, '🔥', {\n                fontSize: '48px'\n            });\n            fireText.setOrigin(0.5);\n            fireText.setDepth(1052);\n            fireText.setScale(0);\n            \n            this.scene.tweens.add({\n                targets: fireText,\n                scale: { from: 0, to: 2 },\n                alpha: { from: 1, to: 0 },\n                y: y - 100,\n                duration: 800,\n                ease: 'Back.easeOut',\n                onComplete: () => {\n                    fireText.destroy();\n                }\n            });\n        }\n    }\n    \n    private createImpactFlash(x: number, y: number, config: ComboConfig): void {\n        // Create a bright white flash at impact point\n        const flash = this.scene.add.graphics();\n        flash.fillStyle(0xFFFFFF, 0.8);\n        flash.fillCircle(0, 0, 50);\n        flash.setPosition(x, y);\n        flash.setDepth(1047);\n        flash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        // Quick flash animation\n        this.scene.tweens.add({\n            targets: flash,\n            alpha: 0,\n            scale: 3,\n            duration: 200,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                flash.destroy();\n            }\n        });\n        \n        // Create secondary colored flash\n        const colorFlash = this.scene.add.graphics();\n        colorFlash.fillStyle(config.color, 0.5);\n        colorFlash.fillCircle(0, 0, 80);\n        colorFlash.setPosition(x, y);\n        colorFlash.setDepth(1046);\n        colorFlash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        this.scene.tweens.add({\n            targets: colorFlash,\n            alpha: 0,\n            scale: 2,\n            duration: 400,\n            ease: 'Sine.easeOut',\n            onComplete: () => {\n                colorFlash.destroy();\n            }\n        });\n    }\n    \n    public reset(): void {\n        this.currentCombo = 0;\n        this.comboMultiplier = 1.0;\n        this.lastMatchTime = 0;\n        // Clean up all combo containers\n        this.comboContainers.forEach(container => container.destroy(true));\n        this.comboContainers = [];\n    }\n    \n    public getCurrentCombo(): number {\n        return this.currentCombo;\n    }\n    \n    public getMultiplier(): number {\n        return this.comboMultiplier;\n    }\n}","import Phaser from 'phaser';\n\nexport class VictoryScreen extends Phaser.GameObjects.Container {\n    private particles?: Phaser.GameObjects.Particles.ParticleEmitter;\n    \n    constructor(\n        scene: Phaser.Scene, \n        finalScore: number, \n        onReplay: () => void, \n        onMenu: () => void\n    ) {\n        super(scene, scene.cameras.main.centerX, scene.cameras.main.centerY);\n        \n        // Semi-transparent backdrop\n        const backdrop = scene.add.rectangle(\n            0, 0,\n            scene.cameras.main.width * 2,\n            scene.cameras.main.height * 2,\n            0x000000, 0.75\n        );\n        backdrop.setInteractive(); // Block clicks\n        \n        // Victory panel background\n        const panelBg = scene.add.rectangle(0, 0, 400, 500, 0x1a1a2e, 0.95);\n        panelBg.setStrokeStyle(4, 0xFFD700);\n        \n        // Victory banner\n        const banner = scene.add.rectangle(0, -150, 350, 100, 0xFFD700);\n        banner.setStrokeStyle(3, 0xFFA500);\n        \n        // Victory text with glow effect\n        const victoryGlow = scene.add.text(0, -150, 'VICTORY!', {\n            fontSize: '52px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        victoryGlow.setShadow(0, 0, '#FFD700', 10);\n        \n        const victoryText = scene.add.text(0, -150, 'VICTORY!', {\n            fontSize: '48px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold',\n            stroke: '#FF6600',\n            strokeThickness: 6\n        }).setOrigin(0.5);\n        \n        // Stars decoration\n        const star1 = this.createStar(scene, -120, -150, 20, 0xFFD700);\n        const star2 = this.createStar(scene, 120, -150, 20, 0xFFD700);\n        const star3 = this.createStar(scene, 0, -200, 15, 0xFFA500);\n        \n        // Score section\n        const scoreBg = scene.add.rectangle(0, -20, 300, 80, 0x2c3e50, 0.8);\n        scoreBg.setStrokeStyle(2, 0xFFD700);\n        \n        const scoreLabel = scene.add.text(0, -40, 'FINAL SCORE', {\n            fontSize: '20px',\n            color: '#FFD700',\n            fontFamily: 'Arial',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        const scoreValue = scene.add.text(0, -5, '0', {\n            fontSize: '42px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        // Stats\n        const statsText = scene.add.text(0, 50, 'Great job!', {\n            fontSize: '18px',\n            color: '#FFD700',\n            fontFamily: 'Arial'\n        }).setOrigin(0.5);\n        \n        // Buttons\n        const playAgainBtn = this.createButton(scene, 0, 130, 'PLAY AGAIN', 0x00AA00, 0x00FF00, onReplay);\n        const menuBtn = this.createButton(scene, 0, 200, 'MAIN MENU', 0x0066CC, 0x0099FF, onMenu);\n        \n        // Add all elements\n        this.add([\n            backdrop, panelBg, banner, \n            star1, star2, star3,\n            victoryGlow, victoryText,\n            scoreBg, scoreLabel, scoreValue,\n            statsText, playAgainBtn, menuBtn\n        ]);\n        \n        // Initial state for animations\n        this.setAlpha(0);\n        panelBg.setScale(0);\n        banner.setScale(0);\n        victoryText.setScale(0);\n        victoryGlow.setScale(0);\n        \n        // Entrance animations\n        scene.tweens.add({\n            targets: this,\n            alpha: 1,\n            duration: 300,\n            ease: 'Power2'\n        });\n        \n        scene.tweens.add({\n            targets: panelBg,\n            scaleX: 1,\n            scaleY: 1,\n            duration: 400,\n            ease: 'Back.easeOut',\n            delay: 100\n        });\n        \n        scene.tweens.add({\n            targets: [banner, victoryText, victoryGlow],\n            scaleX: 1,\n            scaleY: 1,\n            duration: 500,\n            ease: 'Back.easeOut',\n            delay: 300\n        });\n        \n        // Star rotation\n        scene.tweens.add({\n            targets: [star1, star2, star3],\n            angle: 360,\n            duration: 3000,\n            repeat: -1,\n            ease: 'Linear'\n        });\n        \n        // Score count up\n        const scoreCounter = { value: 0 };\n        scene.tweens.add({\n            targets: scoreCounter,\n            value: finalScore,\n            duration: 1500,\n            ease: 'Cubic.easeOut',\n            delay: 800,\n            onUpdate: () => {\n                scoreValue.setText(Math.floor(scoreCounter.value).toString());\n            },\n            onComplete: () => {\n                // Pulse the score\n                scene.tweens.add({\n                    targets: scoreValue,\n                    scale: 1.1,\n                    duration: 300,\n                    yoyo: true,\n                    ease: 'Power2'\n                });\n            }\n        });\n        \n        // Create particle effects\n        this.createConfetti(scene);\n        \n        // Camera shake for impact\n        scene.cameras.main.shake(300, 0.005);\n        \n        this.setDepth(2000);\n        scene.add.existing(this);\n    }\n    \n    private createStar(scene: Phaser.Scene, x: number, y: number, size: number, color: number): Phaser.GameObjects.Star {\n        const star = scene.add.star(x, y, 5, size * 0.5, size, color);\n        star.setStrokeStyle(2, 0xFFFFFF);\n        return star;\n    }\n    \n    private createButton(\n        scene: Phaser.Scene, \n        x: number, \n        y: number, \n        text: string, \n        bgColor: number,\n        hoverColor: number,\n        callback: () => void\n    ): Phaser.GameObjects.Container {\n        const button = scene.add.container(x, y);\n        \n        const bg = scene.add.rectangle(0, 0, 220, 55, bgColor);\n        bg.setInteractive({ useHandCursor: true });\n        bg.setStrokeStyle(3, 0xFFFFFF);\n        \n        const shadow = scene.add.rectangle(0, 3, 220, 55, 0x000000, 0.3);\n        shadow.setDepth(-1);\n        \n        const label = scene.add.text(0, 0, text, {\n            fontSize: '22px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        button.add([shadow, bg, label]);\n        \n        // Button interactions\n        bg.on('pointerover', () => {\n            bg.setFillStyle(hoverColor);\n            scene.tweens.add({\n                targets: [bg, label],\n                scale: 1.05,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n        \n        bg.on('pointerout', () => {\n            bg.setFillStyle(bgColor);\n            scene.tweens.add({\n                targets: [bg, label],\n                scale: 1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n        \n        bg.on('pointerdown', () => {\n            console.log(`💆 VictoryScreen button clicked: ${text}`);\n            \n            // Emit UI click event for sound system\n            scene.events.emit('ui-click');\n            \n            // Execute callback IMMEDIATELY without waiting for tween\n            console.log(`🚀 Executing callback for: ${text}`);\n            \n            try {\n                if (callback && typeof callback === 'function') {\n                    console.log(`💫 Callback type check passed, executing...`);\n                    callback();\n                    console.log(`✅ Callback executed successfully!`);\n                } else {\n                    console.error('❌ Callback is not a function:', callback, 'Type:', typeof callback);\n                }\n            } catch (error) {\n                console.error('❌ Error executing callback:', error);\n            }\n            \n            // Visual feedback AFTER callback\n            scene.tweens.add({\n                targets: button,\n                scale: 0.9,\n                duration: 100,\n                yoyo: true,\n                ease: 'Power2'\n            });\n        });\n        \n        // Initial animation\n        button.setScale(0);\n        scene.tweens.add({\n            targets: button,\n            scale: 1,\n            duration: 400,\n            ease: 'Back.easeOut',\n            delay: 1000 + (y > 150 ? 200 : 0)\n        });\n        \n        return button;\n    }\n    \n    private createConfetti(scene: Phaser.Scene): void {\n        const colors = [0xFFD700, 0xFFA500, 0xFF69B4, 0x00CED1, 0x98FB98, 0xFF6347];\n        \n        // Create confetti manually using shapes\n        const confettiTimer = scene.time.addEvent({\n            delay: 100,\n            repeat: 30,\n            callback: () => {\n                for (let i = 0; i < 6; i++) {\n                    const x = Phaser.Math.Between(-100, 100);\n                    const y = -250;\n                    \n                    // Random shape (circle or rectangle)\n                    const shape = Math.random() > 0.5 ?\n                        scene.add.circle(x, y, Phaser.Math.Between(3, 6), Phaser.Utils.Array.GetRandom(colors), 0.9) :\n                        scene.add.rectangle(x, y, Phaser.Math.Between(8, 12), Phaser.Math.Between(4, 6), Phaser.Utils.Array.GetRandom(colors), 0.9);\n                    \n                    shape.setRotation(Math.random() * Math.PI * 2);\n                    this.add(shape);\n                    \n                    const angle = Phaser.Math.Between(-110, -70) * Math.PI / 180;\n                    const speed = Phaser.Math.Between(100, 350);\n                    const vx = Math.cos(angle) * speed;\n                    const vy = Math.sin(angle) * speed;\n                    \n                    scene.tweens.add({\n                        targets: shape,\n                        x: shape.x + vx,\n                        y: shape.y + vy + 600, // Gravity effect\n                        rotation: shape.rotation + Phaser.Math.Between(-6, 6),\n                        alpha: 0,\n                        scale: 0,\n                        duration: 3000,\n                        ease: 'Power2',\n                        onComplete: () => shape.destroy()\n                    });\n                }\n            }\n        });\n        \n        // Stop confetti after 3 seconds\n        scene.time.delayedCall(3000, () => {\n            confettiTimer.destroy();\n        });\n    }\n    \n    public destroy(): void {\n        this.scene.tweens.killTweensOf(this);\n        super.destroy();\n    }\n}","import Phaser from 'phaser';\n\nexport class DefeatScreen extends Phaser.GameObjects.Container {\n    constructor(\n        scene: Phaser.Scene, \n        finalScore: number, \n        onRetry: () => void, \n        onMenu: () => void\n    ) {\n        super(scene, scene.cameras.main.centerX, scene.cameras.main.centerY);\n        \n        // Semi-transparent backdrop\n        const backdrop = scene.add.rectangle(\n            0, 0,\n            scene.cameras.main.width * 2,\n            scene.cameras.main.height * 2,\n            0x000000, 0.85\n        );\n        backdrop.setInteractive(); // Block clicks\n        \n        // Defeat panel background with softer colors\n        const panelBg = scene.add.rectangle(0, 0, 400, 450, 0x2c2c3e, 0.95);\n        panelBg.setStrokeStyle(3, 0x7B68EE);\n        \n        // Defeat banner\n        const banner = scene.add.rectangle(0, -140, 350, 90, 0x4B0082, 0.9);\n        banner.setStrokeStyle(2, 0x7B68EE);\n        \n        // Defeat text\n        const defeatText = scene.add.text(0, -140, 'GAME OVER', {\n            fontSize: '42px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        defeatText.setShadow(2, 2, '#000000', 5);\n        \n        // Encouraging message\n        const encourageText = scene.add.text(0, -80, \"Don't give up!\", {\n            fontSize: '20px',\n            color: '#FFD700',\n            fontFamily: 'Arial',\n            fontStyle: 'italic'\n        }).setOrigin(0.5);\n        \n        // Score section\n        const scoreBg = scene.add.rectangle(0, -10, 280, 70, 0x1a1a2e, 0.8);\n        scoreBg.setStrokeStyle(2, 0x7B68EE);\n        \n        const scoreLabel = scene.add.text(0, -28, 'YOUR SCORE', {\n            fontSize: '18px',\n            color: '#B8B8B8',\n            fontFamily: 'Arial'\n        }).setOrigin(0.5);\n        \n        const scoreValue = scene.add.text(0, 2, finalScore.toString(), {\n            fontSize: '36px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        // Motivational text\n        let motivationalMsg = \"You can do better!\";\n        if (finalScore > 1000) motivationalMsg = \"Great effort!\";\n        if (finalScore > 5000) motivationalMsg = \"So close! Try again!\";\n        if (finalScore > 10000) motivationalMsg = \"Amazing score! Almost there!\";\n        \n        const motivationText = scene.add.text(0, 50, motivationalMsg, {\n            fontSize: '18px',\n            color: '#FFA500',\n            fontFamily: 'Arial'\n        }).setOrigin(0.5);\n        \n        // Buttons - Retry is more prominent\n        const retryBtn = this.createButton(\n            scene, 0, 120, 'TRY AGAIN', \n            0xFF6B6B, 0xFF8E8E, true, onRetry\n        );\n        \n        const menuBtn = this.createButton(\n            scene, 0, 185, 'Main Menu', \n            0x5C5C8A, 0x7C7CAA, false, onMenu\n        );\n        \n        // Add all elements\n        this.add([\n            backdrop, panelBg, banner,\n            defeatText, encourageText,\n            scoreBg, scoreLabel, scoreValue,\n            motivationText, retryBtn, menuBtn\n        ]);\n        \n        // Initial state for animations\n        this.setAlpha(0);\n        panelBg.setScale(0.8);\n        defeatText.setScale(0);\n        \n        // Gentle entrance animations\n        scene.tweens.add({\n            targets: this,\n            alpha: 1,\n            duration: 500,\n            ease: 'Power2'\n        });\n        \n        scene.tweens.add({\n            targets: panelBg,\n            scaleX: 1,\n            scaleY: 1,\n            duration: 600,\n            ease: 'Quad.easeOut',\n            delay: 100\n        });\n        \n        scene.tweens.add({\n            targets: defeatText,\n            scaleX: 1,\n            scaleY: 1,\n            duration: 400,\n            ease: 'Quad.easeOut',\n            delay: 300\n        });\n        \n        // Gentle pulsing on encourage text\n        scene.tweens.add({\n            targets: encourageText,\n            scale: 1.05,\n            duration: 1500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Score display (immediate, no count up for defeat)\n        scoreValue.setScale(0);\n        scene.tweens.add({\n            targets: scoreValue,\n            scale: 1,\n            duration: 400,\n            ease: 'Back.easeOut',\n            delay: 500\n        });\n        \n        // Add some floating bubbles for visual interest\n        this.createFloatingBubbles(scene);\n        \n        this.setDepth(2000);\n        scene.add.existing(this);\n    }\n    \n    private createButton(\n        scene: Phaser.Scene, \n        x: number, \n        y: number, \n        text: string, \n        bgColor: number,\n        hoverColor: number,\n        isPrimary: boolean,\n        callback: () => void\n    ): Phaser.GameObjects.Container {\n        const button = scene.add.container(x, y);\n        \n        const width = isPrimary ? 240 : 200;\n        const height = isPrimary ? 60 : 50;\n        const fontSize = isPrimary ? '24px' : '20px';\n        \n        const bg = scene.add.rectangle(0, 0, width, height, bgColor);\n        bg.setInteractive({ useHandCursor: true });\n        bg.setStrokeStyle(isPrimary ? 3 : 2, 0xFFFFFF);\n        \n        const shadow = scene.add.rectangle(0, 3, width, height, 0x000000, 0.3);\n        shadow.setDepth(-1);\n        \n        const label = scene.add.text(0, 0, text, {\n            fontSize: fontSize,\n            color: '#FFFFFF',\n            fontFamily: isPrimary ? 'Arial Black' : 'Arial',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        button.add([shadow, bg, label]);\n        \n        // Primary button pulses\n        if (isPrimary) {\n            scene.tweens.add({\n                targets: bg,\n                scale: 1.05,\n                duration: 1000,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut'\n            });\n        }\n        \n        // Button interactions\n        bg.on('pointerover', () => {\n            bg.setFillStyle(hoverColor);\n            scene.tweens.add({\n                targets: [bg, label],\n                scale: 1.1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n        \n        bg.on('pointerout', () => {\n            bg.setFillStyle(bgColor);\n            scene.tweens.add({\n                targets: [bg, label],\n                scale: 1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n        \n        bg.on('pointerdown', () => {\n            console.log(`💆 DefeatScreen button clicked: ${text}`);\n            \n            // Emit UI click event for sound system\n            scene.events.emit('ui-click');\n            \n            // Execute callback IMMEDIATELY without waiting for tween\n            console.log(`🚀 Executing callback for: ${text}`);\n            \n            try {\n                if (callback && typeof callback === 'function') {\n                    console.log(`💫 Callback type check passed, executing...`);\n                    callback();\n                    console.log(`✅ Callback executed successfully!`);\n                } else {\n                    console.error('❌ Callback is not a function:', callback, 'Type:', typeof callback);\n                }\n            } catch (error) {\n                console.error('❌ Error executing callback:', error);\n            }\n            \n            // Visual feedback AFTER callback\n            scene.tweens.add({\n                targets: button,\n                scale: 0.9,\n                duration: 100,\n                yoyo: true,\n                ease: 'Power2'\n            });\n        });\n        \n        // Initial animation\n        button.setAlpha(0);\n        scene.tweens.add({\n            targets: button,\n            alpha: 1,\n            duration: 500,\n            ease: 'Power2',\n            delay: 800 + (isPrimary ? 0 : 200)\n        });\n        \n        return button;\n    }\n    \n    private createFloatingBubbles(scene: Phaser.Scene): void {\n        const colors = [0x7B68EE, 0x4B0082, 0x6A5ACD];\n        \n        for (let i = 0; i < 5; i++) {\n            const x = Phaser.Math.Between(-150, 150);\n            const y = Phaser.Math.Between(-200, 200);\n            \n            const bubble = scene.add.circle(x, y, 15, colors[i % colors.length], 0.2);\n            this.add(bubble);\n            \n            // Floating animation\n            scene.tweens.add({\n                targets: bubble,\n                y: y - 30,\n                duration: 3000 + i * 500,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut',\n                delay: i * 200\n            });\n            \n            scene.tweens.add({\n                targets: bubble,\n                x: x + Phaser.Math.Between(-20, 20),\n                duration: 2000 + i * 300,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut',\n                delay: i * 150\n            });\n        }\n    }\n    \n    public destroy(): void {\n        this.scene.tweens.killTweensOf(this);\n        super.destroy();\n    }\n}","import { Scene } from 'phaser';\nimport { HD_SCALE } from '@/config/GameConfig';\n\n// Types of poolable effects\nexport enum EffectType {\n    FLOATING_TEXT = 'floating_text',\n    PARTICLE_BURST = 'particle_burst',\n    RING_EXPLOSION = 'ring_explosion',\n    STAR_BURST = 'star_burst',\n    COMBO_DISPLAY = 'combo_display'\n}\n\n// Base interface for poolable effects\ninterface IPoolableEffect {\n    type: EffectType;\n    active: boolean;\n    gameObject: Phaser.GameObjects.GameObject;\n    reset(): void;\n    activate(x: number, y: number, ...args: any[]): void;\n    deactivate(): void;\n    update?(delta: number): void;\n}\n\n// Floating text effect\nclass FloatingTextEffect implements IPoolableEffect {\n    type = EffectType.FLOATING_TEXT;\n    active = false;\n    gameObject: Phaser.GameObjects.Container;\n    private scene: Scene;\n    private text: Phaser.GameObjects.Text;\n    private tween?: Phaser.Tweens.Tween;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        \n        // Create container\n        this.gameObject = scene.add.container(0, 0);\n        this.gameObject.setDepth(1200);\n        \n        // Create text - optimized for mobile\n        this.text = scene.add.text(0, 0, '', {\n            fontSize: `${10 * HD_SCALE}px`,  // Balanced size for mobile HD\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold',\n            stroke: '#000000',\n            strokeThickness: 2 * HD_SCALE  // Clean stroke width HD\n        });\n        this.text.setOrigin(0.5);\n        this.text.setShadow(1 * HD_SCALE, 1 * HD_SCALE, '#000000', 2 * HD_SCALE, true, true);\n        \n        this.gameObject.add(this.text);\n        this.deactivate();\n    }\n    \n    reset(): void {\n        if (this.tween) {\n            this.tween.stop();\n            this.tween = undefined;\n        }\n        this.gameObject.setScale(1);\n        this.gameObject.setAlpha(1);\n        this.gameObject.setPosition(0, 0);\n    }\n    \n    activate(x: number, y: number, text: string, color: number, duration: number = 1000): void {\n        this.reset();\n        this.active = true;\n        this.gameObject.setVisible(true);\n        this.gameObject.setPosition(x, y);\n        this.text.setText(text);\n        this.text.setTint(color);\n        \n        // Adjust font size based on text content - balanced for HD visibility\n        if (text.includes('PERFECT')) {\n            this.text.setFontSize(`${18 * HD_SCALE}px`);  // Largest combo\n        } else if (text.includes('AMAZING')) {\n            this.text.setFontSize(`${17 * HD_SCALE}px`);  // Large combo\n        } else if (text.includes('GREAT')) {\n            this.text.setFontSize(`${17 * HD_SCALE}px`);  // Large combo\n        } else if (text.includes('GOOD')) {\n            this.text.setFontSize(`${16 * HD_SCALE}px`);  // Medium combo\n        } else if (text.includes('CHAIN')) {\n            this.text.setFontSize(`${17 * HD_SCALE}px`);  // Large combo\n        } else if (text.includes('DROP')) {\n            this.text.setFontSize(`${16 * HD_SCALE}px`);  // Medium size\n        } else {\n            this.text.setFontSize(`${16 * HD_SCALE}px`); // Same as medium - visible for points\n        }\n        \n        // Animate\n        this.gameObject.setScale(0);\n        \n        // Pop in - balanced impact\n        const isCombo = text.includes('PERFECT') || text.includes('AMAZING') || \n                        text.includes('GREAT') || text.includes('GOOD') || \n                        text.includes('CHAIN');\n        const targetScale = isCombo ? 1.1 : 1.0;\n        \n        this.scene.tweens.add({\n            targets: this.gameObject,\n            scale: { from: 0, to: targetScale },\n            duration: 250,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                // Settle to final size\n                this.scene.tweens.add({\n                    targets: this.gameObject,\n                    scale: 1.0,\n                    duration: 100,\n                    ease: 'Sine.easeInOut'\n                });\n            }\n        });\n        \n        // Float up and fade\n        this.tween = this.scene.tweens.add({\n            targets: this.gameObject,\n            y: y - 60,\n            alpha: 0,\n            duration: duration,\n            delay: 300,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                this.deactivate();\n            }\n        });\n    }\n    \n    deactivate(): void {\n        this.active = false;\n        this.gameObject.setVisible(false);\n        this.reset();\n    }\n}\n\n// Particle burst effect\nclass ParticleBurstEffect implements IPoolableEffect {\n    type = EffectType.PARTICLE_BURST;\n    active = false;\n    gameObject: Phaser.GameObjects.Container;\n    private scene: Scene;\n    private particles: Phaser.GameObjects.Arc[] = [];\n    private tweens: Phaser.Tweens.Tween[] = [];\n    private readonly MAX_PARTICLES = 30;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.gameObject = scene.add.container(0, 0);\n        this.gameObject.setDepth(1150);\n        \n        // Pre-create particles\n        for (let i = 0; i < this.MAX_PARTICLES; i++) {\n            const particle = scene.add.circle(0, 0, 3, 0xFFFFFF);\n            particle.setVisible(false);\n            this.particles.push(particle);\n            this.gameObject.add(particle);\n        }\n        \n        this.deactivate();\n    }\n    \n    reset(): void {\n        this.tweens.forEach(tween => tween.stop());\n        this.tweens = [];\n        this.particles.forEach(p => {\n            p.setVisible(false);\n            p.setPosition(0, 0);\n            p.setScale(1);\n            p.setAlpha(1);\n        });\n    }\n    \n    activate(x: number, y: number, color: number, particleCount: number = 20, intensity: number = 1): void {\n        this.reset();\n        this.active = true;\n        this.gameObject.setVisible(true);\n        this.gameObject.setPosition(x, y);\n        \n        const count = Math.min(particleCount, this.MAX_PARTICLES);\n        const speedBase = 100 * intensity;\n        \n        for (let i = 0; i < count; i++) {\n            const particle = this.particles[i];\n            particle.setVisible(true);\n            particle.setFillStyle(color);\n            particle.setRadius(Phaser.Math.Between(2, 4));\n            \n            const angle = (Math.PI * 2 * i) / count;\n            const speed = Phaser.Math.Between(speedBase * 0.5, speedBase * 1.5);\n            \n            const tween = this.scene.tweens.add({\n                targets: particle,\n                x: Math.cos(angle) * speed,\n                y: Math.sin(angle) * speed,\n                alpha: 0,\n                scale: 0,\n                duration: Phaser.Math.Between(400, 800),\n                ease: 'Power2.easeOut',\n                delay: i * 5,\n                onComplete: () => {\n                    particle.setVisible(false);\n                    if (i === count - 1) {\n                        this.deactivate();\n                    }\n                }\n            });\n            \n            this.tweens.push(tween);\n        }\n    }\n    \n    deactivate(): void {\n        this.active = false;\n        this.gameObject.setVisible(false);\n        this.reset();\n    }\n}\n\n// Ring explosion effect\nclass RingExplosionEffect implements IPoolableEffect {\n    type = EffectType.RING_EXPLOSION;\n    active = false;\n    gameObject: Phaser.GameObjects.Graphics;\n    private scene: Scene;\n    private tween?: Phaser.Tweens.Tween;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.gameObject = scene.add.graphics();\n        this.gameObject.setDepth(1049);\n        this.deactivate();\n    }\n    \n    reset(): void {\n        if (this.tween) {\n            this.tween.stop();\n            this.tween = undefined;\n        }\n        this.gameObject.clear();\n        this.gameObject.setScale(1);\n        this.gameObject.setAlpha(1);\n    }\n    \n    activate(x: number, y: number, color: number, size: number = 30): void {\n        this.reset();\n        this.active = true;\n        this.gameObject.setVisible(true);\n        this.gameObject.setPosition(x, y);\n        \n        this.gameObject.lineStyle(2 * HD_SCALE, color, 1);\n        this.gameObject.strokeCircle(0, 0, size);\n        this.gameObject.setScale(0);\n        \n        this.tween = this.scene.tweens.add({\n            targets: this.gameObject,\n            scale: 3,\n            alpha: 0,\n            duration: 600,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                this.deactivate();\n            }\n        });\n    }\n    \n    deactivate(): void {\n        this.active = false;\n        this.gameObject.setVisible(false);\n        this.reset();\n    }\n}\n\n// Main Effect Pool Manager\nexport class EffectPool {\n    private scene: Scene;\n    private pools: Map<EffectType, IPoolableEffect[]> = new Map();\n    private activeEffects: IPoolableEffect[] = [];\n    \n    // Pool sizes\n    private readonly POOL_SIZES = {\n        [EffectType.FLOATING_TEXT]: 20,\n        [EffectType.PARTICLE_BURST]: 10,\n        [EffectType.RING_EXPLOSION]: 8,\n        [EffectType.STAR_BURST]: 6,\n        [EffectType.COMBO_DISPLAY]: 10\n    };\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.initializePools();\n    }\n    \n    private initializePools(): void {\n        // Initialize floating text pool\n        this.createPool(EffectType.FLOATING_TEXT, () => new FloatingTextEffect(this.scene));\n        \n        // Initialize particle burst pool\n        this.createPool(EffectType.PARTICLE_BURST, () => new ParticleBurstEffect(this.scene));\n        \n        // Initialize ring explosion pool\n        this.createPool(EffectType.RING_EXPLOSION, () => new RingExplosionEffect(this.scene));\n    }\n    \n    private createPool(type: EffectType, factory: () => IPoolableEffect): void {\n        const pool: IPoolableEffect[] = [];\n        const size = this.POOL_SIZES[type] || 10;\n        \n        for (let i = 0; i < size; i++) {\n            pool.push(factory());\n        }\n        \n        this.pools.set(type, pool);\n    }\n    \n    public getEffect(type: EffectType): IPoolableEffect | null {\n        const pool = this.pools.get(type);\n        if (!pool) return null;\n        \n        // Find inactive effect\n        for (const effect of pool) {\n            if (!effect.active) {\n                this.activeEffects.push(effect);\n                return effect;\n            }\n        }\n        \n        // All effects in use, reuse the oldest one\n        const oldest = pool[0];\n        oldest.deactivate();\n        this.activeEffects.push(oldest);\n        return oldest;\n    }\n    \n    public showFloatingText(x: number, y: number, text: string, color: number = 0xFFD700, duration: number = 1000): void {\n        const effect = this.getEffect(EffectType.FLOATING_TEXT) as FloatingTextEffect;\n        if (effect) {\n            effect.activate(x, y, text, color, duration);\n        }\n    }\n    \n    public showParticleBurst(x: number, y: number, color: number, particleCount: number = 20, intensity: number = 1): void {\n        const effect = this.getEffect(EffectType.PARTICLE_BURST) as ParticleBurstEffect;\n        if (effect) {\n            effect.activate(x, y, color, particleCount, intensity);\n        }\n    }\n    \n    public showRingExplosion(x: number, y: number, color: number, size: number = 30): void {\n        const effect = this.getEffect(EffectType.RING_EXPLOSION) as RingExplosionEffect;\n        if (effect) {\n            effect.activate(x, y, color, size);\n        }\n    }\n    \n    public showComboEffect(x: number, y: number, comboLevel: number, score: number, color: number): void {\n        // Show multiple effects based on combo level\n        this.showFloatingText(x, y - 20, `+${score}`, color);\n        \n        if (comboLevel >= 2) {\n            this.showParticleBurst(x, y, color, 10 * comboLevel, comboLevel * 0.5);\n        }\n        \n        if (comboLevel >= 4) {\n            this.showRingExplosion(x, y, color, 20 + comboLevel * 5);\n        }\n    }\n    \n    public update(delta: number): void {\n        // Update active effects that need per-frame updates\n        this.activeEffects = this.activeEffects.filter(effect => {\n            if (effect.active && effect.update) {\n                effect.update(delta);\n            }\n            return effect.active;\n        });\n    }\n    \n    public reset(): void {\n        // Deactivate all effects\n        this.pools.forEach(pool => {\n            pool.forEach(effect => effect.deactivate());\n        });\n        this.activeEffects = [];\n    }\n    \n    public destroy(): void {\n        this.reset();\n        \n        // Destroy all game objects\n        this.pools.forEach(pool => {\n            pool.forEach(effect => {\n                if (effect.gameObject) {\n                    effect.gameObject.destroy();\n                }\n            });\n        });\n        \n        this.pools.clear();\n    }\n}","import { Scene } from 'phaser';\nimport { EffectPool } from './EffectPool';\nimport { ScoreResult } from './ScoreEventManager';\n\ninterface FeedbackQueueItem {\n    result: ScoreResult;\n    position: { x: number; y: number };\n    timestamp: number;\n}\n\ninterface ActiveFeedback {\n    position: { x: number; y: number };\n    endTime: number;\n}\n\nexport class UnifiedFeedbackSystem {\n    private scene: Scene;\n    private effectPool: EffectPool;\n    private feedbackQueue: FeedbackQueueItem[] = [];\n    private activeFeedbacks: ActiveFeedback[] = [];\n    private processing: boolean = false;\n    \n    // Spacing configuration - tighter for mobile screens\n    private readonly MIN_VERTICAL_SPACING = 35;\n    private readonly MIN_HORIZONTAL_SPACING = 50;\n    private readonly FEEDBACK_DURATION = 1500;\n    private readonly MAX_QUEUE_SIZE = 30;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.effectPool = new EffectPool(scene);\n        \n        // Start processing queue\n        this.startProcessing();\n    }\n    \n    private startProcessing(): void {\n        this.scene.time.addEvent({\n            delay: 16, // ~60fps\n            callback: this.processQueue,\n            callbackScope: this,\n            loop: true\n        });\n    }\n    \n    public queueFeedback(result: ScoreResult, position: { x: number; y: number }): void {\n        // Add to queue\n        this.feedbackQueue.push({\n            result,\n            position,\n            timestamp: Date.now()\n        });\n        \n        // Limit queue size\n        if (this.feedbackQueue.length > this.MAX_QUEUE_SIZE) {\n            this.feedbackQueue.shift();\n        }\n    }\n    \n    private processQueue(): void {\n        if (this.processing || this.feedbackQueue.length === 0) return;\n        \n        this.processing = true;\n        \n        // Clean up expired active feedbacks\n        const now = Date.now();\n        this.activeFeedbacks = this.activeFeedbacks.filter(f => f.endTime > now);\n        \n        // Process up to 3 feedbacks per frame\n        const itemsToProcess = Math.min(3, this.feedbackQueue.length);\n        \n        for (let i = 0; i < itemsToProcess; i++) {\n            const item = this.feedbackQueue.shift();\n            if (!item) continue;\n            \n            this.showFeedback(item);\n        }\n        \n        this.processing = false;\n    }\n    \n    private showFeedback(item: FeedbackQueueItem): void {\n        const { result, position } = item;\n        \n        // Calculate offset to prevent overlapping\n        const offset = this.calculateOffset(position);\n        const finalPosition = {\n            x: position.x + offset.x,\n            y: position.y + offset.y\n        };\n        \n        // Add to active feedbacks\n        this.activeFeedbacks.push({\n            position: finalPosition,\n            endTime: Date.now() + this.FEEDBACK_DURATION\n        });\n        \n        // Show effects based on visual effect level\n        this.showEffectsForLevel(result, finalPosition);\n    }\n    \n    private calculateOffset(position: { x: number; y: number }): { x: number; y: number } {\n        let offsetX = 0;\n        let offsetY = 0;\n        let conflictCount = 0;\n        \n        // Check for nearby active feedbacks\n        for (const active of this.activeFeedbacks) {\n            const dx = Math.abs(position.x - active.position.x);\n            const dy = Math.abs(position.y - active.position.y);\n            \n            // If too close, calculate offset\n            if (dx < this.MIN_HORIZONTAL_SPACING && dy < this.MIN_VERTICAL_SPACING) {\n                conflictCount++;\n                \n                // Alternate between up and down offsets for better distribution\n                if (conflictCount % 2 === 0) {\n                    offsetY -= this.MIN_VERTICAL_SPACING;\n                } else {\n                    offsetY += this.MIN_VERTICAL_SPACING;\n                }\n                \n                // Add slight horizontal offset for visual variety\n                offsetX = (conflictCount % 3 - 1) * 20;\n            }\n        }\n        \n        return { x: offsetX, y: offsetY };\n    }\n    \n    private showEffectsForLevel(result: ScoreResult, position: { x: number; y: number }): void {\n        const { visualEffectLevel, displayText, color, finalScore } = result;\n        \n        // Always show score text - optimized duration for mobile\n        this.effectPool.showFloatingText(\n            position.x,\n            position.y,\n            displayText,\n            color,\n            800 + (visualEffectLevel * 150) // Shorter duration for mobile readability\n        );\n        \n        // Add effects based on level\n        switch (visualEffectLevel) {\n            case 1: // Basic match (3 bubbles)\n                // Enhanced subtle effect with small pop and sparkle\n                this.effectPool.showParticleBurst(position.x, position.y, color, 6, 0.4);\n                this.createSparkleEffect(position.x, position.y, color, 3);\n                this.createPopEffect(position.x, position.y, color, 0.8);\n                break;\n                \n            case 2: // Small combo (4 bubbles) - \"GOOD!\"\n                this.effectPool.showParticleBurst(position.x, position.y, color, 12, 0.6);\n                this.createSparkleEffect(position.x, position.y, color, 5);\n                this.createPopEffect(position.x, position.y, color, 1.0);\n                this.addScreenShake(30, 0.001);\n                break;\n                \n            case 3: // Medium combo (5 bubbles) - \"GREAT!\"\n                this.effectPool.showParticleBurst(position.x, position.y, color, 25, 0.9);\n                this.effectPool.showRingExplosion(position.x, position.y, color, 20);\n                this.createSparkleEffect(position.x, position.y, color, 8);\n                this.addScreenShake(80, 0.002);\n                break;\n                \n            case 4: // Large combo (6 bubbles) - \"AMAZING!\"\n                this.effectPool.showParticleBurst(position.x, position.y, color, 40, 1.2);\n                this.effectPool.showRingExplosion(position.x, position.y, color, 30);\n                this.createSparkleEffect(position.x, position.y, color, 12);\n                this.addScreenShake(120, 0.004);\n                this.addCameraFlash(40, color);\n                break;\n                \n            case 5: // Mega combo (7+ bubbles) - \"PERFECT!\"\n                // Epic effects\n                this.effectPool.showParticleBurst(position.x, position.y, color, 60, 1.4);\n                this.effectPool.showRingExplosion(position.x, position.y, color, 40);\n                this.createFireEffect(position.x, position.y, color);\n                this.createSparkleEffect(position.x, position.y, color, 20);\n                this.addScreenShake(180, 0.006);\n                this.addCameraFlash(80, color);\n                break;\n        }\n        \n        // Don't show multiplier text separately - it's now part of the main text\n    }\n    \n    private createSparkleEffect(x: number, y: number, color: number, count: number): void {\n        // Create sparkle/star effects for polish\n        for (let i = 0; i < count; i++) {\n            const star = this.scene.add.star(\n                x + Phaser.Math.Between(-20, 20),\n                y + Phaser.Math.Between(-20, 20),\n                4, 2, 4,\n                color\n            );\n            star.setDepth(1150);\n            star.setScale(0);\n            star.setAlpha(0.8);\n            \n            // Animate sparkle\n            this.scene.tweens.add({\n                targets: star,\n                scale: { from: 0, to: Phaser.Math.FloatBetween(0.3, 0.6) },\n                alpha: { from: 0.8, to: 0 },\n                angle: 360,\n                duration: Phaser.Math.Between(600, 900),\n                delay: i * 50,\n                ease: 'Sine.easeOut',\n                onComplete: () => {\n                    star.destroy();\n                }\n            });\n        }\n    }\n    \n    private createPopEffect(x: number, y: number, color: number, scale: number): void {\n        // Create a subtle pop effect\n        const pop = this.scene.add.circle(x, y, 15, color, 0.3);\n        pop.setDepth(1140);\n        pop.setScale(0);\n        pop.setBlendMode(Phaser.BlendModes.ADD);\n        \n        this.scene.tweens.add({\n            targets: pop,\n            scale: scale,\n            alpha: 0,\n            duration: 300,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                pop.destroy();\n            }\n        });\n    }\n    \n    private createFireEffect(x: number, y: number, color: number): void {\n        // Create dramatic fire effect for mega combos\n        const particleCount = 30;\n        \n        for (let i = 0; i < particleCount; i++) {\n            const angle = (Math.PI * 2 * i) / particleCount;\n            const speed = Phaser.Math.Between(50, 150);\n            \n            const flame = this.scene.add.circle(\n                x + Math.cos(angle) * 10,\n                y + Math.sin(angle) * 10,\n                Phaser.Math.Between(3, 6),\n                color\n            );\n            flame.setDepth(1051);\n            flame.setBlendMode(Phaser.BlendModes.ADD);\n            \n            const targetX = x + Math.cos(angle) * speed;\n            const targetY = y + Math.sin(angle) * speed - Phaser.Math.Between(20, 60);\n            \n            this.scene.tweens.add({\n                targets: flame,\n                x: targetX,\n                y: targetY,\n                alpha: { from: 1, to: 0 },\n                scale: { from: 1.5, to: 0 },\n                duration: Phaser.Math.Between(600, 1000),\n                delay: i * 10,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    flame.destroy();\n                }\n            });\n        }\n    }\n    \n    private addScreenShake(duration: number, intensity: number): void {\n        this.scene.cameras.main.shake(duration, intensity);\n    }\n    \n    private addCameraFlash(duration: number, color: number): void {\n        // Convert color to RGB\n        const colorObj = Phaser.Display.Color.IntegerToColor(color);\n        this.scene.cameras.main.flash(\n            duration,\n            colorObj.red,\n            colorObj.green,\n            colorObj.blue,\n            false\n        );\n    }\n    \n    public update(delta: number): void {\n        this.effectPool.update(delta);\n    }\n    \n    public reset(): void {\n        this.feedbackQueue = [];\n        this.activeFeedbacks = [];\n        this.effectPool.reset();\n    }\n    \n    public destroy(): void {\n        this.reset();\n        this.effectPool.destroy();\n    }\n}","import { Scene } from 'phaser';\nimport { PowerUpType } from './PowerUpManager';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\n\nexport enum AimingMode {\n    NORMAL = 'crosshair',\n    RAINBOW = 'rainbow_sphere',\n    LASER = 'extended_line',\n    BOMB_NORMAL = 'explosion_radius',\n    BOMB_BALLISTIC = 'ballistic_arc',\n    LIGHTNING = 'selection_cursor',\n    FREEZE = 'snowflake_area',\n    MULTI = 'triple_arrow'\n}\n\nexport interface TargetingInfo {\n    mode: AimingMode;\n    position: { x: number; y: number };\n    angle?: number;\n    radius?: number;\n    trajectory?: Phaser.Geom.Point[];\n}\n\n/**\n * Manages different aiming modes for power-ups\n */\nexport class AimingModeSystem {\n    private scene: Scene;\n    private currentMode: AimingMode = AimingMode.NORMAL;\n    private aimingGraphics: Phaser.GameObjects.Graphics;\n    private trajectoryLine?: Phaser.GameObjects.Graphics;\n    private cursorSprite?: Phaser.GameObjects.Image;\n    private modeIndicator?: Phaser.GameObjects.Container;\n    private activePowerUp?: PowerUpType;\n    \n    // Trajectory calculation\n    private trajectoryPoints: Phaser.Geom.Point[] = [];\n    private readonly MAX_BOUNCES = 3;\n    private readonly TRAJECTORY_STEPS = 50;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        \n        // Create graphics layers but keep them hidden by default\n        this.aimingGraphics = scene.add.graphics();\n        this.aimingGraphics.setDepth(Z_LAYERS.UI);\n        this.aimingGraphics.setVisible(false); // Hidden by default\n        \n        this.trajectoryLine = scene.add.graphics();\n        this.trajectoryLine.setDepth(Z_LAYERS.UI - 1);\n        this.trajectoryLine.setVisible(false); // Hidden by default\n    }\n    \n    /**\n     * Set the aiming mode based on power-up type\n     */\n    public setMode(mode: AimingMode, powerUp?: PowerUpType): void {\n        this.currentMode = mode;\n        this.activePowerUp = powerUp;\n        \n        // Clear previous graphics\n        this.clearGraphics();\n        \n        // Show/hide graphics based on mode\n        if (mode !== AimingMode.NORMAL) {\n            this.aimingGraphics.setVisible(true);\n            this.trajectoryLine?.setVisible(true);\n        } else {\n            this.aimingGraphics.setVisible(false);\n            this.trajectoryLine?.setVisible(false);\n        }\n        \n        // Create mode-specific indicator\n        this.createModeIndicator();\n        \n        // Update cursor style\n        this.updateCursorStyle();\n    }\n    \n    /**\n     * Update aiming graphics based on pointer position\n     */\n    public updateAiming(pointerX: number, pointerY: number, launcherX: number, launcherY: number): void {\n        this.clearGraphics();\n        \n        switch (this.currentMode) {\n            case AimingMode.NORMAL:\n                this.drawNormalCrosshair(pointerX, pointerY);\n                this.drawBasicTrajectory(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.RAINBOW:\n                this.drawRainbowCrosshair(pointerX, pointerY);\n                this.drawBasicTrajectory(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.LASER:\n                this.drawLaserSight(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.BOMB_NORMAL:\n                this.drawBombRadius(pointerX, pointerY);\n                this.drawBasicTrajectory(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.BOMB_BALLISTIC:\n                this.drawBallisticArc(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.LIGHTNING:\n                this.drawSelectionCursor(pointerX, pointerY);\n                break;\n                \n            case AimingMode.FREEZE:\n                this.drawFreezeArea(pointerX, pointerY);\n                break;\n                \n            case AimingMode.MULTI:\n                this.drawTripleArrow(launcherX, launcherY, pointerX, pointerY);\n                break;\n        }\n    }\n    \n    private drawNormalCrosshair(x: number, y: number): void {\n        this.aimingGraphics.lineStyle(2, 0xFFFFFF, 0.8);\n        \n        // Draw crosshair\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x - 10, y);\n        this.aimingGraphics.lineTo(x + 10, y);\n        this.aimingGraphics.moveTo(x, y - 10);\n        this.aimingGraphics.lineTo(x, y + 10);\n        this.aimingGraphics.strokePath();\n        \n        // Draw circle\n        this.aimingGraphics.strokeCircle(x, y, 15);\n    }\n    \n    private drawRainbowCrosshair(x: number, y: number): void {\n        // Draw rainbow-colored crosshair\n        const colors = [0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF];\n        const segments = 6;\n        \n        for (let i = 0; i < segments; i++) {\n            const angle = (i / segments) * Math.PI * 2;\n            const nextAngle = ((i + 1) / segments) * Math.PI * 2;\n            \n            this.aimingGraphics.lineStyle(3, colors[i], 0.8);\n            this.aimingGraphics.beginPath();\n            this.aimingGraphics.arc(x, y, 20, angle, nextAngle);\n            this.aimingGraphics.strokePath();\n        }\n        \n        // Center dot\n        this.aimingGraphics.fillStyle(0xFFFFFF, 1);\n        this.aimingGraphics.fillCircle(x, y, 3);\n    }\n    \n    private drawLaserSight(launcherX: number, launcherY: number, targetX: number, targetY: number): void {\n        // Calculate extended trajectory with bounces\n        this.calculateTrajectory(launcherX, launcherY, targetX, targetY, true);\n        \n        // Draw extended laser line\n        this.trajectoryLine!.lineStyle(3, 0xFF0000, 1);\n        this.trajectoryLine!.lineBetween(\n            this.trajectoryPoints[0].x,\n            this.trajectoryPoints[0].y,\n            this.trajectoryPoints[0].x,\n            this.trajectoryPoints[0].y\n        );\n        \n        // Animated laser effect\n        const time = Date.now() * 0.001;\n        \n        for (let i = 0; i < this.trajectoryPoints.length - 1; i++) {\n            const alpha = 1 - (i / this.trajectoryPoints.length) * 0.5;\n            const width = 3 - (i / this.trajectoryPoints.length) * 2;\n            \n            // Pulsing effect\n            const pulse = Math.sin(time * 3 + i * 0.2) * 0.3 + 0.7;\n            \n            this.trajectoryLine!.lineStyle(width, 0xFF0000, alpha * pulse);\n            this.trajectoryLine!.lineBetween(\n                this.trajectoryPoints[i].x,\n                this.trajectoryPoints[i].y,\n                this.trajectoryPoints[i + 1].x,\n                this.trajectoryPoints[i + 1].y\n            );\n        }\n        \n        // Draw laser dot at end\n        const lastPoint = this.trajectoryPoints[this.trajectoryPoints.length - 1];\n        this.aimingGraphics.fillStyle(0xFF0000, 1);\n        this.aimingGraphics.fillCircle(lastPoint.x, lastPoint.y, 5);\n    }\n    \n    private drawBombRadius(x: number, y: number): void {\n        // Draw explosion radius preview\n        const radius = 100; // 7-bubble radius approximation\n        \n        // Outer ring\n        this.aimingGraphics.lineStyle(2, 0xFF4500, 0.3);\n        this.aimingGraphics.fillStyle(0xFF4500, 0.1);\n        this.aimingGraphics.fillCircle(x, y, radius);\n        this.aimingGraphics.strokeCircle(x, y, radius);\n        \n        // Inner rings for impact visualization\n        this.aimingGraphics.lineStyle(1, 0xFF6347, 0.5);\n        this.aimingGraphics.strokeCircle(x, y, radius * 0.66);\n        this.aimingGraphics.strokeCircle(x, y, radius * 0.33);\n        \n        // Center explosion point\n        this.aimingGraphics.fillStyle(0xFF0000, 1);\n        this.aimingGraphics.fillCircle(x, y, 5);\n        \n        // Draw bomb icon\n        const bomb = '💣';\n        if (!this.cursorSprite) {\n            const text = this.scene.add.text(x, y - radius - 20, bomb, {\n                fontSize: '24px'\n            });\n            text.setOrigin(0.5);\n            text.setDepth(Z_LAYERS.UI + 1);\n            \n            // Clean up after frame\n            this.scene.time.delayedCall(50, () => text.destroy());\n        }\n    }\n    \n    private drawBallisticArc(launcherX: number, launcherY: number, targetX: number, targetY: number): void {\n        // Calculate parabolic trajectory to castle\n        const points: Phaser.Geom.Point[] = [];\n        const steps = 30;\n        const maxHeight = Math.min(launcherY, targetY) - 100; // Peak height\n        \n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            \n            // Parabolic interpolation\n            const x = Phaser.Math.Linear(launcherX, targetX, t);\n            const baseY = Phaser.Math.Linear(launcherY, targetY, t);\n            \n            // Add parabolic arc\n            const arc = Math.sin(t * Math.PI) * (launcherY - maxHeight);\n            const y = baseY - arc;\n            \n            points.push(new Phaser.Geom.Point(x, y));\n        }\n        \n        // Draw ballistic path\n        this.trajectoryLine!.lineStyle(3, 0xFF0000, 0.5);\n        \n        for (let i = 0; i < points.length - 1; i++) {\n            const alpha = 0.5 + (i / points.length) * 0.5;\n            this.trajectoryLine!.lineStyle(2, 0xFF4500, alpha);\n            this.trajectoryLine!.lineBetween(\n                points[i].x, points[i].y,\n                points[i + 1].x, points[i + 1].y\n            );\n        }\n        \n        // Draw impact zone at target\n        this.aimingGraphics.fillStyle(0xFF0000, 0.3);\n        this.aimingGraphics.fillCircle(targetX, targetY, 30);\n        \n        // Draw castle target indicator\n        this.aimingGraphics.lineStyle(3, 0xFF0000, 1);\n        this.aimingGraphics.strokeCircle(targetX, targetY, 30);\n    }\n    \n    private drawSelectionCursor(x: number, y: number): void {\n        // Draw selection cursor for lightning\n        const size = 20;\n        \n        // Animated rotation\n        const angle = Date.now() * 0.002;\n        \n        // Draw rotating brackets\n        this.aimingGraphics.lineStyle(3, 0xFFFF00, 1);\n        \n        // Top-left bracket\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x - size, y - size + 5);\n        this.aimingGraphics.lineTo(x - size, y - size);\n        this.aimingGraphics.lineTo(x - size + 5, y - size);\n        this.aimingGraphics.strokePath();\n        \n        // Top-right bracket\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x + size - 5, y - size);\n        this.aimingGraphics.lineTo(x + size, y - size);\n        this.aimingGraphics.lineTo(x + size, y - size + 5);\n        this.aimingGraphics.strokePath();\n        \n        // Bottom-left bracket\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x - size, y + size - 5);\n        this.aimingGraphics.lineTo(x - size, y + size);\n        this.aimingGraphics.lineTo(x - size + 5, y + size);\n        this.aimingGraphics.strokePath();\n        \n        // Bottom-right bracket\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x + size - 5, y + size);\n        this.aimingGraphics.lineTo(x + size, y + size);\n        this.aimingGraphics.lineTo(x + size, y + size - 5);\n        this.aimingGraphics.strokePath();\n        \n        // Center lightning bolt\n        this.aimingGraphics.lineStyle(2, 0xFFFF00, 1);\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x - 5, y - 10);\n        this.aimingGraphics.lineTo(x + 2, y);\n        this.aimingGraphics.lineTo(x - 2, y);\n        this.aimingGraphics.lineTo(x + 5, y + 10);\n        this.aimingGraphics.strokePath();\n    }\n    \n    private drawFreezeArea(x: number, y: number): void {\n        // Draw freeze area indicator\n        const radius = 150;\n        \n        // Frost effect\n        this.aimingGraphics.fillStyle(0x87CEEB, 0.2);\n        this.aimingGraphics.fillCircle(x, y, radius);\n        \n        // Snowflake patterns\n        const snowflakeCount = 6;\n        for (let i = 0; i < snowflakeCount; i++) {\n            const angle = (i / snowflakeCount) * Math.PI * 2;\n            const sx = x + Math.cos(angle) * radius * 0.7;\n            const sy = y + Math.sin(angle) * radius * 0.7;\n            \n            // Draw simple snowflake\n            this.aimingGraphics.lineStyle(2, 0xFFFFFF, 0.8);\n            this.aimingGraphics.beginPath();\n            \n            // Six-pointed snowflake\n            for (let j = 0; j < 6; j++) {\n                const a = (j / 6) * Math.PI * 2;\n                this.aimingGraphics.moveTo(sx, sy);\n                this.aimingGraphics.lineTo(\n                    sx + Math.cos(a) * 10,\n                    sy + Math.sin(a) * 10\n                );\n            }\n            this.aimingGraphics.strokePath();\n        }\n    }\n    \n    private drawTripleArrow(launcherX: number, launcherY: number, targetX: number, targetY: number): void {\n        // Draw three trajectory lines for multi-shot\n        const baseAngle = Math.atan2(targetY - launcherY, targetX - launcherX);\n        const angles = [-15, 0, 15]; // Degrees\n        \n        angles.forEach((angleDiff, index) => {\n            const angle = baseAngle + Phaser.Math.DegToRad(angleDiff);\n            const distance = 200;\n            const endX = launcherX + Math.cos(angle) * distance;\n            const endY = launcherY + Math.sin(angle) * distance;\n            \n            // Different colors for each trajectory\n            const colors = [0xFF6B6B, 0xFFFFFF, 0x6B6BFF];\n            this.trajectoryLine!.lineStyle(2, colors[index], 0.6);\n            this.trajectoryLine!.lineBetween(launcherX, launcherY, endX, endY);\n            \n            // Arrow heads\n            this.drawArrowHead(endX, endY, angle, colors[index]);\n        });\n    }\n    \n    private drawArrowHead(x: number, y: number, angle: number, color: number): void {\n        const size = 10;\n        const angleLeft = angle - Phaser.Math.DegToRad(150);\n        const angleRight = angle + Phaser.Math.DegToRad(150);\n        \n        this.aimingGraphics.lineStyle(2, color, 0.8);\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x, y);\n        this.aimingGraphics.lineTo(x + Math.cos(angleLeft) * size, y + Math.sin(angleLeft) * size);\n        this.aimingGraphics.moveTo(x, y);\n        this.aimingGraphics.lineTo(x + Math.cos(angleRight) * size, y + Math.sin(angleRight) * size);\n        this.aimingGraphics.strokePath();\n    }\n    \n    private drawBasicTrajectory(launcherX: number, launcherY: number, targetX: number, targetY: number): void {\n        // Basic dotted line trajectory\n        this.trajectoryLine!.lineStyle(1, 0xFFFFFF, 0.5);\n        \n        const distance = Phaser.Math.Distance.Between(launcherX, launcherY, targetX, targetY);\n        const steps = Math.floor(distance / 20);\n        \n        for (let i = 0; i < steps; i += 2) {\n            const t1 = i / steps;\n            const t2 = Math.min((i + 1) / steps, 1);\n            \n            const x1 = Phaser.Math.Linear(launcherX, targetX, t1);\n            const y1 = Phaser.Math.Linear(launcherY, targetY, t1);\n            const x2 = Phaser.Math.Linear(launcherX, targetX, t2);\n            const y2 = Phaser.Math.Linear(launcherY, targetY, t2);\n            \n            this.trajectoryLine!.lineBetween(x1, y1, x2, y2);\n        }\n    }\n    \n    private calculateTrajectory(startX: number, startY: number, targetX: number, targetY: number, extended: boolean = false): void {\n        this.trajectoryPoints = [];\n        \n        // Calculate initial direction\n        const angle = Math.atan2(targetY - startY, targetX - startX);\n        const speed = 10;\n        let x = startX;\n        let y = startY;\n        let vx = Math.cos(angle) * speed;\n        let vy = Math.sin(angle) * speed;\n        let bounces = 0;\n        \n        const maxSteps = extended ? 200 : 100;\n        const screenWidth = this.scene.cameras.main.width;\n        \n        for (let i = 0; i < maxSteps; i++) {\n            this.trajectoryPoints.push(new Phaser.Geom.Point(x, y));\n            \n            x += vx;\n            y += vy;\n            \n            // Check for wall bounces\n            if ((x <= 10 || x >= screenWidth - 10) && bounces < this.MAX_BOUNCES) {\n                vx = -vx;\n                bounces++;\n            }\n            \n            // Stop at screen boundaries\n            if (y <= 0 || y >= this.scene.cameras.main.height) {\n                break;\n            }\n        }\n    }\n    \n    private createModeIndicator(): void {\n        // Clean up previous indicator\n        if (this.modeIndicator) {\n            this.modeIndicator.destroy();\n        }\n        \n        // Create mode-specific visual indicator at top of screen\n        const x = this.scene.cameras.main.centerX;\n        const y = 50;\n        \n        this.modeIndicator = this.scene.add.container(x, y);\n        this.modeIndicator.setDepth(Z_LAYERS.UI + 10);\n        \n        // Background\n        const bg = this.scene.add.graphics();\n        bg.fillStyle(0x000000, 0.7);\n        bg.fillRoundedRect(-60, -20, 120, 40, 10);\n        this.modeIndicator.add(bg);\n        \n        // Mode text\n        const modeNames: Record<AimingMode, string> = {\n            [AimingMode.NORMAL]: 'NORMAL',\n            [AimingMode.RAINBOW]: '🌈 RAINBOW',\n            [AimingMode.LASER]: '🎯 LASER',\n            [AimingMode.BOMB_NORMAL]: '💣 BOMB',\n            [AimingMode.BOMB_BALLISTIC]: '💣 BALLISTIC',\n            [AimingMode.LIGHTNING]: '⚡ LIGHTNING',\n            [AimingMode.FREEZE]: '❄️ FREEZE',\n            [AimingMode.MULTI]: '🎱 MULTI'\n        };\n        \n        const text = this.scene.add.text(0, 0, modeNames[this.currentMode], {\n            fontSize: '16px',\n            fontFamily: 'Arial Black',\n            color: '#FFFFFF'\n        });\n        text.setOrigin(0.5);\n        this.modeIndicator.add(text);\n        \n        // Fade in animation\n        this.modeIndicator.setAlpha(0);\n        this.scene.tweens.add({\n            targets: this.modeIndicator,\n            alpha: 1,\n            duration: 300,\n            ease: 'Cubic.easeOut'\n        });\n    }\n    \n    private updateCursorStyle(): void {\n        // Update HTML cursor style based on mode\n        const canvas = this.scene.game.canvas;\n        \n        switch (this.currentMode) {\n            case AimingMode.LIGHTNING:\n                canvas.style.cursor = 'crosshair';\n                break;\n            case AimingMode.BOMB_BALLISTIC:\n                canvas.style.cursor = 'crosshair';\n                break;\n            default:\n                canvas.style.cursor = 'default';\n                break;\n        }\n    }\n    \n    private clearGraphics(): void {\n        this.aimingGraphics.clear();\n        if (this.trajectoryLine) {\n            this.trajectoryLine.clear();\n        }\n    }\n    \n    public getTargetingInfo(): TargetingInfo {\n        return {\n            mode: this.currentMode,\n            position: { x: 0, y: 0 }, // Will be updated with actual pointer position\n            trajectory: this.trajectoryPoints\n        };\n    }\n    \n    public reset(): void {\n        this.setMode(AimingMode.NORMAL);\n        this.clearGraphics();\n        \n        if (this.modeIndicator) {\n            this.modeIndicator.destroy();\n            this.modeIndicator = undefined;\n        }\n    }\n    \n    public destroy(): void {\n        this.reset();\n        this.aimingGraphics.destroy();\n        \n        if (this.trajectoryLine) {\n            this.trajectoryLine.destroy();\n        }\n        \n        if (this.cursorSprite) {\n            this.cursorSprite.destroy();\n        }\n    }\n}","/*! Capacitor: https://capacitorjs.com/ - MIT License */\nvar ExceptionCode;\n(function (ExceptionCode) {\n    /**\n     * API is not implemented.\n     *\n     * This usually means the API can't be used because it is not implemented for\n     * the current platform.\n     */\n    ExceptionCode[\"Unimplemented\"] = \"UNIMPLEMENTED\";\n    /**\n     * API is not available.\n     *\n     * This means the API can't be used right now because:\n     *   - it is currently missing a prerequisite, such as network connectivity\n     *   - it requires a particular platform or browser version\n     */\n    ExceptionCode[\"Unavailable\"] = \"UNAVAILABLE\";\n})(ExceptionCode || (ExceptionCode = {}));\nclass CapacitorException extends Error {\n    constructor(message, code, data) {\n        super(message);\n        this.message = message;\n        this.code = code;\n        this.data = data;\n    }\n}\nconst getPlatformId = (win) => {\n    var _a, _b;\n    if (win === null || win === void 0 ? void 0 : win.androidBridge) {\n        return 'android';\n    }\n    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {\n        return 'ios';\n    }\n    else {\n        return 'web';\n    }\n};\n\nconst createCapacitor = (win) => {\n    const capCustomPlatform = win.CapacitorCustomPlatform || null;\n    const cap = win.Capacitor || {};\n    const Plugins = (cap.Plugins = cap.Plugins || {});\n    const getPlatform = () => {\n        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);\n    };\n    const isNativePlatform = () => getPlatform() !== 'web';\n    const isPluginAvailable = (pluginName) => {\n        const plugin = registeredPlugins.get(pluginName);\n        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {\n            // JS implementation available for the current platform.\n            return true;\n        }\n        if (getPluginHeader(pluginName)) {\n            // Native implementation available.\n            return true;\n        }\n        return false;\n    };\n    const getPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName); };\n    const handleError = (err) => win.console.error(err);\n    const registeredPlugins = new Map();\n    const registerPlugin = (pluginName, jsImplementations = {}) => {\n        const registeredPlugin = registeredPlugins.get(pluginName);\n        if (registeredPlugin) {\n            console.warn(`Capacitor plugin \"${pluginName}\" already registered. Cannot register plugins twice.`);\n            return registeredPlugin.proxy;\n        }\n        const platform = getPlatform();\n        const pluginHeader = getPluginHeader(pluginName);\n        let jsImplementation;\n        const loadPluginImplementation = async () => {\n            if (!jsImplementation && platform in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations[platform] === 'function'\n                        ? (jsImplementation = await jsImplementations[platform]())\n                        : (jsImplementation = jsImplementations[platform]);\n            }\n            else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations['web'] === 'function'\n                        ? (jsImplementation = await jsImplementations['web']())\n                        : (jsImplementation = jsImplementations['web']);\n            }\n            return jsImplementation;\n        };\n        const createPluginMethod = (impl, prop) => {\n            var _a, _b;\n            if (pluginHeader) {\n                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);\n                if (methodHeader) {\n                    if (methodHeader.rtype === 'promise') {\n                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);\n                    }\n                    else {\n                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);\n                    }\n                }\n                else if (impl) {\n                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);\n                }\n            }\n            else if (impl) {\n                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);\n            }\n            else {\n                throw new CapacitorException(`\"${pluginName}\" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n            }\n        };\n        const createPluginMethodWrapper = (prop) => {\n            let remove;\n            const wrapper = (...args) => {\n                const p = loadPluginImplementation().then((impl) => {\n                    const fn = createPluginMethod(impl, prop);\n                    if (fn) {\n                        const p = fn(...args);\n                        remove = p === null || p === void 0 ? void 0 : p.remove;\n                        return p;\n                    }\n                    else {\n                        throw new CapacitorException(`\"${pluginName}.${prop}()\" is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n                    }\n                });\n                if (prop === 'addListener') {\n                    p.remove = async () => remove();\n                }\n                return p;\n            };\n            // Some flair ✨\n            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;\n            Object.defineProperty(wrapper, 'name', {\n                value: prop,\n                writable: false,\n                configurable: false,\n            });\n            return wrapper;\n        };\n        const addListener = createPluginMethodWrapper('addListener');\n        const removeListener = createPluginMethodWrapper('removeListener');\n        const addListenerNative = (eventName, callback) => {\n            const call = addListener({ eventName }, callback);\n            const remove = async () => {\n                const callbackId = await call;\n                removeListener({\n                    eventName,\n                    callbackId,\n                }, callback);\n            };\n            const p = new Promise((resolve) => call.then(() => resolve({ remove })));\n            p.remove = async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            };\n            return p;\n        };\n        const proxy = new Proxy({}, {\n            get(_, prop) {\n                switch (prop) {\n                    // https://github.com/facebook/react/issues/20030\n                    case '$$typeof':\n                        return undefined;\n                    case 'toJSON':\n                        return () => ({});\n                    case 'addListener':\n                        return pluginHeader ? addListenerNative : addListener;\n                    case 'removeListener':\n                        return removeListener;\n                    default:\n                        return createPluginMethodWrapper(prop);\n                }\n            },\n        });\n        Plugins[pluginName] = proxy;\n        registeredPlugins.set(pluginName, {\n            name: pluginName,\n            proxy,\n            platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),\n        });\n        return proxy;\n    };\n    // Add in convertFileSrc for web, it will already be available in native context\n    if (!cap.convertFileSrc) {\n        cap.convertFileSrc = (filePath) => filePath;\n    }\n    cap.getPlatform = getPlatform;\n    cap.handleError = handleError;\n    cap.isNativePlatform = isNativePlatform;\n    cap.isPluginAvailable = isPluginAvailable;\n    cap.registerPlugin = registerPlugin;\n    cap.Exception = CapacitorException;\n    cap.DEBUG = !!cap.DEBUG;\n    cap.isLoggingEnabled = !!cap.isLoggingEnabled;\n    return cap;\n};\nconst initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));\n\nconst Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof global !== 'undefined'\n                ? global\n                : {});\nconst registerPlugin = Capacitor.registerPlugin;\n\n/**\n * Base class web plugins should extend.\n */\nclass WebPlugin {\n    constructor() {\n        this.listeners = {};\n        this.retainedEventArguments = {};\n        this.windowListeners = {};\n    }\n    addListener(eventName, listenerFunc) {\n        let firstListener = false;\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n            firstListener = true;\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        const windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        if (firstListener) {\n            this.sendRetainedArgumentsForEvent(eventName);\n        }\n        const remove = async () => this.removeListener(eventName, listenerFunc);\n        const p = Promise.resolve({ remove });\n        return p;\n    }\n    async removeAllListeners() {\n        this.listeners = {};\n        for (const listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    }\n    notifyListeners(eventName, data, retainUntilConsumed) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            if (retainUntilConsumed) {\n                let args = this.retainedEventArguments[eventName];\n                if (!args) {\n                    args = [];\n                }\n                args.push(data);\n                this.retainedEventArguments[eventName] = args;\n            }\n            return;\n        }\n        listeners.forEach((listener) => listener(data));\n    }\n    hasListeners(eventName) {\n        var _a;\n        return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);\n    }\n    registerWindowListener(windowEventName, pluginEventName) {\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName,\n            pluginEventName,\n            handler: (event) => {\n                this.notifyListeners(pluginEventName, event);\n            },\n        };\n    }\n    unimplemented(msg = 'not implemented') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);\n    }\n    unavailable(msg = 'not available') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);\n    }\n    async removeListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    }\n    addWindowListener(handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    }\n    removeWindowListener(handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    }\n    sendRetainedArgumentsForEvent(eventName) {\n        const args = this.retainedEventArguments[eventName];\n        if (!args) {\n            return;\n        }\n        delete this.retainedEventArguments[eventName];\n        args.forEach((arg) => {\n            this.notifyListeners(eventName, arg);\n        });\n    }\n}\n\nconst WebView = /*#__PURE__*/ registerPlugin('WebView');\n/******** END WEB VIEW PLUGIN ********/\n/******** COOKIES PLUGIN ********/\n/**\n * Safely web encode a string value (inspired by js-cookie)\n * @param str The string value to encode\n */\nconst encode = (str) => encodeURIComponent(str)\n    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n    .replace(/[()]/g, escape);\n/**\n * Safely web decode a string value (inspired by js-cookie)\n * @param str The string value to decode\n */\nconst decode = (str) => str.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\nclass CapacitorCookiesPluginWeb extends WebPlugin {\n    async getCookies() {\n        const cookies = document.cookie;\n        const cookieMap = {};\n        cookies.split(';').forEach((cookie) => {\n            if (cookie.length <= 0)\n                return;\n            // Replace first \"=\" with CAP_COOKIE to prevent splitting on additional \"=\"\n            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');\n            key = decode(key).trim();\n            value = decode(value).trim();\n            cookieMap[key] = value;\n        });\n        return cookieMap;\n    }\n    async setCookie(options) {\n        try {\n            // Safely Encoded Key/Value\n            const encodedKey = encode(options.key);\n            const encodedValue = encode(options.value);\n            // Clean & sanitize options\n            const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is \"; expires=\"\n            const path = (options.path || '/').replace('path=', ''); // Default is \"path=/\"\n            const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : '';\n            document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}; ${domain};`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async deleteCookie(options) {\n        try {\n            document.cookie = `${options.key}=; Max-Age=0`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearCookies() {\n        try {\n            const cookies = document.cookie.split(';') || [];\n            for (const cookie of cookies) {\n                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);\n            }\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearAllCookies() {\n        try {\n            await this.clearCookies();\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n}\nconst CapacitorCookies = registerPlugin('CapacitorCookies', {\n    web: () => new CapacitorCookiesPluginWeb(),\n});\n// UTILITY FUNCTIONS\n/**\n * Read in a Blob value and return it as a base64 string\n * @param blob The blob value to convert to a base64 string\n */\nconst readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n        const base64String = reader.result;\n        // remove prefix \"data:application/pdf;base64,\"\n        resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(blob);\n});\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach((str) => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nconst buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // If body is already a string, then pass it through as-is.\n    if (typeof options.data === 'string') {\n        output.body = options.data;\n    }\n    // Build request initializers based off of content-type\n    else if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data') || options.data instanceof FormData) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (const key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') || typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n// WEB IMPLEMENTATION\nclass CapacitorHttpPluginWeb extends WebPlugin {\n    /**\n     * Perform an Http request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async request(options) {\n        const requestInit = buildRequestInit(options, options.webFetchExtra);\n        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n        const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n        const response = await fetch(url, requestInit);\n        const contentType = response.headers.get('content-type') || '';\n        // Default to 'text' responseType so no parsing happens\n        let { responseType = 'text' } = response.ok ? options : {};\n        // If the response content-type is json, force the response to be json\n        if (contentType.includes('application/json')) {\n            responseType = 'json';\n        }\n        let data;\n        let blob;\n        switch (responseType) {\n            case 'arraybuffer':\n            case 'blob':\n                blob = await response.blob();\n                data = await readBlobAsBase64(blob);\n                break;\n            case 'json':\n                data = await response.json();\n                break;\n            case 'document':\n            case 'text':\n            default:\n                data = await response.text();\n        }\n        // Convert fetch headers to Capacitor HttpHeaders\n        const headers = {};\n        response.headers.forEach((value, key) => {\n            headers[key] = value;\n        });\n        return {\n            data,\n            headers,\n            status: response.status,\n            url: response.url,\n        };\n    }\n    /**\n     * Perform an Http GET request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async get(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n    }\n    /**\n     * Perform an Http POST request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async post(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n    }\n    /**\n     * Perform an Http PUT request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async put(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n    }\n    /**\n     * Perform an Http PATCH request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async patch(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n    }\n    /**\n     * Perform an Http DELETE request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async delete(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n    }\n}\nconst CapacitorHttp = registerPlugin('CapacitorHttp', {\n    web: () => new CapacitorHttpPluginWeb(),\n});\n/******** END HTTP PLUGIN ********/\n\nexport { Capacitor, CapacitorCookies, CapacitorException, CapacitorHttp, ExceptionCode, WebPlugin, WebView, buildRequestInit, registerPlugin };\n//# sourceMappingURL=index.js.map\n","import { Scene } from 'phaser';\nimport { PowerUpType } from './PowerUpManager';\nimport { AimingMode, AimingModeSystem } from './AimingModeSystem';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { BubbleGrid } from '@/systems/gameplay/BubbleGrid';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\n\nexport interface PowerUpContext {\n    scene: Scene;\n    launcher: Launcher;\n    opponentLauncher?: Launcher;\n    aimingMode: AimingModeSystem;\n    bubbleGrid: BubbleGrid;\n    targetMode?: 'bubbles' | 'castle';\n    shotsRemaining?: number;\n}\n\nexport interface IPowerUpEffect {\n    type: PowerUpType;\n    activate(context: PowerUpContext): void;\n    deactivate?(context: PowerUpContext): void;\n    update?(context: PowerUpContext, delta: number): void;\n}\n\n/**\n * Rainbow Power-Up: Next bubble matches any color\n */\nexport class RainbowEffect implements IPowerUpEffect {\n    type = PowerUpType.RAINBOW;\n    private rainbowBubble?: Bubble;\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set aiming mode to rainbow\n        context.aimingMode.setMode(AimingMode.RAINBOW, this.type);\n        \n        // Visual feedback\n        const rainbowText = context.scene.add.text(\n            context.scene.cameras.main.centerX,\n            context.scene.cameras.main.centerY,\n            '🌈 RAINBOW BUBBLE!',\n            {\n                fontSize: '28px',\n                fontFamily: 'Arial Black',\n                color: '#FF69B4',\n                stroke: '#000000',\n                strokeThickness: 3\n            }\n        );\n        rainbowText.setOrigin(0.5);\n        rainbowText.setDepth(1000);\n        \n        // Animate text\n        context.scene.tweens.add({\n            targets: rainbowText,\n            scale: { from: 0, to: 1.2 },\n            alpha: { from: 1, to: 0 },\n            y: rainbowText.y - 50,\n            duration: 1500,\n            ease: 'Power2',\n            onComplete: () => rainbowText.destroy()\n        });\n        \n        // Single shot power-up\n        context.shotsRemaining = 1;\n    }\n    \n    private applyRainbowEffect(bubble: Bubble): void {\n        // Create rainbow shimmer\n        const shimmer = bubble.scene.add.graphics();\n        shimmer.setDepth(bubble.depth + 1);\n        \n        // Animated rainbow effect\n        bubble.scene.time.addEvent({\n            delay: 100,\n            callback: () => {\n                if (!bubble || !bubble.scene) return;\n                \n                shimmer.clear();\n                const time = Date.now() * 0.001;\n                const colors = [0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF];\n                const segments = 6;\n                \n                for (let i = 0; i < segments; i++) {\n                    const angle = (i / segments) * Math.PI * 2;\n                    const nextAngle = ((i + 1) / segments) * Math.PI * 2;\n                    const colorIndex = Math.floor((time + i) % colors.length);\n                    \n                    shimmer.lineStyle(2, colors[colorIndex], 0.8);\n                    shimmer.beginPath();\n                    shimmer.arc(bubble.x, bubble.y, 18, angle, nextAngle);\n                    shimmer.strokePath();\n                }\n            },\n            loop: true\n        });\n        \n        // Store shimmer reference for cleanup\n        // bubble.setData('rainbowShimmer', shimmer);\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        // Clean up rainbow effect\n        if (this.rainbowBubble) {\n            const shimmer = this.rainbowBubble.getData('rainbowShimmer');\n            if (shimmer) {\n                shimmer.destroy();\n            }\n            // this.rainbowBubble.setData('isRainbow', false);\n        }\n        \n        // Reset aiming mode\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Laser Sight Power-Up: Extended trajectory preview\n */\nexport class LaserSightEffect implements IPowerUpEffect {\n    type = PowerUpType.LASER;\n    private remainingShots: number = 5;\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set laser aiming mode\n        context.aimingMode.setMode(AimingMode.LASER, this.type);\n        \n        // 5 shots with enhanced aiming\n        this.remainingShots = 5;\n        context.shotsRemaining = 5;\n        \n        // Add UI indicator for remaining shots\n        this.createShotCounter(context);\n    }\n    \n    private createShotCounter(context: PowerUpContext): void {\n        const counter = context.scene.add.container(100, 100);\n        counter.setDepth(Z_LAYERS.UI + 10);\n        \n        // Background\n        const bg = context.scene.add.graphics();\n        bg.fillStyle(0x000000, 0.7);\n        bg.fillRoundedRect(-40, -20, 80, 40, 10);\n        counter.add(bg);\n        \n        // Text\n        const text = context.scene.add.text(0, 0, `🎯 ${this.remainingShots}`, {\n            fontSize: '20px',\n            fontFamily: 'Arial Black',\n            color: '#FF0000'\n        });\n        text.setOrigin(0.5);\n        counter.add(text);\n        \n        // Store reference\n        // context.launcher.setData('laserCounter', counter);\n        // context.launcher.setData('laserCounterText', text);\n    }\n    \n    update(context: PowerUpContext, delta: number): void {\n        // Update shot counter\n        const text = context.launcher.getData('laserCounterText') as Phaser.GameObjects.Text;\n        if (text && context.shotsRemaining !== undefined) {\n            text.setText(`🎯 ${context.shotsRemaining}`);\n        }\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        // Clean up UI\n        const counter = context.launcher.getData('laserCounter');\n        if (counter) {\n            counter.destroy();\n        }\n        \n        // Reset aiming\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Bomb Power-Up: Explosion or castle attack\n */\nexport class BombEffect implements IPowerUpEffect {\n    type = PowerUpType.BOMB;\n    private targetMode: 'bubbles' | 'castle' = 'bubbles';\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Check target mode\n        this.targetMode = context.targetMode || 'bubbles';\n        \n        if (this.targetMode === 'castle' && context.opponentLauncher) {\n            // Ballistic mode for castle attack\n            context.aimingMode.setMode(AimingMode.BOMB_BALLISTIC, this.type);\n            this.prepareBallistic(context);\n        } else {\n            // Normal bomb mode\n            context.aimingMode.setMode(AimingMode.BOMB_NORMAL, this.type);\n            this.prepareNormalBomb(context);\n        }\n        \n        context.shotsRemaining = 1;\n    }\n    \n    private prepareNormalBomb(context: PowerUpContext): void {\n        // Create AAA bomb ready effect with particles\n        const x = context.launcher.x;\n        const y = context.launcher.y;\n        \n        // Create glowing orb effect\n        const bombGlow = context.scene.add.graphics();\n        bombGlow.setDepth(999);\n        this.visualElements.push(bombGlow);\n        \n        // Animated glow rings\n        let glowRadius = 0;\n        const glowTimer = context.scene.time.addEvent({\n            delay: 50,\n            callback: () => {\n                bombGlow.clear();\n                \n                // Multiple rings for depth\n                for (let i = 0; i < 3; i++) {\n                    const radius = (glowRadius + i * 15) % 60;\n                    const alpha = Math.max(0, 1 - radius / 60);\n                    bombGlow.lineStyle(3, 0xFF4500, alpha * 0.5);\n                    bombGlow.strokeCircle(x, y - 30, radius);\n                }\n                \n                glowRadius = (glowRadius + 2) % 60;\n            },\n            loop: true\n        });\n        \n        // Create spark particles using circles instead of textures\n        const sparkContainer = context.scene.add.container(x, y - 30);\n        sparkContainer.setDepth(1000);\n        this.visualElements.push(sparkContainer);\n        \n        // Animated sparks\n        const sparkTimer = context.scene.time.addEvent({\n            delay: 100,\n            callback: () => {\n                for (let i = 0; i < 2; i++) {\n                    const spark = context.scene.add.circle(\n                        0, 0, \n                        Phaser.Math.Between(2, 4),\n                        Phaser.Math.RND.pick([0xFF4500, 0xFF6500, 0xFFAA00])\n                    );\n                    spark.setBlendMode(Phaser.BlendModes.ADD);\n                    sparkContainer.add(spark);\n                    \n                    const angle = Phaser.Math.Between(-110, -70) * Math.PI / 180;\n                    const speed = Phaser.Math.Between(100, 200);\n                    const vx = Math.cos(angle) * speed;\n                    const vy = Math.sin(angle) * speed;\n                    \n                    context.scene.tweens.add({\n                        targets: spark,\n                        x: spark.x + vx * 0.6,\n                        y: spark.y + vy * 0.6,\n                        scale: { from: 1, to: 0 },\n                        alpha: { from: 1, to: 0 },\n                        duration: 600,\n                        ease: 'Sine.easeOut',\n                        onComplete: () => spark.destroy()\n                    });\n                }\n            },\n            loop: true\n        });\n        (this as any).sparkTimer = sparkTimer;\n        \n        // Explosive core visualization\n        const bombCore = context.scene.add.circle(x, y - 30, 8, 0xFF4500);\n        bombCore.setDepth(1001);\n        this.visualElements.push(bombCore);\n        \n        // Pulsing core\n        context.scene.tweens.add({\n            targets: bombCore,\n            scale: { from: 0.8, to: 1.3 },\n            alpha: { from: 1, to: 0.6 },\n            duration: 400,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Text with better styling\n        const bombText = context.scene.add.text(x, y - 60, 'BOMB ARMED', {\n            fontSize: '14px',\n            fontFamily: 'Arial Black',\n            color: '#FFFFFF',\n            stroke: '#FF4500',\n            strokeThickness: 4,\n            shadow: {\n                offsetX: 2,\n                offsetY: 2,\n                color: '#000000',\n                blur: 4,\n                fill: true\n            }\n        });\n        bombText.setOrigin(0.5);\n        bombText.setDepth(1002);\n        this.visualElements.push(bombText);\n        \n        // Flash effect\n        context.scene.tweens.add({\n            targets: bombText,\n            alpha: { from: 0, to: 1 },\n            scale: { from: 1.5, to: 1 },\n            duration: 300,\n            ease: 'Back.easeOut'\n        });\n        \n        // Store timer for cleanup\n        (this as any).glowTimer = glowTimer;\n    }\n    \n    private prepareBallistic(context: PowerUpContext): void {\n        // Set launcher to ballistic mode\n        // context.launcher.setData('ballisticMode', true);\n        \n        if (context.opponentLauncher) {\n            // context.launcher.setData('ballisticTarget', {\n            //     x: context.opponentLauncher.x,\n            //     y: context.opponentLauncher.y\n            // });\n        }\n    }\n    \n    // Removed unused method - visual feedback handled differently\n    \n    private explodeAt(x: number, y: number, context: PowerUpContext): void {\n        const radius = 120;\n        \n        // AAA Explosion Effects\n        // 1. Shockwave ring\n        const shockwave = context.scene.add.graphics();\n        shockwave.setDepth(Z_LAYERS.BUBBLES_FRONT - 1);\n        \n        let shockRadius = 0;\n        const shockTimer = context.scene.time.addEvent({\n            delay: 20,\n            callback: () => {\n                shockwave.clear();\n                if (shockRadius < radius * 2) {\n                    const alpha = Math.max(0, 1 - shockRadius / (radius * 2));\n                    shockwave.lineStyle(4, 0xFFFFFF, alpha);\n                    shockwave.strokeCircle(x, y, shockRadius);\n                    shockwave.lineStyle(8, 0xFF4500, alpha * 0.5);\n                    shockwave.strokeCircle(x, y, shockRadius * 0.9);\n                    shockRadius += 8;\n                } else {\n                    shockTimer.destroy();\n                    shockwave.destroy();\n                }\n            },\n            loop: true\n        });\n        \n        // 2. Core flash\n        const flash = context.scene.add.circle(x, y, radius * 0.3, 0xFFFFFF, 1);\n        flash.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        flash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        context.scene.tweens.add({\n            targets: flash,\n            scale: { from: 0, to: 4 },\n            alpha: { from: 1, to: 0 },\n            duration: 300,\n            ease: 'Expo.easeOut',\n            onComplete: () => flash.destroy()\n        });\n        \n        // 3. Fire burst effect with circles\n        const explosionContainer = context.scene.add.container(x, y);\n        explosionContainer.setDepth(Z_LAYERS.BUBBLES_FRONT + 1);\n        \n        // Create explosion particles\n        for (let i = 0; i < 30; i++) {\n            const particle = context.scene.add.circle(\n                0, 0,\n                Phaser.Math.Between(3, 6),\n                Phaser.Math.RND.pick([0xFFFFFF, 0xFF4500, 0xFF6500, 0xFFAA00])\n            );\n            particle.setBlendMode(Phaser.BlendModes.ADD);\n            explosionContainer.add(particle);\n            \n            const angle = Phaser.Math.Between(0, 360) * Math.PI / 180;\n            const speed = Phaser.Math.Between(200, 400);\n            const vx = Math.cos(angle) * speed;\n            const vy = Math.sin(angle) * speed;\n            \n            context.scene.tweens.add({\n                targets: particle,\n                x: vx * 0.8,\n                y: vy * 0.8,\n                scale: { from: 1, to: 0 },\n                alpha: { from: 1, to: 0 },\n                duration: 800,\n                ease: 'Power3',\n                onComplete: () => particle.destroy()\n            });\n        }\n        \n        // 4. Debris effect\n        const debrisContainer = context.scene.add.container(x, y);\n        debrisContainer.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        \n        for (let i = 0; i < 15; i++) {\n            const debris = context.scene.add.rectangle(\n                0, 0,\n                Phaser.Math.Between(4, 8),\n                Phaser.Math.Between(4, 8),\n                Phaser.Math.RND.pick([0xFF4500, 0xFF6500, 0xFFAA00])\n            );\n            debrisContainer.add(debris);\n            \n            const angle = Phaser.Math.Between(-120, -60) * Math.PI / 180;\n            const speed = Phaser.Math.Between(100, 300);\n            const vx = Math.cos(angle) * speed;\n            const vy = Math.sin(angle) * speed;\n            \n            context.scene.tweens.add({\n                targets: debris,\n                x: debris.x + vx,\n                y: debris.y + vy + 400, // Gravity effect\n                scale: { from: 0.3, to: 0.1 },\n                angle: Phaser.Math.Between(0, 360),\n                duration: 1200,\n                ease: 'Quad.easeIn',\n                onComplete: () => debris.destroy()\n            });\n        }\n        \n        // 5. Smoke effect\n        const smokeContainer = context.scene.add.container(x, y);\n        smokeContainer.setDepth(Z_LAYERS.BUBBLES_FRONT - 2);\n        \n        for (let i = 0; i < 8; i++) {\n            const smoke = context.scene.add.circle(\n                Phaser.Math.Between(-10, 10),\n                Phaser.Math.Between(-10, 10),\n                Phaser.Math.Between(20, 30),\n                0x666666\n            );\n            smoke.setAlpha(0.4);\n            smokeContainer.add(smoke);\n            \n            context.scene.tweens.add({\n                targets: smoke,\n                scale: { from: 1, to: 2 },\n                alpha: 0,\n                y: smoke.y - Phaser.Math.Between(20, 50),\n                duration: 1500,\n                ease: 'Sine.easeOut',\n                onComplete: () => smoke.destroy()\n            });\n        }\n        \n        // Enhanced camera effects\n        context.scene.cameras.main.shake(300, 0.02);\n        context.scene.cameras.main.flash(100, 255, 100, 0, true);\n        \n        // Clean up containers\n        context.scene.time.delayedCall(2000, () => {\n            explosionContainer.destroy();\n            debrisContainer.destroy();\n            smokeContainer.destroy();\n        });\n        \n        // Destroy bubbles with chain reaction\n        const bubbles = context.bubbleGrid.getBubblesInRadius(x, y, radius);\n        bubbles.forEach((bubble, index) => {\n            const dist = Phaser.Math.Distance.Between(x, y, bubble.x, bubble.y);\n            const delay = (dist / radius) * 200;\n            \n            context.scene.time.delayedCall(delay, () => {\n                if (bubble && bubble.visible) {\n                    // Mini explosion per bubble\n                    const miniFlash = context.scene.add.circle(bubble.x, bubble.y, 15, 0xFF6500, 0.8);\n                    miniFlash.setDepth(Z_LAYERS.BUBBLES_FRONT);\n                    context.scene.tweens.add({\n                        targets: miniFlash,\n                        scale: { from: 0, to: 1.5 },\n                        alpha: 0,\n                        duration: 200,\n                        ease: 'Cubic.easeOut',\n                        onComplete: () => miniFlash.destroy()\n                    });\n                    \n                    bubble.destroy();\n                }\n            });\n        });\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        // Clean up timers if they exist\n        if ((this as any).glowTimer) {\n            (this as any).glowTimer.destroy();\n            (this as any).glowTimer = null;\n        }\n        if ((this as any).sparkTimer) {\n            (this as any).sparkTimer.destroy();\n            (this as any).sparkTimer = null;\n        }\n        \n        // Clean up visual elements\n        this.visualElements.forEach(element => {\n            if (element && element.destroy) {\n                element.destroy();\n            }\n        });\n        this.visualElements = [];\n        \n        // Reset aiming mode\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Lightning Power-Up: Click to destroy bubble\n */\nexport class LightningEffect implements IPowerUpEffect {\n    type = PowerUpType.LIGHTNING;\n    private selectionHandler?: Function;\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set selection cursor mode\n        context.aimingMode.setMode(AimingMode.LIGHTNING, this.type);\n        \n        // Visual feedback\n        const lightningText = context.scene.add.text(\n            context.scene.cameras.main.centerX,\n            context.scene.cameras.main.centerY,\n            '⚡ LIGHTNING STRIKE!',\n            {\n                fontSize: '28px',\n                fontFamily: 'Arial Black',\n                color: '#FFFF00',\n                stroke: '#000000',\n                strokeThickness: 3\n            }\n        );\n        lightningText.setOrigin(0.5);\n        lightningText.setDepth(1000);\n        \n        // Animate text\n        context.scene.tweens.add({\n            targets: lightningText,\n            scale: { from: 0, to: 1.2 },\n            alpha: { from: 1, to: 0 },\n            y: lightningText.y - 50,\n            duration: 1500,\n            ease: 'Power2',\n            onComplete: () => lightningText.destroy()\n        });\n        \n        // For now, just show the effect, actual bubble selection will be implemented later\n        context.shotsRemaining = 1;\n    }\n    \n    private destroyWithLightning(bubble: Bubble, context: PowerUpContext): void {\n        // Lightning strike visual\n        const lightning = context.scene.add.graphics();\n        lightning.setDepth(Z_LAYERS.BUBBLES_FRONT + 10);\n        \n        // Draw lightning bolt from top\n        lightning.lineStyle(4, 0xFFFF00, 1);\n        lightning.beginPath();\n        \n        const startY = 0;\n        const segments = 5;\n        let currentX = bubble.x;\n        let currentY = startY;\n        \n        for (let i = 0; i < segments; i++) {\n            const nextX = bubble.x + Phaser.Math.Between(-30, 30);\n            const nextY = startY + ((bubble.y - startY) / segments) * (i + 1);\n            \n            lightning.moveTo(currentX, currentY);\n            lightning.lineTo(nextX, nextY);\n            \n            currentX = nextX;\n            currentY = nextY;\n        }\n        \n        lightning.lineTo(bubble.x, bubble.y);\n        lightning.strokePath();\n        \n        // Flash effect\n        context.scene.cameras.main.flash(100, 255, 255, 0);\n        \n        // Destroy bubble\n        bubble.destroy();\n        \n        // Clean up lightning after animation\n        context.scene.tweens.add({\n            targets: lightning,\n            alpha: 0,\n            duration: 200,\n            onComplete: () => lightning.destroy()\n        });\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        if (this.selectionHandler) {\n            context.scene.input.off('pointerdown', this.selectionHandler as any);\n        }\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Freeze Power-Up: Stop bubble physics\n */\nexport class FreezeEffect implements IPowerUpEffect {\n    type = PowerUpType.FREEZE;\n    private frozenBubbles: Bubble[] = [];\n    private frostOverlay?: Phaser.GameObjects.Graphics;\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set freeze aiming mode\n        context.aimingMode.setMode(AimingMode.FREEZE, this.type);\n        \n        // Freeze all physics (if physics exists)\n        if (context.scene.physics && context.scene.physics.pause) {\n            context.scene.physics.pause();\n        }\n        \n        // Create frost overlay\n        this.createFrostOverlay(context);\n        \n        // Store frozen bubbles (empty for now, will be implemented later)\n        this.frozenBubbles = [];\n        \n        // Visual feedback for freeze effect\n        const freezeText = context.scene.add.text(\n            context.scene.cameras.main.centerX,\n            context.scene.cameras.main.centerY,\n            'TIME FROZEN!',\n            {\n                fontSize: '32px',\n                fontFamily: 'Arial Black',\n                color: '#00FFFF',\n                stroke: '#003366',\n                strokeThickness: 4\n            }\n        );\n        freezeText.setOrigin(0.5);\n        freezeText.setDepth(1000);\n        \n        // Animate and remove text\n        context.scene.tweens.add({\n            targets: freezeText,\n            scale: { from: 0, to: 1.5 },\n            alpha: { from: 1, to: 0 },\n            duration: 2000,\n            ease: 'Power2',\n            onComplete: () => freezeText.destroy()\n        });\n        \n        // Auto-deactivate after 5 seconds\n        context.scene.time.delayedCall(5000, () => {\n            this.deactivate(context);\n        });\n    }\n    \n    private createFrostOverlay(context: PowerUpContext): void {\n        this.frostOverlay = context.scene.add.graphics();\n        this.frostOverlay.setDepth(Z_LAYERS.UI - 1);\n        \n        // Semi-transparent blue overlay\n        this.frostOverlay.fillStyle(0x87CEEB, 0.2);\n        this.frostOverlay.fillRect(\n            0, 0,\n            context.scene.cameras.main.width,\n            context.scene.cameras.main.height\n        );\n        \n        // Add snowflake particles\n        for (let i = 0; i < 20; i++) {\n            const snowflake = context.scene.add.text(\n                Phaser.Math.Between(0, context.scene.cameras.main.width),\n                Phaser.Math.Between(0, context.scene.cameras.main.height),\n                '❄️',\n                { fontSize: '20px' }\n            );\n            snowflake.setDepth(Z_LAYERS.UI);\n            \n            context.scene.tweens.add({\n                targets: snowflake,\n                y: snowflake.y + 100,\n                alpha: { from: 1, to: 0 },\n                duration: 3000,\n                repeat: -1,\n                delay: i * 150\n            });\n            \n            // Store for cleanup\n            // this.frostOverlay.setData(`snowflake_${i}`, snowflake);\n        }\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        // Resume physics\n        if (context.scene.physics && context.scene.physics.resume) {\n            context.scene.physics.resume();\n        }\n        \n        // Remove tint from bubbles\n        this.frozenBubbles.forEach(bubble => {\n            if (bubble && bubble.scene) {\n                bubble.clearTint();\n            }\n        });\n        \n        // Clean up overlay\n        if (this.frostOverlay) {\n            // Clean up snowflakes\n            for (let i = 0; i < 20; i++) {\n                const snowflake = this.frostOverlay.getData(`snowflake_${i}`);\n                if (snowflake) {\n                    snowflake.destroy();\n                }\n            }\n            this.frostOverlay.destroy();\n        }\n        \n        // Reset aiming\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Multi-Shot Power-Up: Shoot 3 bubbles in spread\n */\nexport class MultiShotEffect implements IPowerUpEffect {\n    type = PowerUpType.MULTIPLIER; // Using as placeholder for MULTI_SHOT\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set multi-shot aiming mode\n        context.aimingMode.setMode(AimingMode.MULTI, this.type);\n        \n        // Visual feedback\n        const multiText = context.scene.add.text(\n            context.scene.cameras.main.centerX,\n            context.scene.cameras.main.centerY,\n            '✨ MULTI-SHOT!',\n            {\n                fontSize: '28px',\n                fontFamily: 'Arial Black',\n                color: '#FFD700',\n                stroke: '#000000',\n                strokeThickness: 3\n            }\n        );\n        multiText.setOrigin(0.5);\n        multiText.setDepth(1000);\n        \n        // Animate text\n        context.scene.tweens.add({\n            targets: multiText,\n            scale: { from: 0, to: 1.2 },\n            alpha: { from: 1, to: 0 },\n            y: multiText.y - 50,\n            duration: 1500,\n            ease: 'Power2',\n            onComplete: () => multiText.destroy()\n        });\n        \n        context.shotsRemaining = 1;\n    }\n    \n    deactivate?(context: PowerUpContext): void {\n        // Reset aiming mode\n        if (context.aimingMode) {\n            context.aimingMode.setMode(AimingMode.NORMAL);\n        }\n    }\n}\n\n/**\n * Factory for creating power-up effects\n */\nexport class PowerUpEffectFactory {\n    private effects: Map<PowerUpType, IPowerUpEffect> = new Map();\n    \n    constructor() {\n        // Register all effects\n        this.registerEffect(new RainbowEffect());\n        this.registerEffect(new LaserSightEffect());\n        this.registerEffect(new BombEffect());\n        this.registerEffect(new LightningEffect());\n        this.registerEffect(new FreezeEffect());\n        this.registerEffect(new MultiShotEffect());\n    }\n    \n    private registerEffect(effect: IPowerUpEffect): void {\n        this.effects.set(effect.type, effect);\n    }\n    \n    public getEffect(type: PowerUpType): IPowerUpEffect | undefined {\n        return this.effects.get(type);\n    }\n    \n    public getAllEffects(): IPowerUpEffect[] {\n        return Array.from(this.effects.values());\n    }\n}","import { Scene } from 'phaser';\nimport { PowerUpType } from './PowerUpManager';\nimport { \n    PowerUpContext, \n    RainbowEffect, \n    LaserSightEffect, \n    BombEffect, \n    LightningEffect, \n    FreezeEffect, \n    MultiShotEffect,\n    IPowerUpEffect \n} from './PowerUpEffectsLibrary';\nimport { AimingModeSystem, AimingMode } from './AimingModeSystem';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { BubbleGrid } from '@/systems/gameplay/BubbleGrid';\n\nexport class PowerUpActivationSystem {\n    private scene: Scene;\n    private effects: Map<PowerUpType, IPowerUpEffect>;\n    private activeEffect?: IPowerUpEffect;\n    private context: PowerUpContext;\n    \n    constructor(\n        scene: Scene, \n        launcher: Launcher, \n        bubbleGrid: BubbleGrid,\n        aimingModeSystem: AimingModeSystem\n    ) {\n        this.scene = scene;\n        \n        // Initialize context\n        this.context = {\n            scene,\n            launcher,\n            aimingMode: aimingModeSystem,\n            bubbleGrid\n        };\n        \n        // Initialize effects\n        this.effects = new Map([\n            [PowerUpType.RAINBOW, new RainbowEffect()],\n            [PowerUpType.LASER, new LaserSightEffect()],\n            [PowerUpType.BOMB, new BombEffect()],\n            [PowerUpType.LIGHTNING, new LightningEffect()],\n            [PowerUpType.FREEZE, new FreezeEffect()],\n            [PowerUpType.MULTIPLIER, new MultiShotEffect()]\n        ]);\n        \n        this.setupEventListeners();\n    }\n    \n    private setupEventListeners(): void {\n        // Listen for power-up activation from inventory\n        this.scene.events.on('activate-power-up', (data: { type: PowerUpType }) => {\n            this.activatePowerUp(data.type);\n        });\n    }\n    \n    public activatePowerUp(type: PowerUpType): void {\n        // Deactivate current effect if any\n        if (this.activeEffect && this.activeEffect.deactivate) {\n            this.activeEffect.deactivate(this.context);\n        }\n        \n        // Reset aiming mode to normal first\n        this.context.aimingMode.setMode(AimingMode.NORMAL);\n        \n        // Get the effect\n        const effect = this.effects.get(type);\n        if (!effect) {\n            console.warn(`Power-up effect not found for type: ${type}`);\n            return;\n        }\n        \n        // Activate the new effect\n        console.log(`Activating power-up effect: ${type}`);\n        this.activeEffect = effect;\n        effect.activate(this.context);\n        \n        // Emit power-up activation event for sound system\n        this.scene.events.emit('power-up-activated', { type });\n        \n        // Visual feedback\n        this.showActivationFeedback(type);\n    }\n    \n    private showActivationFeedback(type: PowerUpType): void {\n        // Create activation text\n        const powerUpNames: Record<PowerUpType, string> = {\n            [PowerUpType.RAINBOW]: 'RAINBOW MODE!',\n            [PowerUpType.LASER]: 'LASER SIGHT!',\n            [PowerUpType.BOMB]: 'BOMB READY!',\n            [PowerUpType.LIGHTNING]: 'LIGHTNING STRIKE!',\n            [PowerUpType.FREEZE]: 'FREEZE TIME!',\n            [PowerUpType.MULTIPLIER]: 'MULTI-SHOT!',\n            [PowerUpType.SHIELD]: 'SHIELD UP!',\n            [PowerUpType.MAGNET]: 'MAGNET ON!'\n        };\n        \n        const text = this.scene.add.text(\n            this.scene.cameras.main.centerX,\n            this.scene.cameras.main.centerY - 100,\n            powerUpNames[type] || 'POWER-UP!',\n            {\n                fontSize: '32px',\n                fontFamily: 'Arial Black',\n                color: '#FFD700',\n                stroke: '#000000',\n                strokeThickness: 4\n            }\n        );\n        text.setOrigin(0.5);\n        text.setDepth(1000);\n        \n        // Animate\n        this.scene.tweens.add({\n            targets: text,\n            scale: { from: 0, to: 1.2 },\n            alpha: { from: 1, to: 0 },\n            y: text.y - 50,\n            duration: 1500,\n            ease: 'Power2',\n            onComplete: () => {\n                text.destroy();\n            }\n        });\n        \n        // Screen flash effect\n        this.scene.cameras.main.flash(250, 255, 215, 0);\n    }\n    \n    public update(delta: number): void {\n        // Update active effect if it has an update method\n        if (this.activeEffect && this.activeEffect.update) {\n            this.activeEffect.update(this.context, delta);\n        }\n    }\n    \n    public destroy(): void {\n        // Clean up\n        if (this.activeEffect && this.activeEffect.deactivate) {\n            this.activeEffect.deactivate(this.context);\n        }\n        this.effects.clear();\n    }\n}","import { Scene } from 'phaser';\nimport { BubbleColor } from '@/types/ArenaTypes';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\n\n/**\n * Configuration interface for paint splatter system\n */\ninterface IPaintSplatterConfig {\n    // Droplet settings\n    minDropletSize: number;\n    maxDropletSize: number;\n    minDroplets: number;\n    maxDroplets: number;\n    minSpread: number;\n    maxSpread: number;\n    \n    // Timing\n    fadeStartDelay: number;\n    fadeDuration: number;\n    \n    // Visual\n    initialAlpha: number;\n    colorVariation: number;\n    \n    // Performance\n    maxSplatters: number;\n    cleanupBatchSize: number;\n    \n    // Scaling\n    scaleWithCombo: boolean;\n    comboScaleFactor: number;\n    maxComboScale: number;\n}\n\n/**\n * Professional paint splatter visual effect system\n * Creates realistic paint splatters when bubbles explode\n * Fully scalable and configurable\n */\nexport class PaintSplatterSystem {\n    private scene: Scene;\n    private splatters: Phaser.GameObjects.Graphics[] = [];\n    private config: IPaintSplatterConfig;\n    \n    // Default configuration - easily adjustable\n    private static readonly DEFAULT_CONFIG: IPaintSplatterConfig = {\n        // Balanced, natural splatters\n        minDropletSize: 1.5,\n        maxDropletSize: 4,\n        minDroplets: 3,\n        maxDroplets: 7,\n        minSpread: 10,\n        maxSpread: 28,\n        \n        // Quick persistence (1.5 seconds before fade, 1 second fade)\n        fadeStartDelay: 1500,\n        fadeDuration: 1000,\n        \n        // Balanced visual settings\n        initialAlpha: 0.45,  // Balanced transparency\n        colorVariation: 0.12,  // Slight color variation\n        \n        // Performance limits\n        maxSplatters: 120,\n        cleanupBatchSize: 20,\n        \n        // Balanced scaling with combo\n        scaleWithCombo: true,\n        comboScaleFactor: 0.2, // 20% more droplets per combo level\n        maxComboScale: 1.8 // Max 1.8x droplets at high combos\n    };\n    \n    constructor(scene: Scene, config?: Partial<IPaintSplatterConfig>) {\n        this.scene = scene;\n        this.config = { ...PaintSplatterSystem.DEFAULT_CONFIG, ...config };\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Update configuration at runtime\n     */\n    public updateConfig(config: Partial<IPaintSplatterConfig>): void {\n        this.config = { ...this.config, ...config };\n    }\n    \n    /**\n     * Get current configuration\n     */\n    public getConfig(): IPaintSplatterConfig {\n        return { ...this.config };\n    }\n    \n    private setupEventListeners(): void {\n        // Listen for the actual bubble explosion event\n        this.scene.events.on('bubble-exploded', this.handleBubbleExplosion, this);\n    }\n    \n    private handleBubbleExplosion(data: {\n        x: number;\n        y: number;\n        positions?: { x: number, y: number }[];\n        color: BubbleColor;\n        comboMultiplier?: number;\n    }): void {\n        // If we have individual positions, create splatters at each bubble\n        if (data.positions && data.positions.length > 0) {\n            // Calculate droplets per bubble based on total match size\n            const dropletsPerBubble = this.calculateDropletsPerBubble(data.comboMultiplier || 1, data.positions.length);\n            \n            // Create splatters at each bubble position\n            data.positions.forEach(pos => {\n                this.createSplatterAtPosition(pos.x, pos.y, data.color, dropletsPerBubble);\n            });\n        } else {\n            // Fallback to center position for compatibility\n            this.createSplatter(data.x, data.y, data.color, data.comboMultiplier || 1);\n        }\n    }\n    \n    private calculateDropletsPerBubble(matchSize: number, bubbleCount: number): number {\n        // Calculate total droplets for the match size\n        let totalDroplets: number;\n        \n        if (matchSize <= 3) {\n            totalDroplets = Phaser.Math.Between(5, 6);\n        } else if (matchSize === 4) {\n            totalDroplets = Phaser.Math.Between(8, 10);\n        } else if (matchSize === 5) {\n            totalDroplets = Phaser.Math.Between(12, 14);\n        } else if (matchSize === 6) {\n            totalDroplets = Phaser.Math.Between(16, 18);\n        } else {\n            totalDroplets = Phaser.Math.Between(20, 24);\n        }\n        \n        // Distribute droplets across all bubbles\n        // Each bubble gets at least 1-2 droplets, with some getting more\n        const baseDroplets = Math.max(1, Math.floor(totalDroplets / bubbleCount));\n        const extraDroplets = totalDroplets % bubbleCount;\n        \n        // Return base amount plus possible extra\n        return baseDroplets + (Math.random() < extraDroplets / bubbleCount ? 1 : 0);\n    }\n    \n    private createSplatterAtPosition(x: number, y: number, color: BubbleColor, dropletCount: number): void {\n        // Validate position\n        if (!this.isValidPosition(x, y)) {\n            return;\n        }\n        \n        // Create specified number of droplets at this position\n        for (let i = 0; i < dropletCount; i++) {\n            this.createDroplet(x, y, color, 1);\n        }\n    }\n    \n    private createSplatter(x: number, y: number, color: BubbleColor, multiplier: number): void {\n        // Validate position\n        if (!this.isValidPosition(x, y)) {\n            return;\n        }\n        \n        // Clean up old splatters if we have too many\n        if (this.splatters.length > this.config.maxSplatters) {\n            const toRemove = this.splatters.splice(0, this.config.cleanupBatchSize);\n            toRemove.forEach(g => {\n                this.scene.tweens.killTweensOf(g);\n                g.destroy();\n            });\n        }\n        \n        // Calculate droplet count based on match size (multiplier)\n        // Ensure larger matches ALWAYS create more droplets\n        let dropletCount: number;\n        \n        if (multiplier <= 3) {\n            // Small match (3): 5-6 droplets\n            dropletCount = Phaser.Math.Between(5, 6);\n        } else if (multiplier === 4) {\n            // Medium match (4): 8-10 droplets\n            dropletCount = Phaser.Math.Between(8, 10);\n        } else if (multiplier === 5) {\n            // Large match (5): 12-14 droplets\n            dropletCount = Phaser.Math.Between(12, 14);\n        } else if (multiplier === 6) {\n            // Huge match (6): 16-18 droplets\n            dropletCount = Phaser.Math.Between(16, 18);\n        } else {\n            // Epic match (7+): 20-24 droplets\n            dropletCount = Phaser.Math.Between(20, 24);\n        }\n        \n        // Apply configuration limits (allow up to 3x the config for epic combos)\n        dropletCount = Math.min(dropletCount, this.config.maxDroplets * 3);\n        \n        // Create droplets\n        for (let i = 0; i < dropletCount; i++) {\n            this.createDroplet(x, y, color, multiplier);\n        }\n    }\n    \n    private createDroplet(centerX: number, centerY: number, color: BubbleColor, multiplier: number): void {\n        // Random position around center\n        const angle = Math.random() * Math.PI * 2;\n        \n        // Slightly larger spread for bigger combos\n        const spreadMultiplier = this.config.scaleWithCombo ? \n            Math.min(1 + (multiplier - 1) * 0.1, 1.5) : 1;\n            \n        const distance = Phaser.Math.Between(\n            this.config.minSpread * spreadMultiplier,\n            this.config.maxSpread * spreadMultiplier\n        );\n        \n        const dropletX = centerX + Math.cos(angle) * distance;\n        const dropletY = centerY + Math.sin(angle) * distance;\n        \n        // Validate droplet position\n        if (!this.isValidPosition(dropletX, dropletY)) {\n            return;\n        }\n        \n        // Create graphics object for this droplet\n        const graphics = this.scene.add.graphics();\n        \n        // Random droplet size (slightly larger for big combos)\n        const sizeMultiplier = this.config.scaleWithCombo && multiplier > 3 ? \n            1 + (multiplier - 3) * 0.05 : 1;\n            \n        const size = Phaser.Math.FloatBetween(\n            this.config.minDropletSize * sizeMultiplier,\n            this.config.maxDropletSize * sizeMultiplier\n        );\n        \n        // Apply color with slight variation\n        const variedColor = this.applyColorVariation(color);\n        \n        // Set depth behind bubbles\n        graphics.setDepth(Z_LAYERS.BACKGROUND + 1);\n        graphics.setAlpha(this.config.initialAlpha);\n        \n        // Draw the droplet at its position\n        graphics.fillStyle(variedColor, 1);\n        \n        // Random shape with weighted probabilities\n        const shapeType = Math.random();\n        if (shapeType < 0.4) {\n            // 40% - Simple circle (most common)\n            graphics.fillCircle(dropletX, dropletY, size);\n        } else if (shapeType < 0.7) {\n            // 30% - Ellipse (stretched droplet)\n            const rotation = Math.random() * Math.PI;\n            graphics.save();\n            graphics.translateCanvas(dropletX, dropletY);\n            graphics.rotateCanvas(rotation);\n            graphics.fillEllipse(0, 0, size * 1.5, size * 0.6);\n            graphics.restore();\n        } else if (shapeType < 0.9) {\n            // 20% - Teardrop shape\n            graphics.save();\n            graphics.translateCanvas(dropletX, dropletY);\n            graphics.rotateCanvas(angle); // Point away from center\n            graphics.beginPath();\n            graphics.arc(0, 0, size, 0, Math.PI * 2);\n            graphics.lineTo(size * 1.5, 0);\n            graphics.closePath();\n            graphics.fillPath();\n            graphics.restore();\n        } else {\n            // 10% - Irregular splat (rare, more complex)\n            graphics.beginPath();\n            graphics.moveTo(dropletX, dropletY);\n            const points = Phaser.Math.Between(4, 7);\n            for (let j = 0; j < points; j++) {\n                const pointAngle = (j / points) * Math.PI * 2;\n                const pointDist = size * (0.6 + Math.random() * 0.8);\n                const px = dropletX + Math.cos(pointAngle) * pointDist;\n                const py = dropletY + Math.sin(pointAngle) * pointDist;\n                if (j === 0) {\n                    graphics.moveTo(px, py);\n                } else {\n                    graphics.lineTo(px, py);\n                }\n            }\n            graphics.closePath();\n            graphics.fillPath();\n        }\n        \n        // Remove animation for subtlety - splatters just appear naturally\n        \n        // Add to tracking array\n        this.splatters.push(graphics);\n        \n        // PERFORMANCE: Aggressive cleanup to prevent memory issues\n        // Start cleanup earlier when approaching limit\n        if (this.splatters.length > this.config.maxSplatters * 0.7) {\n            // Remove oldest splatters more aggressively\n            const toRemove = Math.min(5, this.splatters.length - this.config.maxSplatters * 0.5);\n            for (let i = 0; i < toRemove; i++) {\n                const oldSplatter = this.splatters.shift();\n                if (oldSplatter) {\n                    this.scene.tweens.killTweensOf(oldSplatter);\n                    oldSplatter.destroy();\n                }\n            }\n        }\n        \n        // Schedule fade out with configured timing\n        this.scene.time.delayedCall(\n            this.config.fadeStartDelay,\n            () => {\n                this.scene.tweens.add({\n                    targets: graphics,\n                    alpha: 0,\n                    duration: this.config.fadeDuration,\n                    ease: 'Power2',\n                    onComplete: () => {\n                        const index = this.splatters.indexOf(graphics);\n                        if (index > -1) {\n                            this.splatters.splice(index, 1);\n                        }\n                        graphics.destroy();\n                    }\n                });\n            }\n        );\n    }\n    \n    private applyColorVariation(color: BubbleColor): number {\n        const r = (color >> 16) & 0xff;\n        const g = (color >> 8) & 0xff;\n        const b = color & 0xff;\n        \n        const variation = this.config.colorVariation;\n        \n        // Apply subtle darker variation (paint tends to be darker when splattered)\n        const darkness = 0.8 + Math.random() * 0.2; // 80-100% brightness for subtlety\n        \n        const newR = Math.min(255, Math.max(0, r * darkness + (Math.random() - 0.5) * 255 * variation));\n        const newG = Math.min(255, Math.max(0, g * darkness + (Math.random() - 0.5) * 255 * variation));\n        const newB = Math.min(255, Math.max(0, b * darkness + (Math.random() - 0.5) * 255 * variation));\n        \n        return (Math.floor(newR) << 16) | (Math.floor(newG) << 8) | Math.floor(newB);\n    }\n    \n    private isValidPosition(x: number, y: number): boolean {\n        const cam = this.scene.cameras.main;\n        const buffer = 50;\n        return x >= -buffer && \n               x <= cam.width + buffer && \n               y >= -buffer && \n               y <= cam.height + buffer &&\n               !isNaN(x) && !isNaN(y) &&\n               isFinite(x) && isFinite(y);\n    }\n    \n    /**\n     * Get current splatter count\n     */\n    public getSplatterCount(): number {\n        return this.splatters.length;\n    }\n    \n    /**\n     * Clear all splatters immediately\n     */\n    public clear(): void {\n        this.splatters.forEach(graphics => {\n            this.scene.tweens.killTweensOf(graphics);\n            graphics.destroy();\n        });\n        this.splatters = [];\n    }\n    \n    /**\n     * Set quality preset for performance optimization\n     */\n    public setQualityPreset(preset: 'low' | 'medium' | 'high' | 'ultra'): void {\n        switch (preset) {\n            case 'low':\n                this.updateConfig({\n                    minDroplets: 1,\n                    maxDroplets: 2,\n                    minDropletSize: 1,\n                    maxDropletSize: 2,\n                    maxSplatters: 30,\n                    fadeStartDelay: 800,\n                    fadeDuration: 500,\n                    initialAlpha: 0.25\n                });\n                break;\n            case 'medium':\n                this.updateConfig({\n                    minDroplets: 2,\n                    maxDroplets: 4,\n                    minDropletSize: 1,\n                    maxDropletSize: 3,\n                    maxSplatters: 60,\n                    fadeStartDelay: 1200,\n                    fadeDuration: 800,\n                    initialAlpha: 0.3\n                });\n                break;\n            case 'high':\n                this.updateConfig({\n                    minDroplets: 3,\n                    maxDroplets: 8,\n                    minDropletSize: 1.5,\n                    maxDropletSize: 5,\n                    maxSplatters: 120,\n                    fadeStartDelay: 1500,\n                    fadeDuration: 1000,\n                    initialAlpha: 0.45\n                });\n                break;\n            case 'ultra':\n                this.updateConfig({\n                    minDroplets: 3,\n                    maxDroplets: 8,\n                    minDropletSize: 1,\n                    maxDropletSize: 5,\n                    maxSplatters: 150,\n                    fadeStartDelay: 2000,\n                    fadeDuration: 1200,\n                    initialAlpha: 0.4,\n                    scaleWithCombo: true,\n                    maxComboScale: 2\n                });\n                break;\n        }\n    }\n    \n    /**\n     * Destroy system and clean up resources\n     */\n    public destroy(): void {\n        this.scene.events.off('bubble-exploded', this.handleBubbleExplosion, this);\n        this.clear();\n    }\n}","import { Scene } from 'phaser';\nimport { IArenaConfig, IZoneBounds, ArenaZone, IHexPosition } from '@/types/ArenaTypes';\nimport { ARENA_CONFIG, BUBBLE_CONFIG, GRID_CONFIG, ZONE_COLORS, Z_LAYERS, DANGER_ZONE_CONFIG } from '@/config/ArenaConfig';\nimport { BubbleGrid } from './BubbleGrid';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { MysteryBubble } from '@/gameObjects/MysteryBubble';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { Objective } from '@/gameObjects/Objective';\nimport { InputManager } from '@/systems/input/InputManager';\nimport { ShootingSystem } from './ShootingSystem';\nimport { GridAttachmentSystem } from './GridAttachmentSystem';\nimport { MatchDetectionSystem } from './MatchDetectionSystem';\nimport { AIOpponentSystem, AIDifficulty } from './AIOpponentSystem';\nimport { EnhancedScoreDisplay } from '@/ui/EnhancedScoreDisplay';\nimport { ComboManager } from './ComboManager';\nimport { VictoryScreen } from '@/ui/VictoryScreen';\nimport { DefeatScreen } from '@/ui/DefeatScreen';\nimport { ScoreEventManager, ScoreEventType, ScoreContext } from '@/systems/scoring/ScoreEventManager';\nimport { UnifiedFeedbackSystem } from '@/systems/scoring/UnifiedFeedbackSystem';\nimport { PowerUpInventoryUI } from '@/ui/PowerUpInventoryUI';\nimport { PowerUpActivationSystem } from '@/systems/powerups/PowerUpActivationSystem';\nimport { AimingModeSystem } from '@/systems/powerups/AimingModeSystem';\nimport { PaintSplatterSystem } from '@/systems/visual/PaintSplatterSystem';\n\nexport { AIDifficulty };\n\nexport class ArenaSystem {\n    // Static variable to persist difficulty between restarts\n    private static currentDifficulty: AIDifficulty = AIDifficulty.HARD;\n    \n    private scene: Scene;\n    private config: IArenaConfig;\n    private bubbleGrid: BubbleGrid;\n    private objective!: Objective;\n    private playerLauncher!: Launcher;\n    private opponentLauncher!: Launcher;\n    private bubbles: Bubble[] = [];\n    private bubblePool: Bubble[] = [];\n    private zones: Map<ArenaZone, IZoneBounds> = new Map();\n    private debugGraphics?: Phaser.GameObjects.Graphics;\n    private debugEnabled: boolean = false;\n    private inputManager: InputManager;\n    private shootingSystem?: ShootingSystem;\n    private gridAttachmentSystem: GridAttachmentSystem;\n    private matchDetectionSystem: MatchDetectionSystem;\n    private aiOpponent?: AIOpponentSystem;\n    private isSinglePlayer: boolean = true;\n    private enhancedScoreDisplay?: EnhancedScoreDisplay;\n    private comboManager?: ComboManager;\n    private scoreEventManager?: ScoreEventManager;\n    private unifiedFeedbackSystem?: UnifiedFeedbackSystem;\n    private playerPowerUpInventory?: PowerUpInventoryUI;\n    private opponentPowerUpInventory?: PowerUpInventoryUI;\n    private powerUpActivation?: PowerUpActivationSystem;\n    private aimingModeSystem?: AimingModeSystem;\n    private playerScore: number = 0;\n    private aiScore: number = 0;\n    private gameOver: boolean = false;\n    private victoryScreen?: VictoryScreen;\n    private defeatScreen?: DefeatScreen;\n    private isRestarting: boolean = false;\n    private playerDangerLine?: Phaser.GameObjects.Graphics;\n    private opponentDangerLine?: Phaser.GameObjects.Graphics;\n    private dangerWarningActive: boolean = false;\n    private paintSplatterSystem?: PaintSplatterSystem;\n    private dangerCheckCounter: number = 0;\n    private readonly DANGER_CHECK_INTERVAL: number = 10;\n    \n    // Performance optimization: Cache objective shield state\n    private shieldCheckCounter: number = 0;\n    private readonly SHIELD_CHECK_INTERVAL: number = 15; // Check every 15 frames (~4 times per second at 60fps)\n    private cachedShieldState: boolean = false;\n    \n    // Performance optimization: Throttle aiming updates\n    private aimingCheckCounter: number = 0;\n    private readonly AIMING_CHECK_INTERVAL: number = 2; // Check every 2 frames for responsive aiming // Check every 10 frames instead of every frame\n    private lastAimAngle: number = 0;\n\n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.config = ARENA_CONFIG;\n        \n        // Initialize input manager\n        this.inputManager = new InputManager(scene);\n        \n        // Initialize grid at center of objective zone\n        const centerX = scene.cameras.main.centerX;\n        const centerY = scene.cameras.main.centerY;\n        this.bubbleGrid = new BubbleGrid(centerX, centerY);\n        \n        // Initialize grid attachment system\n        this.gridAttachmentSystem = new GridAttachmentSystem(scene, this.bubbleGrid);\n        \n        // Initialize match detection system\n        this.matchDetectionSystem = new MatchDetectionSystem(\n            scene,\n            this.bubbleGrid,\n            this.gridAttachmentSystem\n        );\n        \n        // Connect systems\n        this.gridAttachmentSystem.setMatchDetectionSystem(this.matchDetectionSystem);\n        \n        this.initializeZones();\n        this.createBubblePool();\n    }\n\n    private initializeZones(): void {\n        const width = this.scene.cameras.main.width;\n        const height = this.scene.cameras.main.height;\n        \n        // Player zone (bottom 40%)\n        this.zones.set(ArenaZone.PLAYER, {\n            x: 0,\n            y: height - this.config.playerZoneHeight,\n            width: width,\n            height: this.config.playerZoneHeight,\n            zone: ArenaZone.PLAYER\n        });\n        \n        // Opponent zone (top 40%)\n        this.zones.set(ArenaZone.OPPONENT, {\n            x: 0,\n            y: 0,\n            width: width,\n            height: this.config.opponentZoneHeight,\n            zone: ArenaZone.OPPONENT\n        });\n        \n        // Objective zone (middle 20%)\n        this.zones.set(ArenaZone.OBJECTIVE, {\n            x: 0,\n            y: this.config.opponentZoneHeight,\n            width: width,\n            height: this.config.objectiveZoneHeight,\n            zone: ArenaZone.OBJECTIVE\n        });\n    }\n\n    private createBubblePool(): void {\n        for (let i = 0; i < BUBBLE_CONFIG.POOL_SIZE; i++) {\n            const bubble = new Bubble(\n                this.scene,\n                -1000,\n                -1000,\n                Bubble.getRandomColor()\n            );\n            bubble.setVisible(false);\n            this.bubblePool.push(bubble);\n        }\n    }\n\n    public setupArena(singlePlayer: boolean = true, difficulty?: AIDifficulty): void {\n        this.isSinglePlayer = singlePlayer;\n        \n        // Use persisted difficulty if not specified\n        if (difficulty !== undefined) {\n            ArenaSystem.currentDifficulty = difficulty;\n        }\n        const actualDifficulty = ArenaSystem.currentDifficulty;\n        \n        this.createLaunchers();\n        this.createObjective();\n        this.createInitialBubbles();\n        this.createZoneVisuals();\n        \n        // Initialize enhanced scoring systems\n        this.enhancedScoreDisplay = new EnhancedScoreDisplay(this.scene);\n        this.comboManager = new ComboManager(this.scene);\n        \n        // Initialize new unified scoring system\n        this.scoreEventManager = new ScoreEventManager(this.scene);\n        this.unifiedFeedbackSystem = new UnifiedFeedbackSystem(this.scene);\n        \n        // Initialize visual effects systems with custom config\n        this.paintSplatterSystem = new PaintSplatterSystem(this.scene, {\n            // Quick persistence - splatters stay for 1.5 seconds, fade over 1 second\n            fadeStartDelay: 1500,\n            fadeDuration: 1000,\n            \n            // Balanced splatters - not too much, not too little\n            initialAlpha: 0.5,  // Slightly more visible\n            minDropletSize: 1.5,  // Slightly bigger minimum\n            maxDropletSize: 5,  // Slightly bigger maximum\n            \n            // Balanced droplet count\n            minDroplets: 3,\n            maxDroplets: 8,\n            \n            // Balanced spread area\n            minSpread: 10,\n            maxSpread: 30,\n            \n            // Performance tuning\n            maxSplatters: 150,\n            \n            // Balanced scaling with combos\n            scaleWithCombo: true,\n            comboScaleFactor: 0.25,  // 25% increase per combo\n            maxComboScale: 2.0  // Max 2x for huge combos\n        });\n        console.log('ArenaSystem: Paint splatter system initialized with enhanced settings');\n        \n        // Initialize power-up systems\n        // Arsenal is now integrated directly into the Launcher for both players\n        // The Launcher class handles the arsenal display internally\n        // this.playerPowerUpInventory = new PowerUpInventoryUI(this.scene, false);\n        // this.opponentPowerUpInventory = new PowerUpInventoryUI(this.scene, true);\n        this.aimingModeSystem = new AimingModeSystem(this.scene);\n        \n        // Initialize power-up activation after launcher is created\n        if (this.playerLauncher) {\n            this.powerUpActivation = new PowerUpActivationSystem(\n                this.scene,\n                this.playerLauncher,\n                this.bubbleGrid,\n                this.aimingModeSystem\n            );\n        }\n        \n        // Connect scoring systems\n        this.scoreEventManager.onScoreUpdate((score, isPlayer) => {\n            if (isPlayer) {\n                this.playerScore = score;\n                this.enhancedScoreDisplay?.updatePlayerScore(score);\n            } else {\n                this.aiScore = score;\n                this.enhancedScoreDisplay?.updateOpponentScore(score);\n            }\n        });\n        \n        this.scoreEventManager.onVisualEffect((result, position) => {\n            this.unifiedFeedbackSystem?.queueFeedback(result, position);\n        });\n        \n        this.playerScore = 0;\n        this.aiScore = 0;\n        \n        // Initialize shooting system with grid attachment\n        this.shootingSystem = new ShootingSystem(\n            this.scene,\n            this.inputManager,\n            this.playerLauncher,\n            this.gridAttachmentSystem,\n            this.bubbleGrid\n        );\n        \n        // Set opponent launcher for shooting system\n        this.shootingSystem.setOpponentLauncher(this.opponentLauncher);\n        \n        // Initialize AI opponent if single player\n        if (this.isSinglePlayer) {\n            this.aiOpponent = new AIOpponentSystem(\n                this.scene,\n                this.opponentLauncher\n            );\n            this.aiOpponent.setDifficulty(actualDifficulty);\n            \n            console.log(`ArenaSystem: AI opponent initialized with ${actualDifficulty} difficulty`);\n            \n            // Start AI after a short delay\n            this.scene.time.delayedCall(2000, () => {\n                this.aiOpponent?.start();\n                console.log('ArenaSystem: AI opponent started');\n            });\n        }\n        \n        // Listen for scoring events\n        this.scene.events.on('score-update', this.onScoreUpdate, this);\n        this.scene.events.on('bubble-attached', this.checkVictoryCondition, this);\n        this.scene.events.on('bubble-position-update', this.checkChestHit, this);\n        \n        // Enable debug with 'D' key\n        this.scene.input.keyboard?.on('keydown-D', () => {\n            this.toggleDebug();\n        });\n        \n        // Change AI difficulty with number keys\n        if (this.isSinglePlayer && this.aiOpponent) {\n            this.scene.input.keyboard?.on('keydown-ONE', () => {\n                this.changeAIDifficulty(AIDifficulty.EASY);\n            });\n            \n            this.scene.input.keyboard?.on('keydown-TWO', () => {\n                this.changeAIDifficulty(AIDifficulty.MEDIUM);\n            });\n            \n            this.scene.input.keyboard?.on('keydown-THREE', () => {\n                this.changeAIDifficulty(AIDifficulty.HARD);\n            });\n        }\n    }\n\n    private createLaunchers(): void {\n        const centerX = this.scene.cameras.main.centerX;\n        \n        // Player launcher at bottom\n        const playerZone = this.zones.get(ArenaZone.PLAYER)!;\n        this.playerLauncher = new Launcher(\n            this.scene,\n            centerX,\n            playerZone.y + playerZone.height - this.config.launcherOffset,\n            ArenaZone.PLAYER\n        );\n        \n        // Opponent launcher at top\n        const opponentZone = this.zones.get(ArenaZone.OPPONENT)!;\n        this.opponentLauncher = new Launcher(\n            this.scene,\n            centerX,\n            opponentZone.y + this.config.launcherOffset,\n            ArenaZone.OPPONENT\n        );\n    }\n\n    private createObjective(): void {\n        const centerX = this.scene.cameras.main.centerX;\n        const centerY = this.scene.cameras.main.centerY;\n        \n        // Create UFO delivery animation\n        this.createUFODelivery(centerX, centerY, () => {\n            // Create objective after UFO animation\n            this.objective = new Objective(this.scene, {\n                x: centerX,\n                y: centerY,\n                size: this.config.objectiveSize,\n                health: 1\n            });\n        });\n    }\n    \n    private createUFODelivery(targetX: number, targetY: number, onComplete: () => void): void {\n        // Check if UFO asset exists\n        if (!this.scene.textures.exists('ufo')) {\n            // Fallback to immediate creation if no UFO\n            onComplete();\n            return;\n        }\n        \n        const ufoScale = 0.35; // Larger UFO for better visibility\n        const startX = -200; // Start off-screen left\n        const startY = targetY - 100; // Slightly lower position\n        \n        // Create UFO\n        const ufo = this.scene.add.image(startX, startY, 'ufo');\n        ufo.setScale(ufoScale);\n        ufo.setDepth(1000); // Above everything\n        \n        // Play UFO arrival sound\n        let ufoArrivalSound: Phaser.Sound.BaseSound | null = null;\n        let ufoSound: Phaser.Sound.BaseSound | null = null;\n        \n        try {\n            ufoArrivalSound = this.scene.sound.add('ufo-arrives', {\n                volume: 0.5,\n                rate: 1.0  // Normal speed for arrival\n            });\n            ufoArrivalSound.play();\n        } catch (e) {\n            console.log('UFO arrival sound not loaded');\n        }\n        \n        // Create UFO trail particles for entry\n        const trailParticles = this.scene.add.particles(0, 0, 'particle', {\n            follow: ufo,\n            followOffset: { x: -30, y: 0 },\n            scale: { start: 0.3, end: 0 },\n            alpha: { start: 0.6, end: 0 },\n            tint: [0x00ffff, 0x00ff99, 0xffff00],\n            blendMode: 'ADD',\n            lifespan: 500,\n            quantity: 2,\n            frequency: 50,\n            emitting: true\n        });\n        trailParticles.setDepth(999);\n        \n        // UFO engine glow\n        const engineGlow = this.scene.add.particles(0, 0, 'particle', {\n            follow: ufo,\n            followOffset: { x: 0, y: 20 },\n            scale: { start: 0.4, end: 0.1 },\n            alpha: { start: 0.8, end: 0 },\n            tint: 0xffaa00,\n            blendMode: 'ADD',\n            lifespan: 300,\n            speedY: { min: 20, max: 40 },\n            speedX: { min: -10, max: 10 },\n            quantity: 3,\n            frequency: 30,\n            emitting: false\n        });\n        engineGlow.setDepth(998);\n        \n        // UFO entry animation with bounce\n        this.scene.tweens.add({\n            targets: ufo,\n            x: targetX,\n            duration: 1200,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                // Stop trail and start engine\n                trailParticles.stop();\n                engineGlow.start();\n                \n                // Small bounce on arrival\n                this.scene.tweens.add({\n                    targets: ufo,\n                    y: startY - 10,\n                    duration: 200,\n                    yoyo: true,\n                    ease: 'Quad.easeOut',\n                    onComplete: () => {\n                        // Show and animate tractor beam\n                        this.animateTractorBeam(ufo, targetX, startY, targetY, () => {\n                            // Create the objective\n                            onComplete();\n                            \n                            // UFO departure - fly up towards planet!\n                            engineGlow.stop();\n                            \n                            // Add delay before playing UFO departure sound\n                            this.scene.time.delayedCall(800, () => {\n                                // Play UFO departure sound after delay\n                                try {\n                                    ufoSound = this.scene.sound.add('ufo-sound', {\n                                        volume: 0.5,\n                                        rate: 0.9  // Adjusted rate for dramatic effect\n                                    });\n                                    ufoSound.play();\n                                } catch (e) {\n                                    console.log('UFO sound not loaded');\n                                }\n                            });\n                            \n                            // Create departure particles\n                            const departParticles = this.scene.add.particles(targetX, startY, 'particle', {\n                                scale: { start: 0.5, end: 0 },\n                                alpha: { start: 1, end: 0 },\n                                tint: [0xffff00, 0xff9900],\n                                blendMode: 'ADD',\n                                lifespan: 1000,\n                                speedY: { min: 50, max: 100 },\n                                speedX: { min: -30, max: 30 },\n                                quantity: 10,\n                                emitting: false\n                            });\n                            departParticles.setDepth(999);\n                            departParticles.explode(20);\n                            \n                            // UFO flies up towards planet (top-right where Earth is)\n                            this.scene.tweens.add({\n                                targets: ufo,\n                                x: this.scene.cameras.main.width * 0.85,\n                                y: this.scene.cameras.main.height * 0.15, // Go to planet position\n                                scale: 0.05, // Shrink as it goes to planet\n                                duration: 2000,\n                                ease: 'Quad.easeIn',\n                                delay: 300,\n                                onStart: () => {\n                                    // Fade out UFO sound\n                                    if (ufoSound) {\n                                        this.scene.tweens.add({\n                                            targets: ufoSound,\n                                            volume: 0,\n                                            duration: 1500,\n                                            onComplete: () => {\n                                                ufoSound?.stop();\n                                            }\n                                        });\n                                    }\n                                },\n                                onComplete: () => {\n                                    ufo.destroy();\n                                    trailParticles.destroy();\n                                    engineGlow.destroy();\n                                    \n                                    // Cleanup after delay\n                                    this.scene.time.delayedCall(1000, () => {\n                                        departParticles.destroy();\n                                    });\n                                }\n                            });\n                        });\n                    }\n                });\n            }\n        });\n        \n        // Add hovering motion to UFO\n        this.scene.tweens.add({\n            targets: ufo,\n            y: startY + 8,\n            duration: 1000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n    }\n    \n    private animateTractorBeam(ufo: Phaser.GameObjects.Image, x: number, y: number, targetY: number, onComplete: () => void): void {\n        // Calculate beam position to connect perfectly with UFO\n        const beamStartY = ufo.y + 30; // Start from UFO bottom\n        const beamHeight = targetY - beamStartY;\n        \n        // Create main beam container\n        const beamContainer = this.scene.add.container(x, beamStartY);\n        beamContainer.setDepth(999);\n        \n        // Create beam base graphics\n        const beamBase = this.scene.add.graphics();\n        beamContainer.add(beamBase);\n        \n        // Create particle emitters for beam effect\n        const beamParticles = this.scene.add.particles(0, 0, 'particle', {\n            x: 0,\n            y: { min: 0, max: beamHeight },\n            scale: { start: 0.6, end: 0.1 },\n            alpha: { start: 0.7, end: 0 },\n            tint: [0xffff00, 0xffcc00, 0xffffcc],\n            blendMode: 'ADD',\n            lifespan: 800,\n            speedX: { min: -20, max: 20 },\n            speedY: 0,\n            quantity: 3,\n            frequency: 50,\n            emitting: false\n        });\n        beamContainer.add(beamParticles);\n        \n        // Create spiraling energy particles\n        const spiralParticles = this.scene.add.particles(0, 0, 'particle', {\n            x: 0,\n            y: 0,\n            scale: { start: 0.4, end: 0.05 },\n            alpha: { start: 1, end: 0 },\n            tint: 0xffff99,\n            blendMode: 'ADD',\n            lifespan: 1200,\n            quantity: 2,\n            frequency: 80,\n            emitting: false\n        });\n        beamContainer.add(spiralParticles);\n        \n        // Animate beam expansion\n        beamContainer.setScale(0, 0);\n        beamContainer.setAlpha(0);\n        \n        this.scene.tweens.add({\n            targets: beamContainer,\n            scaleX: 1,\n            scaleY: 1,\n            alpha: 1,\n            duration: 400,\n            ease: 'Power2.easeOut',\n            onComplete: () => {\n                // Start particle emissions\n                beamParticles.start();\n                spiralParticles.start();\n                \n                // Play chest arrival sound when beam particles start\n                try {\n                    const chestArrivalSound = this.scene.sound.add('chest-arrival', {\n                        volume: 0.5,\n                        rate: 1.0\n                    });\n                    chestArrivalSound.play();\n                } catch (e) {\n                    console.log('Chest arrival sound not loaded');\n                }\n                \n                // Animate beam with real-time updates\n                let time = 0;\n                const beamPulse = this.scene.time.addEvent({\n                    delay: 16,\n                    callback: () => {\n                        time += 0.03;\n                        beamBase.clear();\n                        \n                        // Only draw a subtle glow effect, no triangles\n                        const pulse = Math.sin(time * 3) * 0.2 + 0.8;\n                        \n                        // Draw vertical beam lines instead of triangles\n                        for (let i = 0; i < 5; i++) {\n                            const offset = (i - 2) * 15;\n                            const alpha = (0.3 - Math.abs(i - 2) * 0.1) * pulse;\n                            \n                            beamBase.lineStyle(3, 0xffff00, alpha);\n                            beamBase.beginPath();\n                            beamBase.moveTo(offset * 0.3, 0);\n                            beamBase.lineTo(offset, beamHeight);\n                            beamBase.strokePath();\n                            \n                            beamBase.lineStyle(2, 0xffffcc, alpha * 0.7);\n                            beamBase.beginPath();\n                            beamBase.moveTo(offset * 0.3, 0);\n                            beamBase.lineTo(offset, beamHeight);\n                            beamBase.strokePath();\n                        }\n                        \n                        // Add circular glow at bottom\n                        beamBase.fillStyle(0xffff00, 0.1 * pulse);\n                        beamBase.fillCircle(0, beamHeight, 60);\n                        beamBase.fillStyle(0xffffcc, 0.2 * pulse);\n                        beamBase.fillCircle(0, beamHeight, 40);\n                        \n                        // Update spiral particle positions\n                        const spiralAngle = time * 4;\n                        spiralParticles.setParticleSpeed(\n                            Math.cos(spiralAngle) * 30,\n                            beamHeight / 1.2\n                        );\n                    },\n                    loop: true\n                });\n                \n                // After beam animation, materialize chest\n                this.scene.time.delayedCall(1800, () => {\n                    beamPulse.destroy();\n                    beamParticles.stop();\n                    spiralParticles.stop();\n                    \n                    // Create materialization effect\n                    const chestGlow = this.scene.add.graphics();\n                    chestGlow.fillStyle(0xffffff, 0);\n                    chestGlow.fillCircle(x, targetY, 40);\n                    chestGlow.setDepth(1000);\n                    \n                    // Materialize with bright flash\n                    this.scene.tweens.add({\n                        targets: chestGlow,\n                        alpha: { from: 0, to: 1 },\n                        scale: { from: 0.5, to: 1.5 },\n                        duration: 200,\n                        ease: 'Power2.easeOut',\n                        onComplete: () => {\n                            // Flash and fade\n                            this.scene.tweens.add({\n                                targets: chestGlow,\n                                alpha: 0,\n                                scale: 2,\n                                duration: 300,\n                                ease: 'Power2.easeOut',\n                                onComplete: () => {\n                                    chestGlow.destroy();\n                                }\n                            });\n                            \n                            // Fade out beam\n                            this.scene.tweens.add({\n                                targets: beamContainer,\n                                alpha: 0,\n                                duration: 500,\n                                onComplete: () => {\n                                    beamContainer.destroy();\n                                    onComplete();\n                                }\n                            });\n                        }\n                    });\n                });\n            }\n        });\n    }\n\n    private createInitialBubbles(): void {\n        const center: IHexPosition = { q: 0, r: 0, s: 0 };\n        \n        // Track Mystery Bubbles per side to ensure fair distribution\n        let playerSideMysteryCount = 0;\n        let opponentSideMysteryCount = 0;\n        const screenHeight = this.scene.cameras.main.height;\n        const midPoint = screenHeight / 2;\n        \n        // Collect all positions first\n        const allPositions: { hexPos: IHexPosition, pixelPos: { x: number, y: number } }[] = [];\n        \n        // Create 3 rings of bubbles around the objective\n        for (let ring = 1; ring <= GRID_CONFIG.OBJECTIVE_RADIUS; ring++) {\n            const positions = this.bubbleGrid.getRing(center, ring);\n            positions.forEach(hexPos => {\n                const pixelPos = this.bubbleGrid.hexToPixel(hexPos);\n                allPositions.push({ hexPos, pixelPos });\n            });\n        }\n        \n        // Calculate how many Mystery Bubbles we want (12.5% of total)\n        const totalBubbles = allPositions.length;\n        const targetMysteryCount = Math.floor(totalBubbles * 0.125);\n        const mysteryPerSide = Math.floor(targetMysteryCount / 2);\n        \n        // Randomly select positions for Mystery Bubbles, ensuring balance\n        const mysteryPositions = new Set<number>();\n        \n        // First, ensure each side gets its fair share\n        for (const side of ['player', 'opponent']) {\n            let sideCount = 0;\n            const maxAttempts = 100; // Prevent infinite loop\n            let attempts = 0;\n            \n            while (sideCount < mysteryPerSide && attempts < maxAttempts) {\n                const index = Math.floor(Math.random() * allPositions.length);\n                if (!mysteryPositions.has(index)) {\n                    const pos = allPositions[index];\n                    const isPlayerSide = pos.pixelPos.y > midPoint;\n                    \n                    if ((side === 'player' && isPlayerSide) || (side === 'opponent' && !isPlayerSide)) {\n                        mysteryPositions.add(index);\n                        sideCount++;\n                    }\n                }\n                attempts++;\n            }\n        }\n        \n        // Create bubbles with balanced Mystery Bubble distribution\n        allPositions.forEach((pos, index) => {\n            if (mysteryPositions.has(index)) {\n                // Create Mystery Bubble\n                const mysteryBubble = new MysteryBubble(this.scene, pos.pixelPos.x, pos.pixelPos.y);\n                mysteryBubble.setGridPosition(pos.hexPos);\n                this.bubbles.push(mysteryBubble);\n                this.gridAttachmentSystem.addGridBubble(mysteryBubble);\n                \n                // Track distribution\n                if (pos.pixelPos.y > midPoint) {\n                    playerSideMysteryCount++;\n                } else {\n                    opponentSideMysteryCount++;\n                }\n            } else {\n                // Create normal bubble\n                const bubble = this.getBubbleFromPool();\n                if (bubble) {\n                    bubble.reset(pos.pixelPos.x, pos.pixelPos.y, Bubble.getRandomColor());\n                    bubble.setGridPosition(pos.hexPos);\n                    this.bubbles.push(bubble);\n                    this.gridAttachmentSystem.addGridBubble(bubble);\n                }\n            }\n        });\n        \n        console.log(`Mystery Bubbles distributed - Player side: ${playerSideMysteryCount}, Opponent side: ${opponentSideMysteryCount}`);\n        \n        // Update objective shield status based on bubbles\n        this.updateObjectiveShield();\n    }\n\n    private getBubbleFromPool(): Bubble | null {\n        const bubble = this.bubblePool.find(b => b.isPooled() || !b.visible);\n        if (bubble) {\n            const index = this.bubblePool.indexOf(bubble);\n            if (index > -1) {\n                this.bubblePool.splice(index, 1);\n            }\n        }\n        return bubble || null;\n    }\n\n    private returnBubbleToPool(bubble: Bubble): void {\n        bubble.returnToPool();\n        this.bubblePool.push(bubble);\n        \n        const index = this.bubbles.indexOf(bubble);\n        if (index > -1) {\n            this.bubbles.splice(index, 1);\n        }\n    }\n\n    private createZoneVisuals(): void {\n        // All zone visuals removed for cleaner UI\n        // Danger zones are now only used for game logic, not visual display\n    }\n\n    private toggleDebug(): void {\n        this.debugEnabled = !this.debugEnabled;\n        \n        if (this.debugEnabled) {\n            this.showDebugOverlay();\n        } else {\n            this.hideDebugOverlay();\n        }\n    }\n\n    private showDebugOverlay(): void {\n        if (!this.debugGraphics) {\n            this.debugGraphics = this.scene.add.graphics();\n            this.debugGraphics.setDepth(Z_LAYERS.DEBUG_OVERLAY);\n        }\n        \n        this.debugGraphics.clear();\n        \n        // Draw zones with transparent colors\n        this.zones.forEach((bounds, zone) => {\n            let color = ZONE_COLORS.NEUTRAL;\n            switch (zone) {\n                case ArenaZone.PLAYER:\n                    color = ZONE_COLORS.PLAYER;\n                    break;\n                case ArenaZone.OPPONENT:\n                    color = ZONE_COLORS.OPPONENT;\n                    break;\n                case ArenaZone.OBJECTIVE:\n                    color = ZONE_COLORS.OBJECTIVE;\n                    break;\n            }\n            \n            this.debugGraphics!.fillStyle(color, ZONE_COLORS.DEBUG_ALPHA);\n            this.debugGraphics!.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);\n            \n            // Add zone labels\n            const text = this.scene.add.text(\n                bounds.x + 10,\n                bounds.y + 10,\n                zone.toUpperCase(),\n                {\n                    fontSize: '14px',\n                    color: '#ffffff',\n                    backgroundColor: '#000000'\n                }\n            );\n            text.setDepth(Z_LAYERS.DEBUG_OVERLAY + 1);\n        });\n        \n        // Draw hexagonal grid\n        this.drawHexGrid();\n        \n        // Draw bubble connections\n        if (this.gridAttachmentSystem && this.debugGraphics) {\n            this.gridAttachmentSystem.debugDrawConnections(this.debugGraphics);\n        }\n    }\n\n    private drawHexGrid(): void {\n        if (!this.debugGraphics) return;\n        \n        this.debugGraphics.lineStyle(1, 0xffffff, 0.3);\n        \n        const bounds = this.bubbleGrid.getGridBounds();\n        for (let q = bounds.minQ; q <= bounds.maxQ; q++) {\n            for (let r = bounds.minR; r <= bounds.maxR; r++) {\n                const hex: IHexPosition = { q, r, s: -q - r };\n                const pixel = this.bubbleGrid.hexToPixel(hex);\n                \n                // Draw hexagon\n                const size = BUBBLE_CONFIG.SIZE / 2;\n                const points: number[] = [];\n                for (let i = 0; i < 6; i++) {\n                    const angle = Math.PI / 3 * i;\n                    points.push(pixel.x + size * Math.cos(angle));\n                    points.push(pixel.y + size * Math.sin(angle));\n                }\n                \n                this.debugGraphics.strokePoints(points, true);\n            }\n        }\n    }\n\n    private hideDebugOverlay(): void {\n        if (this.debugGraphics) {\n            this.debugGraphics.clear();\n        }\n        \n        // Remove zone labels\n        this.scene.children.list.forEach(child => {\n            if (child instanceof Phaser.GameObjects.Text && \n                child.getData('isDebugLabel')) {\n                child.destroy();\n            }\n        });\n    }\n\n    private updateObjectiveShield(): void {\n        // Check if objective still exists (might be null after victory)\n        if (!this.objective) return;\n        \n        // OPTIMIZATION: Use spatial grid for faster neighbor checks\n        const center: IHexPosition = { q: 0, r: 0, s: 0 };\n        const neighbors = this.bubbleGrid.getNeighbors(center);\n        \n        let hasAdjacentBubbles = false;\n        \n        // Use the grid attachment system's spatial grid for O(1) lookups\n        for (const neighbor of neighbors) {\n            // Check if grid position has a bubble (much faster than iterating all bubbles)\n            const gridKey = `${neighbor.q},${neighbor.r}`;\n            if (this.gridAttachmentSystem.hasGridPosition(gridKey)) {\n                hasAdjacentBubbles = true;\n                break;\n            }\n        }\n        \n        // Only update shield if state changed (reduces unnecessary updates)\n        if (hasAdjacentBubbles !== this.cachedShieldState) {\n            this.cachedShieldState = hasAdjacentBubbles;\n            this.objective.setShielded(hasAdjacentBubbles);\n        }\n    }\n\n    public getZoneBounds(zone: ArenaZone): IZoneBounds | undefined {\n        return this.zones.get(zone);\n    }\n\n    public getBubbles(): Bubble[] {\n        return this.bubbles;\n    }\n\n    public getObjective(): Objective {\n        return this.objective;\n    }\n\n    public getPlayerLauncher(): Launcher {\n        return this.playerLauncher;\n    }\n\n    public getOpponentLauncher(): Launcher {\n        return this.opponentLauncher;\n    }\n\n    public update(time: number, delta: number): void {\n        // OPTIMIZATION: Only update input every frame if pointer is active\n        const isPointerActive = this.inputManager.isPointerActive();\n        if (isPointerActive) {\n            this.inputManager.update();\n        } else {\n            // Check input less frequently when not actively aiming\n            this.aimingCheckCounter++;\n            if (this.aimingCheckCounter >= this.AIMING_CHECK_INTERVAL * 2) {\n                this.aimingCheckCounter = 0;\n                this.inputManager.update();\n            }\n        }\n        \n        // OPTIMIZATION: Throttle launcher aiming updates\n        if (isPointerActive) {\n            // Update aiming more frequently when actively aiming\n            this.updateLauncherAiming();\n        } else {\n            // Update less frequently when idle\n            if (this.aimingCheckCounter === 0) {\n                this.updateLauncherAiming();\n            }\n        }\n        \n        // Update shooting system (already optimized internally)\n        this.shootingSystem?.update(delta);\n        \n        // Update power-up systems (only when active)\n        this.powerUpActivation?.update(delta);\n        \n        // OPTIMIZATION: Throttle objective shield checks\n        this.shieldCheckCounter++;\n        if (this.shieldCheckCounter >= this.SHIELD_CHECK_INTERVAL) {\n            this.shieldCheckCounter = 0;\n            this.updateObjectiveShield();\n        }\n        \n        // Check danger zone proximity only every N frames for performance\n        this.dangerCheckCounter++;\n        if (this.dangerCheckCounter >= this.DANGER_CHECK_INTERVAL) {\n            this.dangerCheckCounter = 0;\n            this.checkDangerZoneProximity();\n        }\n        \n        // Update unified feedback system\n        this.unifiedFeedbackSystem?.update(delta);\n    }\n    \n    private updateLauncherAiming(): void {\n        // Get angle from launcher to pointer with constraints\n        const launcherPos = {\n            x: this.playerLauncher.x,\n            y: this.playerLauncher.y\n        };\n        \n        const angle = this.inputManager.getAngleFromWithConstraints(\n            launcherPos.x,\n            launcherPos.y,\n            15,  // Min angle from vertical\n            165  // Max angle from vertical\n        );\n        \n        // Only update launcher rotation if angle has changed significantly (reduces unnecessary updates)\n        const angleDiff = Math.abs(angle - this.lastAimAngle);\n        if (angleDiff > 0.5) { // Only update if angle changed by more than 0.5 degrees\n            this.playerLauncher.setAimAngle(angle);\n            this.lastAimAngle = angle;\n        }\n        \n        // Show aiming feedback when pointer is active\n        const isAiming = this.inputManager.isPointerActive();\n        this.playerLauncher.showAiming(isAiming);\n        \n        // DEBUG: Show aim line when debug is enabled\n        if (this.debugEnabled && this.debugGraphics) {\n            this.debugGraphics.clear();\n            this.showDebugOverlay(); // Redraw grid\n            \n            // Draw aim line\n            this.debugGraphics.lineStyle(2, 0x00ff00, 0.8);\n            this.debugGraphics.beginPath();\n            this.debugGraphics.moveTo(launcherPos.x, launcherPos.y);\n            \n            // Calculate end point based on angle\n            const distance = 200;\n            const radians = Phaser.Math.DegToRad(angle - 90);\n            const endX = launcherPos.x + Math.cos(radians) * distance;\n            const endY = launcherPos.y + Math.sin(radians) * distance;\n            \n            this.debugGraphics.lineTo(endX, endY);\n            this.debugGraphics.strokePath();\n        }\n    }\n    \n    private changeAIDifficulty(difficulty: AIDifficulty): void {\n        if (!this.aiOpponent) return;\n        \n        // console.log(`=== Changing AI Difficulty to ${difficulty} ===`);\n        \n        // Update the static variable to persist difficulty\n        ArenaSystem.currentDifficulty = difficulty;\n        \n        // Stop current AI\n        this.aiOpponent.stop();\n        \n        // Change difficulty  \n        this.aiOpponent.setDifficulty(difficulty);\n        \n        // Restart AI\n        this.scene.time.delayedCall(500, () => {\n            // console.log(`=== Restarting AI with ${difficulty} ===`);\n            this.aiOpponent?.start();\n        });\n        \n        // Show minimal notification\n        this.showDifficultyNotification(difficulty);\n    }\n    \n    private showDifficultyNotification(difficulty: AIDifficulty): void {\n        // Colors for each difficulty\n        const colors = {\n            [AIDifficulty.EASY]: '#4CAF50',\n            [AIDifficulty.MEDIUM]: '#FFA726', \n            [AIDifficulty.HARD]: '#F44336'\n        };\n        \n        // Create small notification\n        const notification = this.scene.add.text(\n            this.scene.cameras.main.centerX,\n            160,\n            `AI: ${difficulty}`,\n            {\n                fontSize: '18px',\n                color: colors[difficulty],\n                fontFamily: 'Arial',\n                fontStyle: 'bold',\n                stroke: '#000000',\n                strokeThickness: 3\n            }\n        );\n        notification.setOrigin(0.5);\n        notification.setDepth(1500);\n        notification.setScale(0);\n        \n        // Animate in\n        this.scene.tweens.add({\n            targets: notification,\n            scale: 1,\n            duration: 200,\n            ease: 'Back.easeOut'\n        });\n        \n        // Fade out after short delay\n        this.scene.time.delayedCall(1200, () => {\n            this.scene.tweens.add({\n                targets: notification,\n                alpha: 0,\n                scale: 0.8,\n                duration: 300,\n                ease: 'Power2',\n                onComplete: () => {\n                    notification.destroy();\n                }\n            });\n        });\n    }\n    \n    private onScoreUpdate = (data: { score: number; delta: number; combo?: number; isAI?: boolean; matchSize?: number; x?: number; y?: number; isOrphanBonus?: boolean; bubbleColor?: number }): void => {\n        if (this.gameOver) return;\n        \n        // Use new ScoreEventManager for all scoring\n        if (this.scoreEventManager) {\n            let context: ScoreContext;\n            \n            if (data.isOrphanBonus) {\n                // Orphan drop event\n                context = {\n                    type: ScoreEventType.ORPHAN_DROP,\n                    baseValue: data.delta,\n                    position: { x: data.x || 0, y: data.y || 0 },\n                    isPlayer: !data.isAI,\n                    bubbleColor: data.bubbleColor,\n                    metadata: {\n                        dropCount: Math.floor(data.delta / 5) // Assuming 5 points per drop\n                    }\n                };\n            } else if (data.matchSize) {\n                // Bubble match event\n                context = {\n                    type: ScoreEventType.BUBBLE_MATCH,\n                    baseValue: data.delta,\n                    position: { x: data.x || 0, y: data.y || 0 },\n                    matchSize: data.matchSize,\n                    isPlayer: !data.isAI,\n                    bubbleColor: data.bubbleColor\n                };\n            } else {\n                // Generic score event\n                context = {\n                    type: ScoreEventType.SPECIAL_BONUS,\n                    baseValue: data.delta,\n                    position: { x: data.x || 0, y: data.y || 0 },\n                    isPlayer: !data.isAI,\n                    bubbleColor: data.bubbleColor\n                };\n            }\n            \n            this.scoreEventManager.queueEvent(context);\n        } else {\n            // Fallback to old system if new system not initialized\n            let finalScore = data.delta;\n            \n            if (data.isOrphanBonus) {\n                finalScore = data.delta;\n            } else if (data.matchSize && this.comboManager) {\n                finalScore = this.comboManager.calculateScore(data.matchSize, data.x, data.y, data.bubbleColor);\n            }\n            \n            if (data.isAI) {\n                this.aiScore += finalScore;\n                this.enhancedScoreDisplay?.updateOpponentScore(this.aiScore);\n            } else {\n                this.playerScore += finalScore;\n                this.enhancedScoreDisplay?.updatePlayerScore(this.playerScore);\n            }\n        }\n    }\n    \n    private checkChestHit = (bubble: Bubble): void => {\n        if (this.gameOver || !this.objective || !bubble.visible) return;\n        \n        // Check if bubble hit the chest during flight\n        const distance = Phaser.Math.Distance.Between(\n            bubble.x, bubble.y,\n            this.objective.x, this.objective.y\n        );\n        \n        // Direct hit detection - bubble must overlap with chest\n        // The chest size is this.config.objectiveSize (60) and bubble is BUBBLE_CONFIG.SIZE (30)\n        // So combined radius is (60/2 + 30/2) = 45\n        const hitRadius = (this.config.objectiveSize / 2) + (BUBBLE_CONFIG.SIZE / 2);\n        \n        if (distance < hitRadius) {\n            const shooter = bubble.getShooter();\n            const playerWins = shooter === 'player';\n            \n            // console.log(`🎯 TREASURE CHEST DIRECT HIT by ${shooter}! Distance: ${distance.toFixed(1)} < ${hitRadius}`);\n            // console.log(`INSTANT VICTORY for ${playerWins ? 'PLAYER' : 'AI'}!`);\n            \n            // Call the hit method on the objective to trigger sound and animation\n            this.objective.hit();\n            \n            // Mark game as over immediately to prevent multiple triggers\n            this.gameOver = true;\n            \n            // Stop the bubble\n            bubble.setVisible(false);\n            \n            // Store objective reference before nulling\n            const obj = this.objective;\n            this.objective = null as any;\n            \n            // Play victory animation\n            obj.playVictoryAnimation(() => {\n                this.triggerGameOver(playerWins);\n            });\n        }\n    }\n    \n    private checkVictoryCondition = (data: { bubble: Bubble; position: IHexPosition }): void => {\n        if (this.gameOver) return;\n        \n        const bubble = data.bubble;\n        \n        // Only check bubbles that are actually attached and visible\n        if (!bubble.visible || !bubble.getGridPosition()) {\n            return;\n        }\n        \n        // Check for defeat conditions (bubbles reaching danger zones)\n        const screenHeight = this.scene.cameras.main.height;\n        const playerDangerY = screenHeight - DANGER_ZONE_CONFIG.PLAYER_OFFSET;\n        const opponentDangerY = DANGER_ZONE_CONFIG.OPPONENT_OFFSET;\n        \n        // Check if any bubble crossed player's danger line (player loses)\n        if (bubble.y > playerDangerY) {\n            // console.log('💀 Bubble crossed PLAYER danger line! Player loses!');\n            // console.log(`Bubble Y: ${bubble.y}, Danger Line: ${playerDangerY}`);\n            this.triggerGameOver(false); // Player loses\n            return;\n        }\n        \n        // Check if any bubble crossed opponent's danger line (opponent loses, player wins)\n        // Only check for real grid positions, not falling bubbles\n        if (bubble.y < opponentDangerY) {\n            // Verify this bubble is actually in the grid at this position\n            const hexPos = bubble.getGridPosition();\n            if (hexPos) {\n                const expectedPos = this.bubbleGrid.hexToPixel(hexPos);\n                // Check if bubble is actually at its grid position (not falling)\n                const distance = Phaser.Math.Distance.Between(bubble.x, bubble.y, expectedPos.x, expectedPos.y);\n                \n                if (distance < 5) {\n                    // Bubble is truly at grid position and in danger zone\n                    console.log('💀 Bubble crossed OPPONENT danger line! Opponent loses!');\n                    console.log(`Bubble Y: ${bubble.y}, Danger Line: ${opponentDangerY}`);\n                    this.triggerGameOver(true); // Player wins\n                    return;\n                }\n            }\n        }\n    }\n    \n    private wasAIShot(bubble: Bubble): boolean {\n        // Track the last shooter - for now we can check the last shot event\n        // This is a simple heuristic: if the bubble was attached high, it likely came from below (player)\n        // If attached low, it came from above (AI)\n        // Better would be to track shooter in bubble data\n        \n        // Simple check: was the bubble's initial trajectory downward (AI) or upward (Player)?\n        // We'll check based on the position where it attached\n        const centerY = this.scene.cameras.main.centerY;\n        \n        // If bubble is in upper half and moving toward center, likely from AI\n        // This is simplified - ideally we'd track the shooter\n        return bubble.y < centerY - 100;\n    }\n    \n    private triggerGameOver(playerWins: boolean): void {\n        // Already set to true in checkChestHit, but double-check\n        if (this.gameOver && (this.victoryScreen || this.defeatScreen)) return;\n        \n        this.gameOver = true;\n        \n        // Stop all game systems\n        this.scene.physics.pause();\n        this.aiOpponent?.stop();\n        this.shootingSystem?.destroy();\n        \n        // Emit game over events for sound system\n        if (playerWins) {\n            this.scene.events.emit('victory');\n        } else {\n            this.scene.events.emit('defeat');\n        }\n        \n        // Show appropriate screen\n        if (playerWins) {\n            console.log('🎉 VICTORY! Player wins!');\n            \n            // Debug callback functions\n            console.log('Creating VictoryScreen with callbacks:');\n            console.log('restartGame type:', typeof this.restartGame);\n            console.log('returnToMenu type:', typeof this.returnToMenu);\n            \n            this.victoryScreen = new VictoryScreen(\n                this.scene,\n                this.playerScore,\n                this.restartGame,\n                this.returnToMenu\n            );\n            \n            // Camera celebration effect\n            this.scene.cameras.main.flash(500, 255, 215, 0);\n        } else {\n            console.log('💀 DEFEAT! AI wins!');\n            \n            // Debug callback functions\n            console.log('Creating DefeatScreen with callbacks:');\n            console.log('restartGame type:', typeof this.restartGame);\n            console.log('returnToMenu type:', typeof this.returnToMenu);\n            \n            this.defeatScreen = new DefeatScreen(\n                this.scene,\n                this.playerScore,\n                this.restartGame,\n                this.returnToMenu\n            );\n            \n            // Camera fade effect\n            this.scene.cameras.main.fade(500, 0, 0, 0, false);\n            this.scene.cameras.main.once('camerafadeoutcomplete', () => {\n                this.scene.cameras.main.fadeIn(500);\n            });\n        }\n        \n        // Fire game over event\n        this.scene.events.emit('game-over', { \n            winner: playerWins ? 'player' : 'ai', \n            playerScore: this.playerScore,\n            aiScore: this.aiScore\n        });\n    }\n    \n    private restartGame = (): void => {\n        console.log('🔄 RESTART BUTTON CLICKED!');\n        \n        try {\n            // Prevent multiple clicks\n            if (this.isRestarting) {\n                console.log('Already restarting, ignoring click');\n                return;\n            }\n            this.isRestarting = true;\n            \n            console.log('IMMEDIATE RESTART - No fade, direct action');\n            \n            // Clean up UI elements immediately\n            if (this.victoryScreen) {\n                this.victoryScreen.destroy();\n                this.victoryScreen = undefined;\n            }\n            if (this.defeatScreen) {\n                this.defeatScreen.destroy();\n                this.defeatScreen = undefined;\n            }\n            \n            console.log('UI cleaned up, attempting restart methods...');\n            \n            // Try Phaser method first (immediate)\n            console.log('Method 0: Phaser scene destruction and recreation');\n            try {\n                // Destroy all game objects\n                this.scene.children.removeAll(true);\n                \n                // Reset game state completely\n                this.gameOver = false;\n                this.playerScore = 0;\n                this.aiScore = 0;\n                this.isRestarting = false;\n                \n                // Restart the scene using scene manager\n                const sceneKey = this.scene.scene.key;\n                console.log('Restarting scene with key:', sceneKey);\n                \n                this.scene.scene.restart();\n                \n                console.log('✅ Phaser restart method attempted');\n                \n            } catch (phaserError) {\n                console.error('Phaser restart failed:', phaserError);\n                \n                // Fallback to page reload methods\n                console.log('Fallback: Attempting page reload methods...');\n                \n                // Method 1: Force reload with timestamp\n                console.log('Method 1: Force reload with timestamp');\n                window.location.href = window.location.href.split('?')[0] + '?t=' + Date.now();\n                \n                // Method 2: Backup - traditional reload after delay\n                setTimeout(() => {\n                    console.log('Method 2: Traditional reload backup');\n                    window.location.reload(true);\n                }, 100);\n            }\n            \n        } catch (error) {\n            console.error('❌ Error in restartGame, trying alternative methods:', error);\n            \n            // Try alternative reload methods\n            try {\n                console.log('Emergency reload attempt 1: document.location.reload()');\n                (document.location as any).reload(true);\n            } catch (e2) {\n                console.log('Emergency reload attempt 2: history manipulation');\n                window.history.go(0);\n            }\n        }\n    }\n    \n    private returnToMenu = (): void => {\n        console.log('🏠 MENU BUTTON CLICKED!');\n        \n        try {\n            // Prevent multiple clicks\n            if (this.isRestarting) {\n                console.log('Already transitioning, ignoring click');\n                return;\n            }\n            this.isRestarting = true;\n            \n            console.log('MENU - Using same method as Try Again (works!)');\n            \n            // Clean up UI elements immediately\n            if (this.victoryScreen) {\n                this.victoryScreen.destroy();\n                this.victoryScreen = undefined;\n            }\n            if (this.defeatScreen) {\n                this.defeatScreen.destroy();\n                this.defeatScreen = undefined;\n            }\n            \n            console.log('UI cleaned up for menu, using restart method...');\n            \n            // Use the EXACT same method that works for Try Again\n            try {\n                // Destroy all game objects\n                this.scene.children.removeAll(true);\n                \n                // Reset game state completely\n                this.gameOver = false;\n                this.playerScore = 0;\n                this.aiScore = 0;\n                this.isRestarting = false;\n                \n                // Restart the scene using scene manager\n                const sceneKey = this.scene.scene.key;\n                console.log('Menu: Restarting scene with key:', sceneKey);\n                \n                this.scene.scene.restart();\n                \n                console.log('✅ Menu using restart method (same as Try Again)');\n                \n            } catch (phaserError) {\n                console.error('Menu restart failed:', phaserError);\n                \n                // Same fallback as Try Again\n                console.log('Menu Fallback: Force reload...');\n                window.location.href = window.location.href.split('?')[0] + '?t=' + Date.now();\n            }\n            \n        } catch (error) {\n            console.error('❌ Error in returnToMenu:', error);\n            // Force restart as last resort\n            window.location.reload();\n        }\n    }\n    \n    private checkDangerZoneProximity(): void {\n        if (this.gameOver) return;\n        \n        const screenHeight = this.scene.cameras.main.height;\n        const playerDangerY = screenHeight - DANGER_ZONE_CONFIG.PLAYER_OFFSET;\n        const opponentDangerY = DANGER_ZONE_CONFIG.OPPONENT_OFFSET;\n        \n        let nearDanger = false;\n        const warningDistance = 40; // Start warning when bubbles are within 40 pixels\n        \n        // Check all grid bubbles\n        const gridBubbles = this.gridAttachmentSystem.getGridBubbles();\n        \n        // Use more efficient iteration with early exit\n        for (let i = 0; i < gridBubbles.length; i++) {\n            const bubble = gridBubbles[i];\n            if (!bubble.visible) continue;\n            \n            // Check proximity to player danger zone\n            const playerDistance = playerDangerY - bubble.y;\n            if (playerDistance < warningDistance && playerDistance > 0) {\n                nearDanger = true;\n                this.activateDangerWarning(this.playerDangerLine, true);\n                break; // Exit early once we find danger\n            }\n            \n            // Check proximity to opponent danger zone\n            const opponentDistance = bubble.y - opponentDangerY;\n            if (opponentDistance < warningDistance && opponentDistance > 0) {\n                nearDanger = true;\n                this.activateDangerWarning(this.opponentDangerLine, false);\n                break; // Exit early once we find danger\n            }\n        }\n        \n        // Deactivate warning if no bubbles are near danger\n        if (!nearDanger && this.dangerWarningActive) {\n            this.deactivateDangerWarning();\n        }\n    }\n    \n    private activateDangerWarning(dangerLine: Phaser.GameObjects.Graphics | undefined, isPlayer: boolean): void {\n        if (!dangerLine || this.dangerWarningActive) return;\n        \n        this.dangerWarningActive = true;\n        \n        // Emit danger warning event for sound system\n        this.scene.events.emit('danger-warning', { isPlayer });\n        \n        // Pulse animation for danger line\n        this.scene.tweens.add({\n            targets: dangerLine,\n            alpha: { from: 0.6, to: 1 },\n            duration: DANGER_ZONE_CONFIG.PULSE_DURATION / 2,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Flash effect for player only\n        if (isPlayer) {\n            this.scene.cameras.main.flash(200, 255, 0, 0, false);\n        }\n    }\n    \n    private deactivateDangerWarning(): void {\n        this.dangerWarningActive = false;\n        \n        // Stop animations\n        if (this.playerDangerLine) {\n            this.scene.tweens.killTweensOf(this.playerDangerLine);\n            this.playerDangerLine.setAlpha(1);\n        }\n        \n        if (this.opponentDangerLine) {\n            this.scene.tweens.killTweensOf(this.opponentDangerLine);\n            this.opponentDangerLine.setAlpha(1);\n        }\n    }\n    \n    public destroy(): void {\n        this.inputManager?.destroy();\n        this.shootingSystem?.destroy();\n        this.gridAttachmentSystem?.clearGrid();\n        this.matchDetectionSystem?.reset();\n        this.aiOpponent?.destroy();\n        this.bubbles.forEach(bubble => bubble.destroy());\n        this.bubblePool.forEach(bubble => bubble.destroy());\n        this.objective?.destroy();\n        this.playerLauncher?.destroy();\n        this.opponentLauncher?.destroy();\n        this.debugGraphics?.destroy();\n        this.enhancedScoreDisplay?.destroy();\n        this.comboManager?.reset();\n        this.scoreEventManager?.destroy();\n        this.unifiedFeedbackSystem?.destroy();\n        this.paintSplatterSystem?.destroy();\n        this.victoryScreen?.destroy();\n        this.defeatScreen?.destroy();\n        // this.playerPowerUpInventory?.destroy(); // Arsenal now integrated in Launcher\n        // this.opponentPowerUpInventory?.destroy(); // No longer created\n        \n        // Remove event listeners\n        this.scene.events.off('score-update', this.onScoreUpdate, this);\n        this.scene.events.off('bubble-attached', this.checkVictoryCondition, this);\n        this.scene.events.off('bubble-position-update', this.checkChestHit, this);\n    }\n    \n    /**\n     * Get paint splatter system for configuration or monitoring\n     */\n    public getPaintSplatterSystem(): PaintSplatterSystem | undefined {\n        return this.paintSplatterSystem;\n    }\n    \n    /**\n     * Set graphics quality preset (affects paint splatters and other visual effects)\n     */\n    public setGraphicsQuality(quality: 'low' | 'medium' | 'high' | 'ultra'): void {\n        // Update paint splatter quality\n        this.paintSplatterSystem?.setQualityPreset(quality);\n        \n        // Could update other visual systems here in the future\n        console.log(`Graphics quality set to: ${quality}`);\n    }\n}","/**\n * RealSoundSystem - Simple MP3 sound playback system\n * Uses Phaser's built-in audio system to play real sound files\n */\n\nimport { Scene } from 'phaser';\nimport { ASSET_KEYS } from '@/config/AssetManifest';\n\nexport class RealSoundSystem {\n    private scene: Scene;\n    private sounds: Map<string, Phaser.Sound.BaseSound> = new Map();\n    private muted: boolean = false;\n    private masterVolume: number = 0.5;\n    \n    // Volume settings for different sound types\n    private volumes = {\n        shoot: 0.3,\n        attach: 0.4,\n        combo: 0.6,\n        celebration: 1.0,  // Maximum volume for celebration\n        arsenal: 0.5,\n        victory: 0.9,\n        background: 0.2\n    };\n\n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.initializeSounds();\n    }\n\n    private initializeSounds(): void {\n        console.log('RealSoundSystem: Initializing sounds...');\n        \n        // Check if sounds are loaded\n        const audioCache = this.scene.cache.audio;\n        \n        Object.values(ASSET_KEYS.AUDIO).forEach(key => {\n            if (audioCache.exists(key)) {\n                console.log(`RealSoundSystem: Sound ${key} is available`);\n            } else {\n                console.warn(`RealSoundSystem: Sound ${key} not found in cache`);\n            }\n        });\n    }\n\n    /**\n     * Play bubble shoot sound\n     */\n    public playShootSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.BUBBLE_SHOOT, this.volumes.shoot);\n    }\n\n    /**\n     * Play bubble attach sound\n     */\n    public playAttachSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.BUBBLE_ATTACH, this.volumes.attach);\n    }\n\n    /**\n     * Play bubbles drop sound (slower playback, lower volume)\n     */\n    public playBubblesDropSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.BUBBLES_DROP, this.volumes.combo * 0.6, 0.85); // 40% quieter, 15% slower\n    }\n\n    /**\n     * Play combo sound based on size\n     */\n    public playComboSound(size: number): void {\n        if (this.muted) return;\n        \n        let soundKey: string;\n        let volume = this.volumes.combo;\n        \n        if (size === 3) {\n            soundKey = ASSET_KEYS.AUDIO.COMBO_3;\n            this.playSound(soundKey, volume);\n        } else if (size === 4) {\n            soundKey = ASSET_KEYS.AUDIO.COMBO_4;\n            this.playSound(soundKey, volume);\n        } else if (size >= 5) {\n            soundKey = ASSET_KEYS.AUDIO.COMBO_5_PLUS;\n            volume = this.volumes.combo * 0.7; // Quieter, more subtle\n            \n            // Play combo 5+ slower and quieter for more dramatic effect\n            this.playSound(soundKey, volume, 0.85); // 30% quieter, 15% slower\n            \n            // ALWAYS play celebration for 5+ combos (not just 7+)\n            setTimeout(() => {\n                this.playSound(ASSET_KEYS.AUDIO.COMBO_CELEBRATION, this.volumes.celebration); // Full celebration volume\n            }, 200);\n        } else {\n            return; // No sound for less than 3\n        }\n    }\n\n    /**\n     * Play match sound (alias for combo sound)\n     */\n    public playMatchSound(matchSize: number): void {\n        this.playComboSound(matchSize);\n    }\n\n    /**\n     * Play arsenal pickup sound\n     */\n    public playArsenalPickupSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.ARSENAL_PICKUP, this.volumes.arsenal);\n    }\n\n    /**\n     * Play success objective sound (for mystery box/treasure chest)\n     */\n    public playSuccessObjectiveSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.SUCCESS_OBJECTIVE, this.volumes.arsenal * 1.2); // Slightly louder for impact\n    }\n\n    /**\n     * Play victory sound\n     */\n    public playVictorySound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.VICTORY, this.volumes.victory);\n    }\n\n    /**\n     * Play defeat sound\n     */\n    public playDefeatSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.DEFEAT, this.volumes.victory * 0.7);\n    }\n\n    /**\n     * Play power-up sound (using arsenal pickup)\n     */\n    public playPowerUpSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.ARSENAL_PICKUP, this.volumes.arsenal);\n    }\n\n    /**\n     * Play UI click sound (using attach sound at lower volume)\n     */\n    public playClickSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.BUBBLE_ATTACH, this.volumes.attach * 0.5);\n    }\n\n    /**\n     * Play background music\n     */\n    public playBackgroundMusic(): Phaser.Sound.BaseSound | undefined {\n        if (this.muted) return undefined;\n        \n        const key = ASSET_KEYS.AUDIO.BACKGROUND_MUSIC;\n        \n        // Check if we have background music file\n        if (!this.scene.cache.audio.exists(key)) {\n            console.log('RealSoundSystem: No background music file found');\n            return undefined;\n        }\n        \n        // Stop any existing background music\n        const existingMusic = this.sounds.get('background-music');\n        if (existingMusic) {\n            existingMusic.stop();\n        }\n        \n        const music = this.scene.sound.add(key, {\n            volume: this.volumes.background * this.masterVolume,\n            loop: true\n        });\n        \n        this.sounds.set('background-music', music);\n        music.play();\n        \n        return music;\n    }\n\n    /**\n     * Helper to play a sound\n     * @param key Sound key\n     * @param volume Volume level (0-1)\n     * @param rate Playback rate (1 = normal, 0.5 = half speed, 2 = double speed)\n     */\n    private playSound(key: string, volume: number = 0.5, rate: number = 1): void {\n        try {\n            if (!this.scene.cache.audio.exists(key)) {\n                console.warn(`RealSoundSystem: Sound ${key} not loaded`);\n                return;\n            }\n            \n            const sound = this.scene.sound.add(key, {\n                volume: volume * this.masterVolume,\n                rate: rate // Playback speed\n            });\n            \n            sound.play();\n            \n            // Clean up after playing\n            sound.once('complete', () => {\n                sound.destroy();\n            });\n        } catch (error) {\n            console.error(`RealSoundSystem: Error playing sound ${key}:`, error);\n        }\n    }\n\n    /**\n     * Toggle mute\n     */\n    public toggleMute(): boolean {\n        this.muted = !this.muted;\n        \n        // Mute/unmute all playing sounds\n        this.scene.sound.mute = this.muted;\n        \n        return this.muted;\n    }\n\n    /**\n     * Set master volume\n     */\n    public setMasterVolume(volume: number): void {\n        this.masterVolume = Math.max(0, Math.min(1, volume));\n        this.scene.sound.volume = this.masterVolume;\n    }\n\n    /**\n     * Test all sounds\n     */\n    public testAllSounds(): void {\n        console.log('RealSoundSystem: Testing all sounds...');\n        \n        const sounds = [\n            { key: ASSET_KEYS.AUDIO.BUBBLE_SHOOT, name: 'Shoot' },\n            { key: ASSET_KEYS.AUDIO.BUBBLE_ATTACH, name: 'Attach' },\n            { key: ASSET_KEYS.AUDIO.COMBO_3, name: 'Combo 3' },\n            { key: ASSET_KEYS.AUDIO.COMBO_4, name: 'Combo 4' },\n            { key: ASSET_KEYS.AUDIO.COMBO_5_PLUS, name: 'Combo 5+' },\n            { key: ASSET_KEYS.AUDIO.VICTORY, name: 'Victory' }\n        ];\n        \n        let delay = 0;\n        sounds.forEach(({ key, name }) => {\n            setTimeout(() => {\n                console.log(`Playing: ${name}`);\n                this.playSound(key, 0.5);\n            }, delay);\n            delay += 1000;\n        });\n    }\n\n    /**\n     * Get system info\n     */\n    public getInfo(): any {\n        return {\n            muted: this.muted,\n            masterVolume: this.masterVolume,\n            soundsLoaded: Object.values(ASSET_KEYS.AUDIO).filter(key => \n                this.scene.cache.audio.exists(key)\n            ).length,\n            totalSounds: Object.values(ASSET_KEYS.AUDIO).length\n        };\n    }\n\n    /**\n     * Cleanup\n     */\n    public destroy(): void {\n        // Stop all sounds\n        this.sounds.forEach(sound => {\n            sound.stop();\n            sound.destroy();\n        });\n        this.sounds.clear();\n    }\n}","/**\n * TweenOptimizer - Manages and optimizes tweens for better performance\n * Keeps all visual effects but makes them more efficient\n */\nexport class TweenOptimizer {\n    private static instance: TweenOptimizer | null = null;\n    private scene: Phaser.Scene;\n    private activeTweens: Map<string, Phaser.Tweens.Tween> = new Map();\n    private tweenGroups: Map<string, Set<string>> = new Map();\n    private frameCounter: number = 0;\n    \n    constructor(scene: Phaser.Scene) {\n        this.scene = scene;\n        TweenOptimizer.instance = this;\n    }\n    \n    public static getInstance(scene?: Phaser.Scene): TweenOptimizer | null {\n        if (!TweenOptimizer.instance && scene) {\n            TweenOptimizer.instance = new TweenOptimizer(scene);\n        }\n        return TweenOptimizer.instance;\n    }\n    \n    /**\n     * Create an optimized infinite tween that can be shared between similar objects\n     * This keeps ALL animations but reduces overhead\n     */\n    public createOptimizedTween(\n        id: string,\n        targets: any,\n        props: any,\n        duration: number,\n        options: {\n            yoyo?: boolean;\n            repeat?: number;\n            ease?: string;\n            delay?: number;\n            group?: string; // Group similar tweens together\n            stagger?: number; // Stagger start times for visual variety\n        } = {}\n    ): Phaser.Tweens.Tween | null {\n        // If this is an infinite tween for a group, try to reuse existing\n        if (options.repeat === -1 && options.group) {\n            const existingTween = this.getGroupTween(options.group);\n            if (existingTween && this.canShareTween(existingTween, props)) {\n                // Add target to existing tween instead of creating new one\n                this.addTargetToTween(existingTween, targets, options.stagger);\n                return existingTween;\n            }\n        }\n        \n        // Create new optimized tween\n        const tweenConfig: any = {\n            targets,\n            ...props,\n            duration,\n            yoyo: options.yoyo || false,\n            repeat: options.repeat || 0,\n            ease: options.ease || 'Linear',\n            delay: options.delay || 0\n        };\n        \n        // For infinite tweens, add optimization\n        if (options.repeat === -1) {\n            // Reduce update frequency for less critical animations\n            tweenConfig.callbackScope = this;\n            tweenConfig.onUpdate = this.throttleUpdate.bind(this, id);\n        }\n        \n        const tween = this.scene.tweens.add(tweenConfig);\n        \n        this.activeTweens.set(id, tween);\n        \n        if (options.group) {\n            if (!this.tweenGroups.has(options.group)) {\n                this.tweenGroups.set(options.group, new Set());\n            }\n            this.tweenGroups.get(options.group)!.add(id);\n        }\n        \n        return tween;\n    }\n    \n    /**\n     * Throttle tween updates for better performance\n     */\n    private throttleUpdate(id: string): void {\n        // Only update visual every few frames for non-critical animations\n        this.frameCounter++;\n        if (this.frameCounter % 2 === 0) {\n            // Update happens naturally, just skip some frames\n            return;\n        }\n    }\n    \n    /**\n     * Check if a tween can be shared with new targets\n     */\n    private canShareTween(tween: Phaser.Tweens.Tween, props: any): boolean {\n        // Check if properties match (simplified check)\n        const tweenData = tween.data[0];\n        if (!tweenData) return false;\n        \n        for (const key in props) {\n            if (tweenData.key === key) {\n                return true; // Can share if at least one property matches\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Add a target to an existing tween\n     */\n    private addTargetToTween(tween: Phaser.Tweens.Tween, target: any, stagger?: number): void {\n        // In Phaser, we can't directly add targets to running tweens\n        // Instead, we'll create a linked tween with slight offset for variety\n        const tweenData = tween.data[0];\n        if (!tweenData) return;\n        \n        const linkedConfig: any = {\n            targets: target,\n            duration: tweenData.duration,\n            yoyo: tween.yoyo,\n            repeat: tween.repeat,\n            ease: tweenData.ease,\n            delay: stagger || 0\n        };\n        \n        // Copy properties\n        tween.data.forEach((data: any) => {\n            linkedConfig[data.key] = {\n                from: data.start,\n                to: data.end\n            };\n        });\n        \n        this.scene.tweens.add(linkedConfig);\n    }\n    \n    /**\n     * Get a tween from a group\n     */\n    private getGroupTween(group: string): Phaser.Tweens.Tween | null {\n        const groupIds = this.tweenGroups.get(group);\n        if (!groupIds || groupIds.size === 0) return null;\n        \n        const firstId = groupIds.values().next().value;\n        return this.activeTweens.get(firstId) || null;\n    }\n    \n    /**\n     * Remove a tween\n     */\n    public removeTween(id: string): void {\n        const tween = this.activeTweens.get(id);\n        if (tween) {\n            tween.destroy();\n            this.activeTweens.delete(id);\n            \n            // Remove from groups\n            this.tweenGroups.forEach((ids, group) => {\n                ids.delete(id);\n                if (ids.size === 0) {\n                    this.tweenGroups.delete(group);\n                }\n            });\n        }\n    }\n    \n    /**\n     * Pause all tweens in a group\n     */\n    public pauseGroup(group: string): void {\n        const groupIds = this.tweenGroups.get(group);\n        if (!groupIds) return;\n        \n        groupIds.forEach(id => {\n            const tween = this.activeTweens.get(id);\n            if (tween) {\n                tween.pause();\n            }\n        });\n    }\n    \n    /**\n     * Resume all tweens in a group\n     */\n    public resumeGroup(group: string): void {\n        const groupIds = this.tweenGroups.get(group);\n        if (!groupIds) return;\n        \n        groupIds.forEach(id => {\n            const tween = this.activeTweens.get(id);\n            if (tween) {\n                tween.resume();\n            }\n        });\n    }\n    \n    /**\n     * Clean up\n     */\n    public destroy(): void {\n        this.activeTweens.forEach(tween => tween.destroy());\n        this.activeTweens.clear();\n        this.tweenGroups.clear();\n        TweenOptimizer.instance = null;\n    }\n    \n    /**\n     * Get stats for debugging\n     */\n    public getStats(): { totalTweens: number; groups: number; tweensPerGroup: Map<string, number> } {\n        const tweensPerGroup = new Map<string, number>();\n        this.tweenGroups.forEach((ids, group) => {\n            tweensPerGroup.set(group, ids.size);\n        });\n        \n        return {\n            totalTweens: this.activeTweens.size,\n            groups: this.tweenGroups.size,\n            tweensPerGroup\n        };\n    }\n}","import { Scene } from 'phaser';\nimport { SceneKeys, ISceneData, GameEvents } from '@/types/GameTypes';\nimport { SceneManager } from '@/systems/core/SceneManager';\nimport { ArenaSystem, AIDifficulty } from '@/systems/gameplay/ArenaSystem';\nimport { PerformanceMonitor } from '@/utils/PerformanceMonitor';\nimport { RealSoundSystem } from '@/systems/audio/RealSoundSystem';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { TweenOptimizer } from '@/systems/visual/TweenOptimizer';\nimport { BackgroundSystem } from '@/systems/visual/BackgroundSystem';\n\nexport class GameScene extends Scene {\n    private sceneManager!: SceneManager;\n    private performanceMonitor!: PerformanceMonitor;\n    private arenaSystem!: ArenaSystem;\n    private soundSystem!: RealSoundSystem;\n    private backgroundSystem!: BackgroundSystem;\n    private backgroundMusic: Phaser.Sound.BaseSound | undefined;\n    private fpsText!: Phaser.GameObjects.Text;\n    private frameCount: number = 0;\n    private lastFPSUpdate: number = 0;\n    // debugText removed for clean production UI\n    // scoreText removed - using player-specific scores\n    private isPaused: boolean = false;\n    private tweenOptimizer!: TweenOptimizer;\n\n    constructor() {\n        super({ key: SceneKeys.GAME });\n    }\n\n    public preload(): void {\n        // No background image loading needed - using procedural graphics\n        \n        // Cannon sprite loading disabled - using procedural graphics\n        // this.load.image('cannon', 'assets/sprites/cannon2_transparent.png');\n        \n        // Load background music\n        // Note: Place background_music.mp3 in public/assets/audio/\n        this.load.audio('background-music', 'assets/audio/background_music.mp3');\n    }\n\n    public init(data: ISceneData): void {\n        console.log('GameScene: Initializing game arena...');\n        \n        // Clean up any existing background music before reinitializing\n        if (this.backgroundMusic) {\n            this.backgroundMusic.stop();\n            this.backgroundMusic.destroy();\n            this.backgroundMusic = undefined;\n        }\n        \n        // Store theme selection if provided\n        if (data && (data as any).theme) {\n            this.registry.set('gameTheme', (data as any).theme);\n        }\n        \n        // Set isCapacitor flag in registry for global access\n        const isCapacitor = !!(window as any).Capacitor;\n        this.game.registry.set('isCapacitor', isCapacitor);\n        \n        this.sceneManager = SceneManager.getInstance();\n        this.sceneManager.setCurrentScene(SceneKeys.GAME);\n        this.performanceMonitor = new PerformanceMonitor();\n        this.performanceMonitor.setEventEmitter(this.game.events);\n        this.isPaused = false;\n    }\n\n    public create(): void {\n        try {\n            // Set a visible background color first\n            this.cameras.main.setBackgroundColor('#3498db');\n            \n            // Initialize TweenOptimizer for performance\n            this.tweenOptimizer = new TweenOptimizer(this);\n            \n            console.log('GameScene: Creating background...');\n            this.createBackground();\n            \n            console.log('GameScene: Initializing sound system...');\n            this.createSoundSystem();\n            \n            console.log('GameScene: Starting background music...');\n            this.createBackgroundMusic();\n            \n            console.log('GameScene: Creating arena...');\n            this.createArena();\n            \n            console.log('GameScene: Creating UI...');\n            this.createUI();\n            \n            console.log('GameScene: Setting up input handlers...');\n            this.setupInputHandlers();\n            \n            // Emit arena ready event\n            this.game.events.emit(GameEvents.SCENE_READY, {\n                scene: SceneKeys.GAME\n            });\n            \n            console.log('GameScene: Arena setup complete');\n        } catch (error) {\n            console.error('GameScene: Error during creation:', error);\n        }\n    }\n\n    private createSoundSystem(): void {\n        try {\n            this.soundSystem = new RealSoundSystem(this);\n            console.log('GameScene: Sound system initialized successfully');\n        } catch (error) {\n            console.error('GameScene: Failed to initialize sound system:', error);\n            // Continue without sound system - game should still be playable\n        }\n    }\n    \n    private createBackgroundMusic(): void {\n        try {\n            // Stop any existing background music first to prevent overlapping\n            if (this.backgroundMusic) {\n                this.backgroundMusic.stop();\n                this.backgroundMusic.destroy();\n                this.backgroundMusic = undefined;\n            }\n            \n            // Use the sound system to play background music\n            if (this.soundSystem) {\n                this.backgroundMusic = this.soundSystem.playBackgroundMusic();\n                if (this.backgroundMusic) {\n                    console.log('GameScene: Background music started');\n                } else {\n                    console.log('GameScene: No background music available');\n                }\n            }\n        } catch (error) {\n            console.error('GameScene: Failed to create background music:', error);\n        }\n    }\n\n    private createBackground(): void {\n        // Detect device performance for quality settings\n        const isCapacitor = this.registry.get('isCapacitor');\n        const quality = isCapacitor ? 'medium' : 'high'; // Lower quality on mobile for performance\n        \n        // Get selected theme or default to ocean\n        const selectedTheme = this.registry.get('gameTheme') || this.registry.get('selectedTheme') || 'ocean';\n        \n        // Create the new advanced background system\n        this.backgroundSystem = new BackgroundSystem(this, {\n            theme: selectedTheme as any,\n            quality: quality,\n            enableParticles: true,\n            enableAnimation: true\n        });\n        \n        console.log(`GameScene: Created advanced background system with ${selectedTheme} theme and ${quality} quality`);\n    }\n    \n    // Old methods commented out - replaced by BackgroundSystem\n    /*\n    private createGeometricPattern(width: number, height: number): void {\n        const patternGraphics = this.add.graphics();\n        \n        // Create subtle hexagonal pattern\n        const hexSize = 40;\n        const hexColor = 0x1e3a5f;\n        const hexAlpha = 0.1;\n        \n        patternGraphics.lineStyle(1, hexColor, hexAlpha);\n        \n        // Draw hexagonal grid pattern\n        const hexWidth = hexSize * Math.sqrt(3);\n        const hexHeight = hexSize * 2;\n        const vertSpacing = hexHeight * 0.75;\n        \n        for (let row = 0; row < Math.ceil(height / vertSpacing) + 2; row++) {\n            for (let col = 0; col < Math.ceil(width / hexWidth) + 2; col++) {\n                const x = col * hexWidth + (row % 2) * (hexWidth / 2) - hexWidth;\n                const y = row * vertSpacing - vertSpacing;\n                \n                if (x < width + hexSize && y < height + hexSize) {\n                    this.drawHexagon(patternGraphics, x, y, hexSize);\n                }\n            }\n        }\n        \n        patternGraphics.setDepth(Z_LAYERS.BACKGROUND + 1);\n    }\n    \n    private drawHexagon(graphics: Phaser.GameObjects.Graphics, x: number, y: number, size: number): void {\n        const points: number[] = [];\n        \n        for (let i = 0; i < 6; i++) {\n            const angle = (i * 60) * Math.PI / 180;\n            points.push(x + size * Math.cos(angle));\n            points.push(y + size * Math.sin(angle));\n        }\n        \n        graphics.strokePoints(points, true);\n    }\n    \n    private createAmbientParticles(width: number, height: number): void {\n        // Create subtle floating particles for atmosphere\n        const particleCount = Math.min(25, Math.floor((width * height) / 15000));\n        \n        for (let i = 0; i < particleCount; i++) {\n            const particle = this.add.graphics();\n            const size = Phaser.Math.Between(1, 3);\n            const alpha = Phaser.Math.FloatBetween(0.1, 0.3);\n            const color = Phaser.Math.RND.pick([0x2a4d6b, 0x3e6b8a, 0x4a7ba7]);\n            \n            particle.fillStyle(color, alpha);\n            particle.fillCircle(0, 0, size);\n            \n            // Random starting position\n            const startX = Phaser.Math.Between(-50, width + 50);\n            const startY = Phaser.Math.Between(-50, height + 50);\n            particle.setPosition(startX, startY);\n            particle.setDepth(Z_LAYERS.BACKGROUND + 2);\n            \n            // Gentle floating animation\n            const duration = Phaser.Math.Between(8000, 15000);\n            const endX = startX + Phaser.Math.Between(-100, 100);\n            const endY = startY + Phaser.Math.Between(-100, 100);\n            \n            this.tweens.add({\n                targets: particle,\n                x: endX,\n                y: endY,\n                alpha: { from: alpha, to: 0 },\n                duration: duration,\n                ease: 'Sine.easeInOut',\n                repeat: -1,\n                yoyo: true,\n                onRepeat: () => {\n                    // Randomize position on repeat for variety\n                    particle.setPosition(\n                        Phaser.Math.Between(-50, width + 50),\n                        Phaser.Math.Between(-50, height + 50)\n                    );\n                }\n            });\n        }\n    }\n    */\n\n    private createArena(): void {\n        try {\n            console.log('GameScene: Instantiating ArenaSystem...');\n            this.arenaSystem = new ArenaSystem(this);\n            \n            console.log('GameScene: Setting up arena with AI opponent (HARD)...');\n            // Setup single player mode with AI difficulty - Always HARD\n            this.arenaSystem.setupArena(true, AIDifficulty.HARD);\n            \n            // Connect sound system to game events\n            this.setupSoundEvents();\n            \n            console.log('GameScene: Arena created successfully with AI opponent');\n        } catch (error) {\n            console.error('GameScene: Error creating arena:', error);\n            throw error;\n        }\n    }\n    \n    private setupSoundEvents(): void {\n        if (!this.soundSystem) return;\n        \n        // Bubble shoot event\n        this.events.on('bubble-shoot', () => {\n            this.soundSystem.playShootSound();\n        });\n        \n        // Bubble attach event (for game logic)\n        this.events.on('bubble-attached', () => {\n            // Game logic handled elsewhere\n        });\n        \n        // Bubble attach collision event (plays at exact collision moment)\n        this.events.on('bubble-attach-collision', () => {\n            this.soundSystem.playAttachSound();\n        });\n        \n        // Bubble attach sound event (backup for other attach cases)\n        this.events.on('bubble-attached-sound', () => {\n            // Already played on collision\n        });\n        \n        // Match found event - play combo sounds\n        this.events.on('match-found', (data: any) => {\n            // Play real MP3 combo sounds based on match size\n            if (data && data.matchSize) {\n                this.soundSystem.playMatchSound(data.matchSize);\n            }\n        });\n        \n        // Power-up activated event\n        this.events.on('power-up-activated', () => {\n            this.soundSystem.playPowerUpSound();\n        });\n        \n        // UI click event\n        this.events.on('ui-click', () => {\n            this.soundSystem.playClickSound();\n        });\n        \n        // Victory event\n        this.events.on('victory', () => {\n            this.soundSystem.playVictorySound();\n        });\n        \n        // Defeat event\n        this.events.on('defeat', () => {\n            this.soundSystem.playDefeatSound();\n        });\n        \n        // Floating bubbles drop event\n        this.events.on('floating-bubbles-drop', () => {\n            this.soundSystem.playBubblesDropSound();\n        });\n        \n        // Mystery box collected event\n        this.events.on('mystery-box-collected', () => {\n            this.soundSystem.playSuccessObjectiveSound();\n        });\n        \n        // Objective hit event (when hitting the treasure chest)\n        this.events.on('objective-hit', () => {\n            this.soundSystem.playSuccessObjectiveSound();\n        });\n        \n        console.log('GameScene: Sound events connected');\n    }\n\n    private createFPSDisplay(): void {\n        const width = this.cameras.main.width;\n        const height = this.cameras.main.height;\n        \n        // Create FPS text in bottom right corner - more visible on mobile\n        this.fpsText = this.add.text(width - 100, height - 100, 'FPS: 0', {\n            fontSize: '20px',\n            color: '#00FF00',\n            fontFamily: 'Arial, sans-serif',\n            fontStyle: 'bold',\n            backgroundColor: '#000000CC',\n            padding: { x: 10, y: 6 }\n        });\n        \n        this.fpsText.setDepth(Z_LAYERS.UI + 1000); // Make sure it's on top\n        this.fpsText.setScrollFactor(0);\n        this.fpsText.setOrigin(0.5, 0.5);\n        \n        // Initialize FPS tracking\n        this.frameCount = 0;\n        this.lastFPSUpdate = performance.now();\n    }\n\n    private createUI(): void {\n        // Add FPS counter in bottom right corner\n        this.createFPSDisplay();\n        \n        // Debug text removed for clean production UI\n        \n        // Pause button removed for cleaner UI\n        \n        // Central score display removed - using player-specific scores only\n        \n        // Score events are now handled by EnhancedScoreDisplay in ArenaSystem\n        \n        // Listen for score events (for combo indicator only)\n        this.game.events.on('match-completed', (data: any) => {\n            \n            // Combo indicator\n            if (data.combo > 0) {\n                const comboText = this.add.text(\n                    this.cameras.main.width / 2,\n                    90,\n                    `COMBO x${data.combo + 1}!`,\n                    {\n                        fontFamily: 'Arial',\n                        fontSize: '20px',\n                        fontStyle: 'bold',\n                        color: '#FF6B6B',\n                        stroke: '#000000',\n                        strokeThickness: 2\n                    }\n                ).setOrigin(0.5);\n                comboText.setDepth(Z_LAYERS.UI);\n                \n                // Animate combo text\n                this.tweens.add({\n                    targets: comboText,\n                    scale: 1.5,\n                    alpha: 0,\n                    duration: 1000,\n                    ease: 'Power2',\n                    onComplete: () => comboText.destroy()\n                });\n            }\n        });\n    }\n\n    private setupInputHandlers(): void {\n        // ESC key to return to menu\n        this.input.keyboard?.on('keydown-ESC', () => {\n            this.returnToMenu();\n        });\n        \n        // P key to pause\n        this.input.keyboard?.on('keydown-P', () => {\n            this.togglePause();\n        });\n        \n        // Space key for testing (placeholder for shooting)\n        this.input.keyboard?.on('keydown-SPACE', () => {\n            console.log('Space pressed - shooting not yet implemented');\n            this.testBubblePop();\n        });\n        \n        // T key to test audio system\n        this.input.keyboard?.on('keydown-T', () => {\n            console.log('Testing audio system...');\n            this.soundSystem?.testAllSounds();\n            \n            // Also log sound system state\n            const stats = this.soundSystem?.getInfo();\n            console.log('Sound System Stats:', stats);\n        });\n        \n        // M key to toggle mute\n        this.input.keyboard?.on('keydown-M', () => {\n            const muted = this.soundSystem?.toggleMute();\n            \n            // Also mute/unmute background music\n            if (this.backgroundMusic) {\n                if (muted) {\n                    this.backgroundMusic.pause();\n                } else {\n                    this.backgroundMusic.resume();\n                }\n            }\n            \n            console.log(`Audio ${muted ? 'muted' : 'unmuted'}`);\n        });\n        \n        // O key to test UFO delivery animation\n        this.input.keyboard?.on('keydown-O', () => {\n            console.log('Testing UFO delivery animation...');\n            \n            // Get center position for the UFO animation\n            const centerX = this.cameras.main.centerX;\n            const centerY = this.cameras.main.centerY;\n            \n            // Trigger the UFO delivery animation\n            if (this.arenaSystem) {\n                // Call the UFO delivery method directly for testing\n                (this.arenaSystem as any).createUFODelivery(centerX, centerY, () => {\n                    console.log('UFO delivery animation complete');\n                });\n            }\n        });\n        \n        // Number keys 5-9 to change background themes (for testing)\n        if (!this.registry.get('isCapacitor')) { // Only on desktop for testing\n            this.input.keyboard?.on('keydown-FIVE', () => {\n                this.backgroundSystem?.setTheme('ocean');\n                console.log('Background theme: Ocean');\n            });\n            \n            this.input.keyboard?.on('keydown-SIX', () => {\n                this.backgroundSystem?.setTheme('sunset');\n                console.log('Background theme: Sunset');\n            });\n            \n            this.input.keyboard?.on('keydown-SEVEN', () => {\n                this.backgroundSystem?.setTheme('forest');\n                console.log('Background theme: Forest');\n            });\n            \n            this.input.keyboard?.on('keydown-EIGHT', () => {\n                this.backgroundSystem?.setTheme('space');\n                console.log('Background theme: Space');\n            });\n            \n            this.input.keyboard?.on('keydown-NINE', () => {\n                this.backgroundSystem?.setTheme('aurora');\n                console.log('Background theme: Aurora');\n            });\n        }\n    }\n\n    private testBubblePop(): void {\n        // Test bubble popping animation\n        const bubbles = this.arenaSystem.getBubbles();\n        if (bubbles.length > 0) {\n            const randomBubble = bubbles[Math.floor(Math.random() * bubbles.length)];\n            if (randomBubble) {\n                randomBubble.pop();\n            }\n        }\n    }\n\n    private togglePause(): void {\n        this.isPaused = !this.isPaused;\n        \n        if (this.isPaused) {\n            this.physics.pause();\n            this.backgroundMusic?.pause();\n            this.showPauseOverlay();\n        } else {\n            this.physics.resume();\n            this.backgroundMusic?.resume();\n            this.hidePauseOverlay();\n        }\n    }\n\n    private showPauseOverlay(): void {\n        const overlay = this.add.rectangle(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            this.cameras.main.width,\n            this.cameras.main.height,\n            0x000000,\n            0.7\n        );\n        overlay.setDepth(Z_LAYERS.UI + 10);\n        overlay.setData('isPauseOverlay', true);\n        \n        const pauseText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            'PAUSED',\n            {\n                fontFamily: 'Arial',\n                fontSize: '48px',\n                color: '#ffffff'\n            }\n        ).setOrigin(0.5);\n        pauseText.setDepth(Z_LAYERS.UI + 11);\n        pauseText.setData('isPauseOverlay', true);\n        \n        const resumeText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY + 60,\n            'Press P to Resume',\n            {\n                fontFamily: 'Arial',\n                fontSize: '20px',\n                color: '#ffffff'\n            }\n        ).setOrigin(0.5);\n        resumeText.setDepth(Z_LAYERS.UI + 11);\n        resumeText.setData('isPauseOverlay', true);\n    }\n\n    private hidePauseOverlay(): void {\n        this.children.list.forEach(child => {\n            if (child.getData('isPauseOverlay')) {\n                child.destroy();\n            }\n        });\n    }\n\n    private returnToMenu(): void {\n        // Properly cleanup background music\n        if (this.backgroundMusic) {\n            this.backgroundMusic.stop();\n            this.backgroundMusic.destroy();\n            this.backgroundMusic = undefined;\n        }\n        \n        this.arenaSystem?.destroy();\n        this.soundSystem?.destroy();\n        this.sceneManager.transitionTo(SceneKeys.MENU);\n    }\n\n    public override update(time: number, delta: number): void {\n        if (this.isPaused) return;\n        \n        // Update FPS counter\n        this.updateFPSDisplay();\n        \n        // Update arena system\n        this.arenaSystem?.update(time, delta);\n    }\n    \n    private updateFPSDisplay(): void {\n        if (!this.fpsText) return;\n        \n        this.frameCount++;\n        const now = performance.now();\n        const elapsed = now - this.lastFPSUpdate;\n        \n        // Update FPS every 1000ms to reduce overhead when targeting 120 FPS\n        if (elapsed >= 1000) {\n            const fps = Math.round((this.frameCount * 1000) / elapsed);\n            this.fpsText.setText(`FPS: ${fps}`);\n            \n            // Color code based on performance\n            if (fps >= 100) {\n                this.fpsText.setColor('#00FF00'); // Green for excellent\n            } else if (fps >= 60) {\n                this.fpsText.setColor('#FFFF00'); // Yellow for good  \n            } else if (fps >= 30) {\n                this.fpsText.setColor('#FFA500'); // Orange for okay\n            } else {\n                this.fpsText.setColor('#FF0000'); // Red for poor\n            }\n            \n            this.frameCount = 0;\n            this.lastFPSUpdate = now;\n        }\n    }\n    \n    public shutdown(): void {\n        // Properly cleanup background music\n        if (this.backgroundMusic) {\n            this.backgroundMusic.stop();\n            this.backgroundMusic.destroy();\n            this.backgroundMusic = undefined;\n        }\n        \n        this.arenaSystem?.destroy();\n        this.soundSystem?.destroy();\n        this.backgroundSystem?.destroy();\n        this.performanceMonitor?.reset();\n    }\n}","/// <reference types=\"@capacitor/cli\" />\nexport var Style;\n(function (Style) {\n    /**\n     * Light text for dark backgrounds.\n     *\n     * @since 1.0.0\n     */\n    Style[\"Dark\"] = \"DARK\";\n    /**\n     * Dark text for light backgrounds.\n     *\n     * @since 1.0.0\n     */\n    Style[\"Light\"] = \"LIGHT\";\n    /**\n     * The style is based on the device appearance.\n     * If the device is using Dark mode, the statusbar text will be light.\n     * If the device is using Light mode, the statusbar text will be dark.\n     *\n     * @since 1.0.0\n     */\n    Style[\"Default\"] = \"DEFAULT\";\n})(Style || (Style = {}));\nexport var Animation;\n(function (Animation) {\n    /**\n     * No animation during show/hide.\n     *\n     * @since 1.0.0\n     */\n    Animation[\"None\"] = \"NONE\";\n    /**\n     * Slide animation during show/hide.\n     * It doesn't work on iOS 15+.\n     *\n     * @deprecated Use Animation.Fade or Animation.None instead.\n     *\n     * @since 1.0.0\n     */\n    Animation[\"Slide\"] = \"SLIDE\";\n    /**\n     * Fade animation during show/hide.\n     *\n     * @since 1.0.0\n     */\n    Animation[\"Fade\"] = \"FADE\";\n})(Animation || (Animation = {}));\n/**\n * @deprecated Use `Animation`.\n * @since 1.0.0\n */\nexport const StatusBarAnimation = Animation;\n/**\n * @deprecated Use `Style`.\n * @since 1.0.0\n */\nexport const StatusBarStyle = Style;\n//# sourceMappingURL=definitions.js.map","import { registerPlugin } from '@capacitor/core';\nconst StatusBar = registerPlugin('StatusBar');\nexport * from './definitions';\nexport { StatusBar };\n//# sourceMappingURL=index.js.map","/// <reference types=\"@capacitor/cli\" />\nexport var KeyboardStyle;\n(function (KeyboardStyle) {\n    /**\n     * Dark keyboard.\n     *\n     * @since 1.0.0\n     */\n    KeyboardStyle[\"Dark\"] = \"DARK\";\n    /**\n     * Light keyboard.\n     *\n     * @since 1.0.0\n     */\n    KeyboardStyle[\"Light\"] = \"LIGHT\";\n    /**\n     * On iOS 13 and newer the keyboard style is based on the device appearance.\n     * If the device is using Dark mode, the keyboard will be dark.\n     * If the device is using Light mode, the keyboard will be light.\n     * On iOS 12 the keyboard will be light.\n     *\n     * @since 1.0.0\n     */\n    KeyboardStyle[\"Default\"] = \"DEFAULT\";\n})(KeyboardStyle || (KeyboardStyle = {}));\nexport var KeyboardResize;\n(function (KeyboardResize) {\n    /**\n     * Only the `body` HTML element will be resized.\n     * Relative units are not affected, because the viewport does not change.\n     *\n     * @since 1.0.0\n     */\n    KeyboardResize[\"Body\"] = \"body\";\n    /**\n     * Only the `ion-app` HTML element will be resized.\n     * Use it only for Ionic Framework apps.\n     *\n     * @since 1.0.0\n     */\n    KeyboardResize[\"Ionic\"] = \"ionic\";\n    /**\n     * The whole native Web View will be resized when the keyboard shows/hides.\n     * This affects the `vh` relative unit.\n     *\n     * @since 1.0.0\n     */\n    KeyboardResize[\"Native\"] = \"native\";\n    /**\n     * Neither the app nor the Web View are resized.\n     *\n     * @since 1.0.0\n     */\n    KeyboardResize[\"None\"] = \"none\";\n})(KeyboardResize || (KeyboardResize = {}));\n//# sourceMappingURL=definitions.js.map","import { registerPlugin } from '@capacitor/core';\nconst Keyboard = registerPlugin('Keyboard');\nexport * from './definitions';\nexport { Keyboard };\n//# sourceMappingURL=index.js.map","import { registerPlugin } from '@capacitor/core';\nconst App = registerPlugin('App', {\n    web: () => import('./web').then(m => new m.AppWeb()),\n});\nexport * from './definitions';\nexport { App };\n//# sourceMappingURL=index.js.map","import { registerPlugin } from '@capacitor/core';\n\nexport interface PerformancePlugin {\n    maximizePerformance(): Promise<{ success: boolean; message: string }>;\n    getDeviceCapabilities(): Promise<{\n        model: string;\n        systemVersion: string;\n        processorCount: number;\n        physicalMemory: number;\n        thermalState: number;\n        lowPowerMode: boolean;\n        batteryLevel: number;\n        supportsProMotion: boolean;\n    }>;\n}\n\nconst Performance = registerPlugin<PerformancePlugin>('PerformancePlugin', {\n    web: () => Promise.resolve({\n        maximizePerformance: async () => ({ success: true, message: 'Web platform - no optimization needed' }),\n        getDeviceCapabilities: async () => ({\n            model: 'Web Browser',\n            systemVersion: navigator.userAgent,\n            processorCount: navigator.hardwareConcurrency || 4,\n            physicalMemory: 0,\n            thermalState: 0,\n            lowPowerMode: false,\n            batteryLevel: 1,\n            supportsProMotion: false\n        })\n    })\n});\n\nexport default Performance;","/**\n * Capacitor-specific optimizations for iOS performance\n */\n\nimport { Capacitor } from '@capacitor/core';\nimport { StatusBar } from '@capacitor/status-bar';\nimport { Keyboard } from '@capacitor/keyboard';\nimport { App } from '@capacitor/app';\nimport Performance from './performancePlugin';\n\nexport class CapacitorOptimizations {\n    private static instance: CapacitorOptimizations;\n    \n    private constructor() {}\n    \n    public static getInstance(): CapacitorOptimizations {\n        if (!CapacitorOptimizations.instance) {\n            CapacitorOptimizations.instance = new CapacitorOptimizations();\n        }\n        return CapacitorOptimizations.instance;\n    }\n    \n    /**\n     * Initialize all iOS optimizations\n     */\n    public async initialize(): Promise<void> {\n        if (!Capacitor.isNativePlatform()) {\n            console.log('Not running on native platform, skipping optimizations');\n            return;\n        }\n        \n        console.log('Initializing Capacitor optimizations for iOS...');\n        \n        try {\n            // Performance optimizations disabled - let iOS handle naturally\n            // await this.maximizeDevicePerformance();\n            \n            // Hide status bar for full screen experience\n            await this.hideStatusBar();\n            \n            // Configure keyboard behavior\n            await this.configureKeyboard();\n            \n            // Handle app state changes\n            this.handleAppStateChanges();\n            \n            // Disable overscroll/bounce effect\n            this.disableOverscroll();\n            \n            // Optimize WebView settings\n            this.optimizeWebView();\n            \n            // Request high performance mode\n            this.requestHighPerformance();\n            \n            console.log('Capacitor optimizations initialized successfully');\n        } catch (error) {\n            console.error('Error initializing Capacitor optimizations:', error);\n        }\n    }\n    \n    /**\n     * Maximize device performance using native plugin\n     */\n    private async maximizeDevicePerformance(): Promise<void> {\n        try {\n            console.log('Attempting to maximize iOS performance...');\n            \n            // Get device capabilities first\n            const capabilities = await Performance.getDeviceCapabilities();\n            console.log('Device capabilities:', capabilities);\n            \n            // Request maximum performance mode\n            const result = await Performance.maximizePerformance();\n            console.log('Performance maximization result:', result);\n            \n            // Log performance status\n            if (capabilities.supportsProMotion) {\n                console.log('✅ ProMotion 120Hz display enabled');\n            }\n            if (!capabilities.lowPowerMode) {\n                console.log('✅ Low Power Mode is OFF - Full performance available');\n            }\n            console.log(`✅ CPU Cores: ${capabilities.processorCount}`);\n            console.log(`✅ RAM: ${(capabilities.physicalMemory / 1024 / 1024 / 1024).toFixed(1)} GB`);\n            \n        } catch (error) {\n            console.warn('Could not maximize performance:', error);\n        }\n    }\n    \n    /**\n     * Hide the status bar for immersive experience\n     */\n    private async hideStatusBar(): Promise<void> {\n        try {\n            await StatusBar.hide();\n            console.log('Status bar hidden');\n        } catch (error) {\n            console.warn('Could not hide status bar:', error);\n        }\n    }\n    \n    /**\n     * Configure keyboard behavior\n     */\n    private async configureKeyboard(): Promise<void> {\n        try {\n            // Set keyboard to not resize the WebView\n            await Keyboard.setResizeMode({ mode: 'none' });\n            \n            // Hide keyboard accessory bar\n            await Keyboard.setAccessoryBarVisible({ isVisible: false });\n            \n            console.log('Keyboard configured');\n        } catch (error) {\n            console.warn('Could not configure keyboard:', error);\n        }\n    }\n    \n    /**\n     * Handle app state changes for performance\n     */\n    private handleAppStateChanges(): void {\n        App.addListener('appStateChange', ({ isActive }) => {\n            if (isActive) {\n                console.log('App resumed - resuming game');\n                // Resume game logic\n                this.onAppResume();\n            } else {\n                console.log('App paused - pausing game');\n                // Pause game logic\n                this.onAppPause();\n            }\n        });\n    }\n    \n    /**\n     * Disable overscroll/bounce effect on iOS\n     */\n    private disableOverscroll(): void {\n        if (Capacitor.getPlatform() === 'ios') {\n            // Disable bounce effect\n            document.body.style.overflow = 'hidden';\n            document.body.style.position = 'fixed';\n            document.body.style.width = '100%';\n            document.body.style.height = '100%';\n            \n            // Prevent pull-to-refresh\n            document.body.addEventListener('touchmove', (e) => {\n                if (e.touches.length > 1) return; // Allow multi-touch\n                e.preventDefault();\n            }, { passive: false });\n            \n            console.log('Overscroll disabled');\n        }\n    }\n    \n    /**\n     * Optimize WebView settings\n     */\n    private optimizeWebView(): void {\n        // Disable text selection\n        document.body.style.userSelect = 'none';\n        document.body.style.webkitUserSelect = 'none';\n        \n        // Disable tap highlight\n        document.body.style.webkitTapHighlightColor = 'transparent';\n        \n        // Enable hardware acceleration\n        document.body.style.transform = 'translateZ(0)';\n        document.body.style.webkitTransform = 'translateZ(0)';\n        \n        // Disable touch callouts\n        document.body.style.webkitTouchCallout = 'none';\n        \n        // Set viewport for optimal rendering\n        const viewport = document.querySelector('meta[name=\"viewport\"]');\n        if (viewport) {\n            viewport.setAttribute('content', \n                'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover'\n            );\n        }\n        \n        console.log('WebView optimized');\n    }\n    \n    /**\n     * Request high performance mode\n     */\n    private requestHighPerformance(): void {\n        // Request wake lock to prevent screen dimming during gameplay\n        if ('wakeLock' in navigator) {\n            (navigator as any).wakeLock.request('screen').then(() => {\n                console.log('Wake lock activated');\n            }).catch((err: Error) => {\n                console.warn('Wake lock failed:', err);\n            });\n        }\n        \n        // REMOVED: Empty RAF loop was consuming resources\n        // Phaser already handles its own render loop efficiently\n        \n        console.log('High performance mode requested');\n    }\n    \n    /**\n     * Called when app resumes\n     */\n    private onAppResume(): void {\n        // Resume audio context if needed\n        const audioContext = (window as any).audioContext;\n        if (audioContext && audioContext.state === 'suspended') {\n            audioContext.resume();\n        }\n        \n        // Re-enable wake lock\n        if ('wakeLock' in navigator) {\n            (navigator as any).wakeLock.request('screen').catch(() => {});\n        }\n    }\n    \n    /**\n     * Called when app pauses\n     */\n    private onAppPause(): void {\n        // Pause audio context if needed\n        const audioContext = (window as any).audioContext;\n        if (audioContext && audioContext.state === 'running') {\n            audioContext.suspend();\n        }\n    }\n    \n    /**\n     * Clean up optimizations\n     */\n    public destroy(): void {\n        // Remove event listeners\n        App.removeAllListeners();\n        \n        // Release wake lock\n        if ('wakeLock' in navigator) {\n            (navigator as any).wakeLock.release().catch(() => {});\n        }\n    }\n}","import Phaser from 'phaser';\nimport { createGameConfig } from '@config/GameConfig';\nimport { BootScene } from '@scenes/BootScene';\nimport { PreloadScene } from '@scenes/PreloadScene';\nimport { MenuScene } from '@scenes/MenuScene';\nimport { ThemeSelectScene } from '@scenes/ThemeSelectScene';\nimport { GameScene } from '@scenes/GameScene';\nimport { CapacitorOptimizations } from '@utils/capacitorOptimizations';\nimport { Capacitor } from '@capacitor/core';\n\nclass BubbleBattleRoyale {\n    private game: Phaser.Game | null = null;\n\n    constructor() {\n        this.initialize();\n    }\n\n    private async initialize(): Promise<void> {\n        console.log('Bubble Battle Royale - Initializing...');\n        \n        // Apply iOS/Capacitor optimizations\n        if (Capacitor.isNativePlatform()) {\n            console.log('Running on native platform - applying optimizations');\n            const optimizer = CapacitorOptimizations.getInstance();\n            await optimizer.initialize();\n        }\n        \n        this.setupErrorHandling();\n        this.waitForDOM(() => {\n            this.createGame();\n            this.hideLoadingScreen();\n        });\n    }\n\n    private setupErrorHandling(): void {\n        window.addEventListener('error', (event) => {\n            console.error('Global error:', event.error);\n        });\n\n        window.addEventListener('unhandledrejection', (event) => {\n            console.error('Unhandled promise rejection:', event.reason);\n        });\n    }\n\n    private waitForDOM(callback: () => void): void {\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', callback);\n        } else {\n            callback();\n        }\n    }\n\n    private createGame(): void {\n        console.log('createGame called - preparing scenes');\n        const scenes = [\n            BootScene,\n            PreloadScene,\n            MenuScene,\n            ThemeSelectScene,\n            GameScene\n        ];\n        console.log('Scenes prepared:', scenes.map(s => s.name));\n\n        const config = createGameConfig(scenes);\n        console.log('Game config created:', config);\n        \n        try {\n            console.log('Creating Phaser.Game instance...');\n            this.game = new Phaser.Game(config as Phaser.Types.Core.GameConfig);\n            console.log('Game created successfully');\n            \n            this.setupGameEventListeners();\n            \n        } catch (error) {\n            console.error('Failed to create game:', error);\n            this.showErrorMessage('Failed to initialize game. Please refresh the page.');\n        }\n    }\n\n    private setupGameEventListeners(): void {\n        if (!this.game) return;\n\n        this.game.events.on('ready', () => {\n            console.log('Game is ready');\n        });\n\n        this.game.events.on('destroy', () => {\n            console.log('Game destroyed');\n        });\n\n        window.addEventListener('beforeunload', () => {\n            if (this.game) {\n                this.game.destroy(true, false);\n            }\n        });\n    }\n\n    private hideLoadingScreen(): void {\n        setTimeout(() => {\n            const loadingElement = document.getElementById('loading');\n            if (loadingElement) {\n                loadingElement.style.transition = 'opacity 0.5s';\n                loadingElement.style.opacity = '0';\n                setTimeout(() => {\n                    loadingElement.style.display = 'none';\n                }, 500);\n            }\n        }, 1000);\n    }\n\n    private showErrorMessage(message: string): void {\n        const loadingElement = document.getElementById('loading');\n        if (loadingElement) {\n            loadingElement.innerHTML = `\n                <div style=\"color: #e74c3c; font-size: 20px;\">${message}</div>\n                <div style=\"margin-top: 20px; font-size: 14px; opacity: 0.8;\">\n                    Check the console for more details\n                </div>\n            `;\n        }\n    }\n\n    public getGame(): Phaser.Game | null {\n        return this.game;\n    }\n}\n\nconsole.log('Creating BubbleBattleRoyale instance...');\nconst app = new BubbleBattleRoyale();\nconsole.log('BubbleBattleRoyale instance created');\n\nif (import.meta.hot) {\n    import.meta.hot.accept(() => {\n        console.log('HMR: Module updated');\n    });\n}\n\nexport default app;"],"file":"assets/index-DoHKlJrn.js"}