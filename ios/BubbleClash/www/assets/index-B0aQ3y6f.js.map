{"version":3,"mappings":"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","names":["DeviceDetection","static","capabilities","constructor","this","detectCapabilities","getInstance","instance","ua","navigator","userAgent","toLowerCase","isTouch","window","maxTouchPoints","isMobile","test","isTablet","isDesktop","screenWidth","innerWidth","screenHeight","innerHeight","isLandscape","isPortrait","canvas","document","createElement","gl","getContext","hasWebGL","maxTextureSize","getParameter","MAX_TEXTURE_SIZE","hasWebAudio","AudioContext","webkitAudioContext","hasAudioTag","canPlayType","pixelRatio","devicePixelRatio","audioSupport","webAudio","audioTag","getCapabilities","updateOrientation","getQualityPreset","shouldReduceMotion","matchMedia","matches","getOptimalResolution","width","Math","min","height","floor","HD_SCALE","GAME_CONSTANTS","MAX_WIDTH","MAX_HEIGHT","COLORS","UI_SUCCESS","UI_TEXT","SceneKeys","GameEvents","SceneManager","game","currentScene","previousScene","transitionInProgress","eventEmitter","Phaser","Events","EventEmitter","Error","transitionTo","sceneName","data","scene","getScene","currentSceneInstance","isActive","fadeOutScene","switchScene","callback","cameras","main","fadeOut","once","stop","sceneData","transitionFrom","start","bringToTop","newScene","fadeIn","emit","SCENE_READY","getCurrentScene","getPreviousScene","isTransitioning","restartCurrentScene","pauseCurrentScene","pause","resumeCurrentScene","resume","launchParallelScene","run","stopParallelScene","on","event","off","setCurrentScene","PerformanceMonitor","fps","frameTime","lastTime","deltaTime","frameCount","fpsUpdateInterval","lastFpsUpdate","frames","maxFrameSamples","warningThreshold","criticalThreshold","consecutiveLowFrames","performance","now","setEventEmitter","emitter","update","time","currentTime","round","max","getFPS","getFrameTime","getDeltaTime","getMetrics","drawCalls","memoryUsage","getMemoryUsage","shouldReduceQuality","getAverageFPS","shouldIncreaseQuality","length","avgFrameTime","reduce","a","b","memory","usedJSHeapSize","reset","getPerformanceScore","avgFps","score","logMetrics","BootScene","Scene","sceneManager","deviceDetection","performanceMonitor","super","key","BOOT","init","_data","events","setupDeviceListeners","checkDeviceCapabilities","preload","loadingText","add","text","centerX","centerY","fontFamily","fontSize","color","align","setOrigin","progressBar","graphics","progressBox","x","y","fillStyle","fillRect","load","value","clear","destroy","create","setupGlobalEventListeners","PRELOAD","error","_delta","addEventListener","handleOrientationChange","hidden","handleGamePause","handleGameResume","showErrorMessage","scale","resize","sound","pauseAll","resumeAll","severity","handleCriticalPerformance","message","errorText","wordWrap","rectangle","setDepth","ASSET_KEYS","LOGO","BACKGROUND","PLANET","BUBBLE_PLANET","BUBBLE_SHOOT","BUBBLE_ATTACH","BUBBLES_DROP","COMBO_3","COMBO_4","COMBO_5_PLUS","COMBO_CELEBRATION","ARSENAL_PICKUP","SUCCESS_OBJECTIVE","VICTORY","DEFEAT","BACKGROUND_MUSIC","AssetLoader","manifest","loadedCount","totalCount","images","url","type","audio","atlases","json","calculateTotalAssets","loadAssets","onProgress","file","loadImages","loadAudio","loadAtlases","loadJSON","forEach","item","textures","exists","image","cache","jsonUrl","replace","atlas","getProgress","getTotalAssets","getLoadedAssets","PreloadScene","assetLoader","percentText","assetText","createLoadingUI","setupLoadingListeners","createPlaceholderAssets","progress","updateProgress","cleanupLoadingUI","delayedCall","LOADING_COMPLETE","MENU","progressBarX","progressBarWidth","progressBarY","createLoadingAnimation","bubbleColors","i","bubble","circle","tweens","targets","duration","ease","yoyo","repeat","delay","setText","percent","progressBarHeight","make","fillCircle","generateTexture","MenuScene","buttons","titleText","versionText","fpsText","createBackground","createTitle","createMenuButtons","createVersionInfo","createFPSDisplay","addAnimations","_time","loop","actualFps","setTint","bg","setDisplaySize","Between","alpha","stroke","strokeThickness","scaleX","scaleY","action","startGame","startPractice","openSettings","showAbout","index","button","createButton","push","setAlpha","setScale","container","setStrokeStyle","setInteractive","useHandCursor","buttonText","setFillStyle","particles","lifespan","speedY","end","quantity","frequency","tint","onComplete","THEME_SELECT","showMessage","overlay","messageBox","messageText","closeButton","BackgroundSystem","config","gradientGraphics","gradientTexture","parallaxLayers","particleEmitters","ambientElements","animationTimers","themes","ocean","colors","accent","name","particleType","secondaryParticles","sunset","forest","space","aurora","currentTheme","theme","quality","enableParticles","enableAnimation","createGradientBackground","createParallaxLayers","createAmbientParticles","createAnimatedElements","startAnimations","gradientHeight","color1","color2","ratio","blendedColor","blendColors","addNoiseTexture","layerCount","layer","elementCount","j","element","createThemeElement","layerIndex","firefly","from","to","bgLeaf","ellipse","RND","pick","setAngle","angle","pillar","setBlendMode","BlendModes","ADD","drawLeaf","size","points","fillPoints","particleCount","createThemeParticle","particle","startX","startY","FloatBetween","sin","Date","recycleParticle","createFireflyPath","leafSize","fallDuration","starSize","active","curtainX","curtainWidth","curtainColor","colorPhase","shimmerTimer","addEvent","onUpdate","tween","fromColor","toColor","blended","Display","Color","Interpolate","ColorWithColor","IntegerToColor","GetColor","r","g","moveFirefly","newX","newY","boundedX","Clamp","boundedY","filter","e","createSecondaryEffect","sparkleTimer","clusterX","smallBubble","spark","dust","sparkle","star","createBackgroundPlanet","createShootingStarTimer","earthX","earthY","earthScale","earth","createFloatingBubblesBetweenPlanets","createShootingStar","createNextStar","shootingContainer","segment","head","endX","endY","updateEvent","updateParallax","bind","startGradientAnimation","speed","hueShift","gradientTimer","shifted","shiftHue","noiseGraphics","r1","g1","b1","r2","g2","b2","degrees","l","d","s","h","hue2rgb","p","q","t","setTheme","setQuality","timer","ThemeSelectScene","backgroundSystem","selectedTheme","themeContainers","confirmButton","previewBackground","description","icon","createThemeCards","createConfirmButton","setupKeyboardControls","selectTheme","cardWidth","cardHeight","createThemeCard","fillRoundedRect","lineStyle","strokeRoundedRect","glow","setVisible","setData","iconX","nameText","descText","dotsStartX","dot","dotSize","Geom","Rectangle","Contains","buttonY","buttonWidth","buttonHeight","getData","registry","set","input","keyboard","GAME","shutdown","BubbleColor","ArenaZone","ARENA_CONFIG","playerZoneHeight","opponentZoneHeight","objectiveZoneHeight","bubbleSize","objectiveSize","launcherOffset","BUBBLE_CONFIG","SIZE","POOL_SIZE","ANIMATION_DURATION","GRID_CONFIG","DANGER_ZONE_CONFIG","PLAYER_OFFSET","OPPONENT_OFFSET","PULSE_DURATION","ZONE_COLORS","Z_LAYERS","BubbleGrid","hexSize","gridMap","Map","initializeGrid","getKey","hexToPixel","hex","rowHeight","sqrt","colWidth","xOffset","abs","pixelToHex","pixel","adjustedX","roundHex","rq","rr","rs","qDiff","rDiff","sDiff","getNeighbors","directions","map","dir","getDistance","getRing","center","radius","results","getSpiral","maxRadius","ring","isValidPosition","has","getGridBounds","minQ","maxQ","minR","maxR","getAllBubbles","getBubbleAt","getBubblesInRadius","Bubble","GameObjects","Container","bubbleSprite","innerGradient","highlightSprite","secondaryHighlight","shadowSprite","rimLight","gridPosition","isSpecial","pooled","shooter","idleAnimation","getDarkerColor","getLighterColor","setSize","existing","addIdleAnimation","setGridPosition","getGridPosition","setShooter","getShooter","getColor","setColor","clearTint","setSpecial","special","addGlow","removeGlow","getIsSpecial","addAt","glowElement","getAt","killTweensOf","removeAt","addColorblindPattern","patternSprite","RED","lineBetween","BLUE","GREEN","offset","YELLOW","PURPLE","x1","y1","x2","y2","pop","returnToPool","createPopParticles","colorIndex","PI","random","rotationSpeed","cos","flash1","setPosition","isPooled","getRandomColor","ScoreEventType","ScoreEventManager","modules","eventQueue","processing","totalPlayerScore","totalOpponentScore","MAX_QUEUE_SIZE","PROCESS_INTERVAL","scoreUpdateCallbacks","visualEffectCallbacks","initializeDefaultModules","startProcessing","registerModule","BubbleMatchModule","OrphanDropModule","ChainComboModule","module","get","sort","priority","queueEvent","context","timestamp","processed","shift","processQueue","callbackScope","eventsToProcess","processEvent","finalResult","canProcess","result","calculateScore","finalScore","visualEffectLevel","isPlayer","notifyScoreUpdate","notifyVisualEffect","position","onScoreUpdate","onVisualEffect","cb","getPlayerScore","getOpponentScore","BASE_POINTS","matchSize","basePoints","multiplier","displayText","effectLevel","bubbleColor","comboMultiplier","dropCount","metadata","totalPoints","ceil","chainCount","lastChainTime","CHAIN_TIMEOUT","isChain","PowerUpType","MysteryBubble","powerUpIcon","currentPowerUp","powerUpCycleTimer","glowEffect","iconBg","powerUpSequence","RAINBOW","BOMB","LIGHTNING","FREEZE","LASER","MULTIPLIER","sequenceIndex","powerUpIcons","SHIELD","MAGNET","createMysteryVisuals","startPowerUpCycle","list","updateGlowEffect","updatePowerUpDisplay","cycleFunction","cyclePowerUp","getCurrentPowerUp","isMysteryBubble","collectPowerUp","isPlayerShot","floatingIcon","powerUpText","flash","owner","Launcher","launcherPlatform","bubbleChamber","queuePanel","effectsLayer","platformGraphics","chamberGraphics","queueBackground","queueLabel","stateIndicator","readyIndicator","queueContainer","nextBubbleFrame","nextBubbleGraphics","secondBubbleGraphics","arsenalSlots","weaponRing","energyConduits","activePowerUp","arsenalContainer","chargingTween","zone","currentAngle","loadedBubble","nextBubbleColors","isAiming","isOpponent","launcherState","powerLevel","BUBBLE_POSITION_Y","QUEUE_POSITION_Y","ARSENAL_POSITIONS_PLAYER","ARSENAL_POSITIONS_OPPONENT","SLOT_SIZE","OPPONENT","createExceptionalLauncher","createIntegratedArsenal","updateTheme","startEnhancedIdleAnimations","setupArsenalListeners","setupMobileTouchArea","createLauncherPlatform","createBubbleChamber","createEnhancedQueueSystem","createStateIndicators","createEffectsLayer","updateAllVisuals","renderLauncherPlatform","renderBubbleChamber","renderEnhancedQueue","renderStateIndicators","renderGlowEffects","topY","bottomY","columnWidth","fillGradientStyle","platform","top","bottom","chamber","highlight","rim","outerTop","outerBottom","strokeCircle","innerRim","innerRadius","renderEnhancedQueueBubbles","aiming","pulse","createNextBubble","createSecondBubble","bubbleGraphics","drawQueueBubble","rotation","resetQueueBubbles","bubbleTheme","getBubbleColors","primary","dark","light","drawSmallQueueBubble","loaded","getExceptionalTheme","base","secondary","darkenColor","shadow","innerTop","innerBottom","depth","queue","panelTop","panelBottom","panelBorder","panelGlow","factor","paused","touchArea","pointer","ripple","setHighlight","setAimAngle","visualAngle","PLAYER","getAimAngle","getAimDirection","rad","DegToRad","Vector2","showAiming","show","animateShoot","createEnhancedLaunchEffects","animateEnhancedLaunch","setTimeout","setState","state","updateStateIndicator","chargeColor","startPowerCharge","renderPowerIndicator","releasePowerCharge","power","powerColor","enabled","loadBubble","remove","updateArsenalTheme","getLoadedBubble","clearLoadedBubble","updateQueueColors","recoilIntensity","shakeIntensity","recoilDistance","shake","effectY","effectIntensity","flashSize","distance","sparkX","sparkY","sparkleSize","slot","background","drawArsenalSlotBackground","createArsenalChamber","pos","createArsenalSlot","chamberY","chamberHeight","chamberWidth","chamberX","inner","panelX","detail","tubeStartX","tubeEndX","tubeHeight","tubeY","lineY","setLineDash","setShadow","countText","device","touch","keyHint","createKeyHintBadge","touchPadding","activateArsenalSlot","baseScale","powerUpType","count","halfSize","innerR","outerR","arc","strokePath","fillEllipse","badge","badgeColor","addPowerUpToArsenal","find","showPowerUpCollectionEffect","showEmptySlotFeedback","activatePowerUp","showPowerUpActivation","startSlotCooldown","renderEnergyConduit","burst","px","py","collectFlash","progressArc","getValue","beginPath","Objective","chestBody","chestLid","chestLock","shield","health","maxHealth","shielded","starBurstTimer","peekTimer","outerGlow","middleGlow","chestSize","detail1","detail2","detail3","sparkleCount","offsetX","Utils","Array","GetRandom","shimmer","setShielded","showVulnerable","hit","damage","createVictoryParticles","vx","vy","getHealth","getMaxHealth","isVulnerable","isShielded","playVictoryAnimation","Arc","particleTimer","InputManager","currentPosition","sensitivity","isEnabled","setupInput","activePointer","onPointerMove","onPointerDown","onPointerUp","targetX","targetY","_pointer","getPosition","getPointerPosition","getAngleFrom","fromX","fromY","dx","dy","atan2","RadToDeg","getAngleFromWithConstraints","minAngle","maxAngle","constrainedMin","constrainedMax","setEnabled","isPointerActive","setSensitivity","TrajectoryPreview","launcher","dots","dotPool","currentBubbleColor","DOT_COUNT","DOT_SIZE","DOT_SPACING","PREVIEW_PERCENTAGE","MAX_PREVIEW_DISTANCE","SHOOT_SPEED","animationTime","isVisible","bounds","createDotPool","calculateTrajectory","hide","radians","magnitude","maxDots","dotIndex","totalDistance","left","right","fadeStart","targetAlpha","delta","waveOffset","wave","animatedAlpha","sizeWave","colorProgress","baseColor","red","green","blue","ShootingSystem","inputManager","playerLauncher","opponentLauncher","projectiles","currentBubble","availableColors","canShoot","cooldownTime","shootSpeed","cooldownBar","cooldownBarBg","trajectoryPreview","gridAttachmentSystem","bubbleGrid","generateNextBubbleColors","setupShooting","onShoot","onAIShoot","createCooldownIndicator","loadNextBubble","setOpponentLauncher","launcherY","startCooldownAnimation","barX","barY","randomColor","currentColor","newColor","direction","velocity","shotBubbleColor","aiBubble","projectile","isAI","checkProjectileCollisions","visible","hitBubble","checkCollision","attachPos","findAttachmentPosition","pixelPos","Distance","attachToGrid","checkWallCollision","splice","proj1","proj2","len","nx","ny","overlap","impulse","isReady","getProjectileCount","GridAttachmentSystem","gridBubbles","attachmentInProgress","attachmentQueue","matchDetectionSystem","spatialGrid","gridPositions","setMatchDetectionSystem","addGridBubble","includes","updateSpatialGrid","removeGridBubble","indexOf","projectilePos","collisionRadius","centerPixel","isPositionOccupied","virtualBubble","nearbyBubbles","getNearbyBubbles","gridBubble","gridSize","cellX","cellY","nearby","cellBubbles","hitHexPos","angleDeg","neighborOffsets","bestNeighbor","minAngleDiff","neighbor","angleDiff","findBestAvailablePosition","targetHex","ringPositions","bestPos","minDistance","Infinity","hexPos","some","hexToKey","threshold","cleanupMisalignedBubbles","createAttachmentEffect","async","finalPixelPos","checkForMatches","checkDisconnectedBubbles","next","newBubble","toRemove","disconnected","findDisconnectedGroups","allDisconnected","bubbles","applyBidirectionalGravity","OBJECTIVE","visited","Set","connected","centerHex","anchors","centerBubble","getBubbleAtPosition","neighborHex","getZoneForBubble","anchor","floodFill","neighborBubble","objectiveTop","objectiveBottom","fallingUp","fallingDown","animateFallingBubbles","outOfBounds","oldPos","delete","horizontalDrift","getGridBubbles","clearGrid","debugDrawConnections","hasGridPosition","gridKey","MatchDetectionSystem","minimumMatchSize","isProcessing","totalScore","combo","lastMatchTime","comboTimeout","attachedBubble","findColorMatches","avgX","avgY","worldPos","getWorldTransformMatrix","tx","ty","isAIMatch","highlightMatches","Promise","resolve","updateCombo","positions","removeMatches","checkFloatingBubbles","startBubble","targetColor","current","colorMatches","neighbors","getNeighborBubbles","hexNeighbors","sum","getPopAnimationStyle","promises","promise","createParticles","explosionAngle","explosionDistance","all","upwardBubbles","downwardBubbles","bonusPerBubble","totalOrphanBonus","isAIBonus","isOrphanBonus","showOrphanBonus","bonus","adjustedY","bonusContainer","dropText","fontStyle","pointsText","createDropParticles","zoneMultiplier","getZone","getScore","AIDifficulty","AIOpponentSystem","shootTimer","difficulty","isOnCooldown","COOLDOWN_TIME","onShootingComplete","setDifficulty","scheduleNextShot","thinkingTime","performShot","target","calculateBestShot","bubbleToShoot","sameColorBubbles","closestBubbles","bestTarget","objectiveShot","checkObjectiveShot","allTargets","isObjectiveExposed","blockingBubbles","unshift","targetBubble","angles","calculateAngleToTarget","targetPos","isTrajectoryLikelyClear","countPotentialMatch","potentialFalls","nearObjective","baseScore","fallBonus","useWallBounce","totalValue","reasoning","bounceTargets","findWallBounceTargets","slice","findStraightShotTarget","allBubbles","safeAngles","getColorName","findTargetsViaWallBounce","attachPoints","getAttachmentPoints","point","wouldConnect","countConnectedBubbles","mirrorX","leftBounceAngle","mirrorX2","rightBounceAngle","findBestWallBounce","leftMirrorX","leftAngle","bouncePoint","tan","rightMirrorX","rightAngle","offsets","isTrajectoryClear","testX","testY","stepDist","children","child","MYSTERY","getClosestBubbles","limit","distA","distB","targetDist","checkX","checkY","quickCountPotentialMatch","shootColor","toCheck","matchCount","predictFallsFromShot","supportingNeighbors","n","other","EnhancedScoreDisplay","playerScore","opponentScore","playerScoreText","opponentScoreText","playerNameText","opponentNameText","playerDisplayScore","opponentDisplayScore","playerTargetScore","opponentTargetScore","playerLeadIndicator","opponentLeadIndicator","currentLeader","playerContainer","opponentContainer","createPlayerDisplay","createOpponentDisplay","containerHeight","containerWidth","updatePlayerScore","newScore","instant","formatScore","pulseScore","updateLeaderIndicator","updateOpponentScore","scoreText","toLocaleString","newLeader","animateLeader","indicator","ComboManager","currentCombo","comboContainers","COMBO_CONFIGS","tier","minBubbles","CHAIN_BONUS","createComboDisplay","comboContainer","comboText","comboConfig","getComboConfig","chainBonus","showCombo","addComboBackground","displayColor","setFontSize","setStyle","createParticleEffect","createImpactFlash","addComboStars","starCount","starX","createFireExplosion","createExplosionEffect","createColorBurst","particleSize","speedRange","shadeVariation","particleColor","ValueToColor","finalColor","createGlowEffect","explosionColor","streak","setRotation","fireGradient","dist","fireParticle","starBurst","fireColors","c","shockwave","fireColor","flame","fireText","colorFlash","getCurrentCombo","getMultiplier","VictoryScreen","onReplay","onMenu","backdrop","panelBg","banner","victoryGlow","victoryText","star1","createStar","star2","star3","scoreBg","scoreLabel","scoreValue","statsText","playAgainBtn","menuBtn","scoreCounter","toString","createConfetti","bgColor","hoverColor","label","confettiTimer","shape","DefeatScreen","onRetry","defeatText","encourageText","motivationalMsg","motivationText","retryBtn","createFloatingBubbles","isPrimary","FloatingTextEffect","gameObject","deactivate","activate","targetScale","ParticleBurstEffect","MAX_PARTICLES","intensity","speedBase","setRadius","RingExplosionEffect","EffectPool","pools","activeEffects","POOL_SIZES","floating_text","particle_burst","ring_explosion","star_burst","combo_display","initializePools","createPool","factory","pool","getEffect","effect","oldest","showFloatingText","showParticleBurst","showRingExplosion","showComboEffect","comboLevel","UnifiedFeedbackSystem","effectPool","feedbackQueue","activeFeedbacks","MIN_VERTICAL_SPACING","MIN_HORIZONTAL_SPACING","FEEDBACK_DURATION","queueFeedback","f","endTime","itemsToProcess","showFeedback","calculateOffset","finalPosition","showEffectsForLevel","offsetY","conflictCount","createSparkleEffect","createPopEffect","addScreenShake","addCameraFlash","createFireEffect","colorObj","ExceptionCode","AimingMode","AimingModeSystem","currentMode","aimingGraphics","trajectoryLine","cursorSprite","modeIndicator","trajectoryPoints","MAX_BOUNCES","TRAJECTORY_STEPS","setMode","mode","powerUp","clearGraphics","createModeIndicator","updateCursorStyle","updateAiming","pointerX","pointerY","launcherX","drawNormalCrosshair","drawBasicTrajectory","drawRainbowCrosshair","drawLaserSight","drawBombRadius","drawBallisticArc","drawSelectionCursor","drawFreezeArea","drawTripleArrow","moveTo","lineTo","nextAngle","lastPoint","maxHeight","Linear","Point","sx","sy","baseAngle","drawArrowHead","angleLeft","angleRight","steps","t1","t2","extended","bounces","maxSteps","modeNames","crosshair","rainbow_sphere","extended_line","explosion_radius","ballistic_arc","selection_cursor","snowflake_area","triple_arrow","style","cursor","getTargetingInfo","trajectory","RainbowEffect","rainbowBubble","visualElements","aimingMode","rainbowText","shotsRemaining","applyRainbowEffect","NORMAL","LaserSightEffect","remainingShots","createShotCounter","counter","BombEffect","targetMode","BOMB_BALLISTIC","prepareBallistic","BOMB_NORMAL","prepareNormalBomb","bombGlow","glowRadius","glowTimer","sparkContainer","sparkTimer","bombCore","bombText","blur","fill","explodeAt","shockRadius","shockTimer","explosionContainer","debrisContainer","debris","smokeContainer","smoke","miniFlash","LightningEffect","selectionHandler","lightningText","destroyWithLightning","lightning","currentX","currentY","nextX","nextY","FreezeEffect","frozenBubbles","frostOverlay","physics","createFrostOverlay","freezeText","snowflake","MultiShotEffect","MULTI","multiText","PowerUpActivationSystem","effects","activeEffect","aimingModeSystem","setupEventListeners","showActivationFeedback","powerUpNames","PaintSplatterSystem","splatters","minDropletSize","maxDropletSize","minDroplets","maxDroplets","minSpread","maxSpread","fadeStartDelay","fadeDuration","initialAlpha","colorVariation","maxSplatters","cleanupBatchSize","scaleWithCombo","comboScaleFactor","maxComboScale","DEFAULT_CONFIG","updateConfig","getConfig","handleBubbleExplosion","dropletsPerBubble","calculateDropletsPerBubble","createSplatterAtPosition","createSplatter","bubbleCount","totalDroplets","extraDroplets","dropletCount","createDroplet","spreadMultiplier","dropletX","dropletY","sizeMultiplier","variedColor","applyColorVariation","shapeType","save","translateCanvas","rotateCanvas","restore","closePath","fillPath","pointAngle","pointDist","oldSplatter","variation","darkness","newR","newG","newB","cam","isNaN","isFinite","getSplatterCount","setQualityPreset","preset","ArenaSystem","HARD","objective","bubblePool","zones","debugGraphics","debugEnabled","shootingSystem","aiOpponent","isSinglePlayer","enhancedScoreDisplay","comboManager","scoreEventManager","unifiedFeedbackSystem","playerPowerUpInventory","opponentPowerUpInventory","powerUpActivation","aiScore","gameOver","victoryScreen","defeatScreen","isRestarting","playerDangerLine","opponentDangerLine","dangerWarningActive","paintSplatterSystem","dangerCheckCounter","DANGER_CHECK_INTERVAL","shieldCheckCounter","SHIELD_CHECK_INTERVAL","cachedShieldState","aimingCheckCounter","AIMING_CHECK_INTERVAL","lastAimAngle","initializeZones","createBubblePool","setupArena","singlePlayer","currentDifficulty","actualDifficulty","createLaunchers","createObjective","createInitialBubbles","createZoneVisuals","checkVictoryCondition","checkChestHit","toggleDebug","changeAIDifficulty","EASY","MEDIUM","playerZone","opponentZone","midPoint","allPositions","totalBubbles","targetMysteryCount","mysteryPerSide","mysteryPositions","side","sideCount","maxAttempts","attempts","isPlayerSide","mysteryBubble","playerSideMysteryCount","opponentSideMysteryCount","getBubbleFromPool","updateObjectiveShield","returnBubbleToPool","showDebugOverlay","hideDebugOverlay","toUpperCase","backgroundColor","drawHexGrid","strokePoints","Text","hasAdjacentBubbles","getZoneBounds","getBubbles","getObjective","getPlayerLauncher","getOpponentLauncher","updateLauncherAiming","checkDangerZoneProximity","launcherPos","showDifficultyNotification","notification","ORPHAN_DROP","baseValue","BUBBLE_MATCH","SPECIAL_BONUS","playerWins","obj","triggerGameOver","playerDangerY","opponentDangerY","expectedPos","wasAIShot","restartGame","returnToMenu","fade","winner","removeAll","restart","phaserError","location","href","split","reload","e2","history","go","nearDanger","playerDistance","activateDangerWarning","opponentDistance","deactivateDangerWarning","dangerLine","getPaintSplatterSystem","setGraphicsQuality","RealSoundSystem","sounds","muted","masterVolume","volumes","shoot","attach","celebration","arsenal","victory","initializeSounds","audioCache","Object","values","playShootSound","playSound","playAttachSound","playBubblesDropSound","playComboSound","soundKey","volume","playMatchSound","playArsenalPickupSound","playSuccessObjectiveSound","playVictorySound","playDefeatSound","playPowerUpSound","playClickSound","playBackgroundMusic","existingMusic","music","play","rate","toggleMute","mute","setMasterVolume","testAllSounds","getInfo","soundsLoaded","totalSounds","TweenOptimizer","activeTweens","tweenGroups","frameCounter","createOptimizedTween","id","props","options","group","existingTween","getGroupTween","canShareTween","addTargetToTween","stagger","tweenConfig","throttleUpdate","tweenData","linkedConfig","groupIds","firstId","removeTween","ids","pauseGroup","resumeGroup","getStats","tweensPerGroup","totalTweens","groups","GameScene","arenaSystem","soundSystem","backgroundMusic","lastFPSUpdate","isPaused","tweenOptimizer","isCapacitor","Capacitor","setBackgroundColor","createSoundSystem","createBackgroundMusic","createArena","createUI","setupInputHandlers","setupSoundEvents","padding","setScrollFactor","togglePause","testBubblePop","randomBubble","showPauseOverlay","hidePauseOverlay","pauseText","resumeText","updateFPSDisplay","elapsed","CapacitorException","code","createCapacitor","win","capCustomPlatform","CapacitorCustomPlatform","cap","Plugins","getPlatform","_a","_b","androidBridge","webkit","messageHandlers","bridge","getPlatformId","getPluginHeader","pluginName","PluginHeaders","registeredPlugins","convertFileSrc","filePath","handleError","err","console","isNativePlatform","isPluginAvailable","plugin","platforms","registerPlugin","jsImplementations","registeredPlugin","proxy","pluginHeader","jsImplementation","createPluginMethodWrapper","prop","wrapper","args","loadPluginImplementation","then","impl","fn","Unimplemented","methodHeader","methods","m","rtype","nativePromise","nativeCallback","createPluginMethod","defineProperty","writable","configurable","addListener","removeListener","addListenerNative","eventName","call","callbackId","Proxy","_","keys","Exception","DEBUG","isLoggingEnabled","initCapacitorGlobal","globalThis","self","global","WebPlugin","listeners","retainedEventArguments","windowListeners","listenerFunc","firstListener","windowListener","registered","addWindowListener","sendRetainedArgumentsForEvent","removeAllListeners","listener","removeWindowListener","notifyListeners","retainUntilConsumed","hasListeners","registerWindowListener","windowEventName","pluginEventName","handler","unimplemented","msg","unavailable","Unavailable","handle","removeEventListener","arg","encode","str","encodeURIComponent","decodeURIComponent","escape","decode","CapacitorCookiesPluginWeb","getCookies","cookies","cookie","cookieMap","trim","setCookie","encodedKey","encodedValue","expires","path","domain","reject","deleteCookie","clearCookies","toUTCString","clearAllCookies","web","buildRequestInit","extra","output","assign","method","headers","originalKeys","k","toLocaleLowerCase","acc","normalizeHttpHeaders","body","params","URLSearchParams","entries","FormData","form","append","Headers","JSON","stringify","CapacitorHttpPluginWeb","request","requestInit","webFetchExtra","urlParams","shouldEncode","accumulator","entry","isArray","substr","buildUrlParams","shouldEncodeUrlParams","response","fetch","contentType","blob","responseType","ok","reader","FileReader","onload","base64String","onerror","readAsDataURL","readBlobAsBase64","status","post","put","patch","Style","Animation","StatusBar","KeyboardStyle","KeyboardResize","Keyboard","App","__vitePreload","import","AppWeb","Performance","maximizePerformance","success","getDeviceCapabilities","model","systemVersion","processorCount","hardwareConcurrency","physicalMemory","thermalState","lowPowerMode","batteryLevel","supportsProMotion","CapacitorOptimizations","initialize","hideStatusBar","configureKeyboard","handleAppStateChanges","disableOverscroll","optimizeWebView","requestHighPerformance","maximizeDevicePerformance","setResizeMode","setAccessoryBarVisible","onAppResume","onAppPause","overflow","touches","preventDefault","passive","userSelect","webkitUserSelect","webkitTapHighlightColor","transform","webkitTransform","webkitTouchCallout","viewport","querySelector","setAttribute","wakeLock","catch","audioContext","suspend","release","optimizer","setupErrorHandling","waitForDOM","createGame","hideLoadingScreen","readyState","scenes","resolution","WEBGL","parent","Scale","FIT","autoCenter","CENTER_BOTH","default","arcade","gravity","debug","forceSetTimeOut","render","antialias","pixelArt","roundPixels","transparent","clearBeforeRender","preserveDrawingBuffer","premultipliedAlpha","failIfMajorPerformanceCaveat","powerPreference","batchSize","maxLights","maxTextures","mipmapFilter","desynchronized","autoMobilePipeline","multiTexture","antialiasSamples","stencil","webGLTimeout","forceWebGL1","disableWebAudio","noAudio","activePointers","smoothFactor","windowEvents","disableVisibilityChange","createGameConfig","Game","setupGameEventListeners","loadingElement","getElementById","transition","opacity","display","innerHTML","getGame"],"sources":["../../src/utils/DeviceDetection.ts","../../src/config/GameConfig.ts","../../src/types/GameTypes.ts","../../src/systems/core/SceneManager.ts","../../src/utils/PerformanceMonitor.ts","../../src/scenes/BootScene.ts","../../src/config/AssetManifest.ts","../../src/scenes/PreloadScene.ts","../../src/scenes/MenuScene.ts","../../src/systems/visual/BackgroundSystem.ts","../../src/scenes/ThemeSelectScene.ts","../../src/types/ArenaTypes.ts","../../src/config/ArenaConfig.ts","../../src/systems/gameplay/BubbleGrid.ts","../../src/gameObjects/Bubble.ts","../../src/systems/scoring/ScoreEventManager.ts","../../src/systems/powerups/PowerUpManager.ts","../../src/gameObjects/MysteryBubble.ts","../../src/gameObjects/Launcher.ts","../../src/gameObjects/Objective.ts","../../src/systems/input/InputManager.ts","../../src/systems/gameplay/TrajectoryPreview.ts","../../src/systems/gameplay/ShootingSystem.ts","../../src/systems/gameplay/GridAttachmentSystem.ts","../../src/systems/gameplay/MatchDetectionSystem.ts","../../src/systems/gameplay/AIOpponentSystem.ts","../../src/ui/EnhancedScoreDisplay.ts","../../src/systems/gameplay/ComboManager.ts","../../src/ui/VictoryScreen.ts","../../src/ui/DefeatScreen.ts","../../src/systems/scoring/EffectPool.ts","../../src/systems/scoring/UnifiedFeedbackSystem.ts","../../src/systems/powerups/AimingModeSystem.ts","../../node_modules/@capacitor/core/dist/index.js","../../src/systems/powerups/PowerUpEffectsLibrary.ts","../../src/systems/powerups/PowerUpActivationSystem.ts","../../src/systems/visual/PaintSplatterSystem.ts","../../src/systems/gameplay/ArenaSystem.ts","../../src/systems/audio/RealSoundSystem.ts","../../src/systems/visual/TweenOptimizer.ts","../../src/scenes/GameScene.ts","../../node_modules/@capacitor/status-bar/dist/esm/definitions.js","../../node_modules/@capacitor/status-bar/dist/esm/index.js","../../node_modules/@capacitor/keyboard/dist/esm/definitions.js","../../node_modules/@capacitor/keyboard/dist/esm/index.js","../../node_modules/@capacitor/app/dist/esm/index.js","../../src/utils/performancePlugin.ts","../../src/utils/capacitorOptimizations.ts","../../src/main.ts"],"sourcesContent":["import { IDeviceCapabilities } from '@/types/GameTypes';\n\nexport class DeviceDetection {\n    private static instance: DeviceDetection;\n    private capabilities: IDeviceCapabilities;\n\n    private constructor() {\n        this.capabilities = this.detectCapabilities();\n    }\n\n    public static getInstance(): DeviceDetection {\n        if (!DeviceDetection.instance) {\n            DeviceDetection.instance = new DeviceDetection();\n        }\n        return DeviceDetection.instance;\n    }\n\n    private detectCapabilities(): IDeviceCapabilities {\n        const ua = navigator.userAgent.toLowerCase();\n        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        \n        const isMobile = /android|webos|iphone|ipod|blackberry|iemobile|opera mini/i.test(ua);\n        const isTablet = /ipad|android(?!.*mobile)/i.test(ua);\n        const isDesktop = !isMobile && !isTablet;\n        \n        const screenWidth = window.innerWidth;\n        const screenHeight = window.innerHeight;\n        const isLandscape = screenWidth > screenHeight;\n        const isPortrait = !isLandscape;\n        \n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n        const hasWebGL = !!gl;\n        \n        let maxTextureSize = 2048;\n        if (gl && hasWebGL) {\n            maxTextureSize = (gl as WebGLRenderingContext).getParameter((gl as WebGLRenderingContext).MAX_TEXTURE_SIZE);\n        }\n        \n        const AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n        const hasWebAudio = !!AudioContext;\n        const hasAudioTag = !!document.createElement('audio').canPlayType;\n        \n        return {\n            isTouch,\n            isMobile,\n            isTablet,\n            isDesktop,\n            pixelRatio: window.devicePixelRatio || 1,\n            screenWidth,\n            screenHeight,\n            isLandscape,\n            isPortrait,\n            hasWebGL,\n            maxTextureSize,\n            audioSupport: {\n                webAudio: hasWebAudio,\n                audioTag: hasAudioTag\n            }\n        };\n    }\n\n    public getCapabilities(): IDeviceCapabilities {\n        return { ...this.capabilities };\n    }\n\n    public updateOrientation(): void {\n        const screenWidth = window.innerWidth;\n        const screenHeight = window.innerHeight;\n        this.capabilities.screenWidth = screenWidth;\n        this.capabilities.screenHeight = screenHeight;\n        this.capabilities.isLandscape = screenWidth > screenHeight;\n        this.capabilities.isPortrait = !this.capabilities.isLandscape;\n    }\n\n    public getQualityPreset(): 'low' | 'medium' | 'high' {\n        const { isMobile, pixelRatio, maxTextureSize } = this.capabilities;\n        \n        if (isMobile && pixelRatio > 2 && maxTextureSize >= 4096) {\n            return 'high';\n        } else if (isMobile || maxTextureSize < 2048) {\n            return 'low';\n        } else {\n            return 'medium';\n        }\n    }\n\n    public shouldReduceMotion(): boolean {\n        return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n    }\n\n    public getOptimalResolution(): { width: number; height: number } {\n        const HD_SCALE = 2;  // Keep HD quality\n        const baseWidth = 375 * HD_SCALE;  // 750 HD\n        const baseHeight = 667 * HD_SCALE;  // 1334 HD\n        const maxWidth = 414 * HD_SCALE;    // 828 HD\n        const maxHeight = 896 * HD_SCALE;   // 1792 HD\n        \n        const { screenWidth, screenHeight, pixelRatio } = this.capabilities;\n        \n        let width = Math.min(screenWidth, maxWidth);\n        let height = Math.min(screenHeight, maxHeight);\n        \n        // Use HD resolution for all devices\n        width = Math.min(width * HD_SCALE, maxWidth);\n        height = Math.min(height * HD_SCALE, maxHeight);\n        \n        return { width: Math.floor(width), height: Math.floor(height) };\n    }\n}","import Phaser from 'phaser';\nimport { IGameConfig } from '@/types/GameTypes';\nimport { DeviceDetection } from '@utils/DeviceDetection';\n\nexport function createGameConfig(scenes: any[]): IGameConfig {\n    const device = DeviceDetection.getInstance();\n    const resolution = device.getOptimalResolution();\n    \n    // Detect if running on iOS/Capacitor\n    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);\n    const isCapacitor = (window as any).Capacitor !== undefined;\n    const isMobile = device.getCapabilities().isMobile || isIOS || isCapacitor;\n    \n    // PERFORMANCE: Use device pixel ratio for better performance on Capacitor\n    // This renders at native resolution instead of forcing 2x\n    const pixelRatio = (isCapacitor && window.devicePixelRatio) ? window.devicePixelRatio : 1;\n    \n    return {\n        // Force WebGL for consistent rendering across all platforms\n        type: Phaser.WEBGL,\n        parent: 'game',\n        backgroundColor: '#1a1a2e',\n        width: resolution.width,\n        height: resolution.height,\n        scale: {\n            mode: Phaser.Scale.FIT,\n            autoCenter: Phaser.Scale.CENTER_BOTH,\n            width: resolution.width,\n            height: resolution.height\n        },\n        physics: {\n            default: 'arcade',\n            arcade: {\n                gravity: { x: 0, y: 0 },\n                debug: false,\n                // iOS-optimized physics with interpolation\n            }\n        },\n        fps: {\n            target: 120,  // Target 120 FPS on all platforms\n            forceSetTimeOut: false  // Use RAF for better performance\n        },\n        render: {\n            // PERFORMANCE: Optimize for iOS\n            antialias: false,  // Disable for better performance\n            pixelArt: false,\n            roundPixels: false,  // Better performance\n            transparent: false,\n            clearBeforeRender: true,\n            preserveDrawingBuffer: false,\n            premultipliedAlpha: true,\n            failIfMajorPerformanceCaveat: false,\n            powerPreference: 'high-performance',  // Request high-performance GPU\n            batchSize: 4096,  // Increased for 120 FPS target\n            // Ultra HD resolution for premium quality\n            // Using higher resolution for sharper graphics\n            resolution: Math.min(window.devicePixelRatio || 1, 3),\n            maxLights: 1,  // Minimum required for shader compilation\n            maxTextures: -1,\n            mipmapFilter: 'LINEAR',\n            // CRITICAL iOS PERFORMANCE\n            desynchronized: true,  // Better performance for 120 FPS\n            autoMobilePipeline: false,  // Disable auto pipeline for consistency\n            multiTexture: true,  // Enable for better batching at 120 FPS\n            // WebGL specific settings\n            antialiasSamples: 0,  // No MSAA for performance\n            depth: false,  // We don't need depth buffer\n            stencil: false,  // We don't need stencil buffer\n            // iOS specific WebGL optimizations\n            webGLTimeout: 0,  // Disable WebGL timeout\n            forceWebGL1: false  // Use WebGL2 if available\n        },\n        scene: scenes,\n        // iOS-specific optimizations\n        audio: {\n            disableWebAudio: false,\n            noAudio: false\n        },\n        input: {\n            activePointers: 2,  // Support multi-touch\n            smoothFactor: 0,\n            windowEvents: false  // Prevent window event conflicts\n        },\n        // Disable features that impact performance\n        disableVisibilityChange: false,\n        banner: false\n    };\n}\n\n// HD_SCALE: Factor to scale everything for Ultra HD quality\nexport const HD_SCALE = 2.5; // Ultra HD quality restored\n\nexport const GAME_CONSTANTS = {\n    BASE_WIDTH: 375 * HD_SCALE,  // 750 for HD\n    BASE_HEIGHT: 667 * HD_SCALE,  // 1334 for HD\n    MAX_WIDTH: 414 * HD_SCALE,    // 828 for HD\n    MAX_HEIGHT: 896 * HD_SCALE,   // 1792 for HD\n    TARGET_FPS: 120,\n    HD_SCALE: HD_SCALE,  // Export scale factor\n    \n    BUBBLE_SIZE: 32 * HD_SCALE,  // 64 for HD\n    BUBBLE_SPEED: 800 * HD_SCALE,  // 1600 for HD\n    GRID_ROWS: 12,\n    GRID_COLS: 11,\n    \n    COLORS: {\n        BACKGROUND: '#1a1a2e',\n        UI_PRIMARY: '#f39c12',\n        UI_SECONDARY: '#3498db',\n        UI_SUCCESS: '#2ecc71',\n        UI_DANGER: '#e74c3c',\n        UI_TEXT: '#ffffff',\n        UI_TEXT_DARK: '#2c3e50'\n    },\n    \n    ANIMATIONS: {\n        BUBBLE_POP_DURATION: 200,\n        SCENE_TRANSITION_DURATION: 300,\n        UI_TRANSITION_DURATION: 200,\n        COMBO_DISPLAY_DURATION: 1000\n    },\n    \n    AUDIO: {\n        MASTER_VOLUME: 0.7,\n        SFX_VOLUME: 0.8,\n        MUSIC_VOLUME: 0.5\n    },\n    \n    NETWORKING: {\n        SYNC_RATE: 100,\n        TIMEOUT: 10000,\n        RECONNECT_ATTEMPTS: 3\n    }\n};\n\nexport const QUALITY_PRESETS = {\n    low: {\n        particleCount: 10,\n        particleScale: 0.5,\n        shadowsEnabled: false,\n        postProcessing: false,\n        textureQuality: 0.5,\n        maxDrawCalls: 50\n    },\n    medium: {\n        particleCount: 25,\n        particleScale: 0.75,\n        shadowsEnabled: false,\n        postProcessing: false,\n        textureQuality: 0.75,\n        maxDrawCalls: 100\n    },\n    high: {\n        particleCount: 50,\n        particleScale: 1,\n        shadowsEnabled: true,\n        postProcessing: true,\n        textureQuality: 1,\n        maxDrawCalls: 200\n    }\n};","import { Scene } from 'phaser';\n\nexport interface IGameConfig {\n    width: number;\n    height: number;\n    type: number;\n    parent: string;\n    backgroundColor: string;\n    scale: {\n        mode: Phaser.Scale.ScaleModes;\n        autoCenter: Phaser.Scale.Center;\n        width: number;\n        height: number;\n    };\n    physics: {\n        default: string;\n        arcade: {\n            gravity: { x: number; y: number };\n            debug: boolean;\n        };\n    };\n    fps?: {\n        target: number;\n        forceSetTimeOut: boolean;\n    };\n    render?: any;\n    scene: Scene[];\n}\n\nexport interface ISceneData {\n    transitionFrom?: string;\n    transitionDuration?: number;\n    data?: Record<string, unknown>;\n}\n\nexport interface IDeviceCapabilities {\n    isTouch: boolean;\n    isMobile: boolean;\n    isTablet: boolean;\n    isDesktop: boolean;\n    pixelRatio: number;\n    screenWidth: number;\n    screenHeight: number;\n    isLandscape: boolean;\n    isPortrait: boolean;\n    hasWebGL: boolean;\n    maxTextureSize: number;\n    audioSupport: {\n        webAudio: boolean;\n        audioTag: boolean;\n    };\n}\n\nexport interface IPerformanceMetrics {\n    fps: number;\n    frameTime: number;\n    deltaTime: number;\n    drawCalls: number;\n    memoryUsage: number | undefined;\n}\n\nexport interface IAssetManifestItem {\n    key: string;\n    url: string;\n    type: 'image' | 'audio' | 'json' | 'atlas' | 'spritesheet' | 'tilemapJSON';\n    data?: Record<string, unknown>;\n}\n\nexport interface IAssetManifest {\n    images: IAssetManifestItem[];\n    audio: IAssetManifestItem[];\n    atlases: IAssetManifestItem[];\n    json: IAssetManifestItem[];\n}\n\nexport enum SceneKeys {\n    BOOT = 'BootScene',\n    PRELOAD = 'PreloadScene',\n    MENU = 'MenuScene',\n    THEME_SELECT = 'ThemeSelectScene',\n    GAME = 'GameScene',\n    VICTORY = 'VictoryScene',\n    SHOP = 'ShopScene'\n}\n\nexport enum GameEvents {\n    SCENE_READY = 'scene-ready',\n    SCENE_TRANSITION = 'scene-transition',\n    PERFORMANCE_WARNING = 'performance-warning',\n    ASSET_LOADED = 'asset-loaded',\n    LOADING_COMPLETE = 'loading-complete',\n    QUALITY_CHANGED = 'quality-changed'\n}\n\nexport interface IGameSettings {\n    soundEnabled: boolean;\n    musicEnabled: boolean;\n    vibrationEnabled: boolean;\n    quality: 'low' | 'medium' | 'high' | 'auto';\n    language: string;\n}\n\nexport interface IGameState {\n    currentScene: string;\n    previousScene: string;\n    isTransitioning: boolean;\n    settings: IGameSettings;\n    performance: IPerformanceMetrics;\n}","import { Scene } from 'phaser';\nimport { GameEvents, ISceneData } from '@/types/GameTypes';\n\nexport class SceneManager {\n    private static instance: SceneManager;\n    private game: Phaser.Game;\n    private currentScene: string = '';\n    private previousScene: string = '';\n    private transitionInProgress: boolean = false;\n    private eventEmitter: Phaser.Events.EventEmitter;\n\n    private constructor(game: Phaser.Game) {\n        this.game = game;\n        this.eventEmitter = new Phaser.Events.EventEmitter();\n    }\n\n    public static getInstance(game?: Phaser.Game): SceneManager {\n        if (!SceneManager.instance) {\n            if (!game) {\n                throw new Error('SceneManager must be initialized with a game instance');\n            }\n            SceneManager.instance = new SceneManager(game);\n        }\n        return SceneManager.instance;\n    }\n\n    public transitionTo(sceneName: string, data?: ISceneData): void {\n        if (this.transitionInProgress) {\n            console.warn('Scene transition already in progress');\n            return;\n        }\n\n        if (!this.game.scene.getScene(sceneName)) {\n            console.error(`Scene \"${sceneName}\" not found`);\n            return;\n        }\n\n        console.log(`SceneManager: Starting transition from ${this.currentScene} to ${sceneName}`);\n        this.transitionInProgress = true;\n        this.previousScene = this.currentScene;\n        \n        const currentSceneInstance = this.game.scene.getScene(this.currentScene);\n        \n        if (currentSceneInstance && currentSceneInstance.scene.isActive()) {\n            this.fadeOutScene(currentSceneInstance as Scene, () => {\n                this.switchScene(sceneName, data);\n            });\n        } else {\n            this.switchScene(sceneName, data);\n        }\n    }\n\n    private fadeOutScene(scene: Scene, callback: () => void): void {\n        const duration = 300;\n        \n        if (scene.cameras && scene.cameras.main) {\n            scene.cameras.main.fadeOut(duration, 0, 0, 0);\n            scene.cameras.main.once('camerafadeoutcomplete', callback);\n        } else {\n            callback();\n        }\n    }\n\n    private switchScene(sceneName: string, data?: ISceneData): void {\n        console.log(`SceneManager: Switching from ${this.currentScene} to ${sceneName}`);\n        \n        if (this.currentScene && this.currentScene !== '') {\n            console.log(`SceneManager: Stopping scene ${this.currentScene}`);\n            // First stop the scene\n            this.game.scene.stop(this.currentScene);\n        }\n\n        const sceneData = {\n            ...data,\n            transitionFrom: this.previousScene\n        };\n\n        console.log(`SceneManager: Starting ${sceneName}`);\n        this.game.scene.start(sceneName, sceneData);\n        \n        // Ensure new scene is on top\n        this.game.scene.bringToTop(sceneName);\n        \n        this.currentScene = sceneName;\n        \n        const newScene = this.game.scene.getScene(sceneName) as Scene;\n        if (newScene && newScene.cameras && newScene.cameras.main) {\n            newScene.cameras.main.fadeIn(300, 0, 0, 0);\n            newScene.cameras.main.once('camerafadeincomplete', () => {\n                console.log(`SceneManager: Transition to ${sceneName} complete`);\n                this.transitionInProgress = false;\n                this.eventEmitter.emit(GameEvents.SCENE_READY, {\n                    scene: sceneName,\n                    previousScene: this.previousScene\n                });\n            });\n        } else {\n            console.log(`SceneManager: Transition to ${sceneName} complete (no fade)`);\n            this.transitionInProgress = false;\n            this.eventEmitter.emit(GameEvents.SCENE_READY, {\n                scene: sceneName,\n                previousScene: this.previousScene\n            });\n        }\n    }\n\n    public getCurrentScene(): string {\n        return this.currentScene;\n    }\n\n    public getPreviousScene(): string {\n        return this.previousScene;\n    }\n\n    public isTransitioning(): boolean {\n        return this.transitionInProgress;\n    }\n\n    public restartCurrentScene(data?: ISceneData): void {\n        if (this.currentScene) {\n            const scene = this.game.scene.getScene(this.currentScene);\n            if (scene) {\n                this.game.scene.stop(this.currentScene);\n                this.game.scene.start(this.currentScene, data);\n            }\n        }\n    }\n\n    public pauseCurrentScene(): void {\n        if (this.currentScene) {\n            this.game.scene.pause(this.currentScene);\n        }\n    }\n\n    public resumeCurrentScene(): void {\n        if (this.currentScene) {\n            this.game.scene.resume(this.currentScene);\n        }\n    }\n\n    public launchParallelScene(sceneName: string, data?: ISceneData): void {\n        if (!this.game.scene.getScene(sceneName)) {\n            console.error(`Scene \"${sceneName}\" not found`);\n            return;\n        }\n\n        this.game.scene.run(sceneName, data);\n    }\n\n    public stopParallelScene(sceneName: string): void {\n        if (this.game.scene.isActive(sceneName)) {\n            this.game.scene.stop(sceneName);\n        }\n    }\n\n    public on(event: string, callback: (...args: any[]) => void): void {\n        this.eventEmitter.on(event, callback);\n    }\n\n    public off(event: string, callback: (...args: any[]) => void): void {\n        this.eventEmitter.off(event, callback);\n    }\n\n    public once(event: string, callback: (...args: any[]) => void): void {\n        this.eventEmitter.once(event, callback);\n    }\n\n    public setCurrentScene(sceneName: string): void {\n        this.currentScene = sceneName;\n    }\n}","import { IPerformanceMetrics, GameEvents } from '@/types/GameTypes';\n\nexport class PerformanceMonitor {\n    private fps: number = 60;\n    private frameTime: number = 0;\n    private lastTime: number = 0;\n    private deltaTime: number = 0;\n    private frameCount: number = 0;\n    private fpsUpdateInterval: number = 500;\n    private lastFpsUpdate: number = 0;\n    private frames: number[] = [];\n    private maxFrameSamples: number = 60;\n    private warningThreshold: number = 30;\n    private criticalThreshold: number = 20;\n    private consecutiveLowFrames: number = 0;\n    private eventEmitter: Phaser.Events.EventEmitter | null = null;\n\n    constructor() {\n        this.lastTime = performance.now();\n        this.lastFpsUpdate = this.lastTime;\n    }\n\n    public setEventEmitter(emitter: Phaser.Events.EventEmitter): void {\n        this.eventEmitter = emitter;\n    }\n\n    public update(time: number): void {\n        const currentTime = time || performance.now();\n        this.deltaTime = currentTime - this.lastTime;\n        \n        // Simple FPS calculation every 500ms\n        if (currentTime - this.lastFpsUpdate >= this.fpsUpdateInterval) {\n            this.fps = Math.round(1000 / Math.max(16.67, this.deltaTime));\n            this.lastFpsUpdate = currentTime;\n        }\n        \n        this.lastTime = currentTime;\n    }\n\n    public getFPS(): number {\n        return this.fps;\n    }\n\n    public getFrameTime(): number {\n        return this.frameTime;\n    }\n\n    public getDeltaTime(): number {\n        return this.deltaTime;\n    }\n\n    public getMetrics(): IPerformanceMetrics {\n        return {\n            fps: this.fps,\n            frameTime: this.frameTime,\n            deltaTime: this.deltaTime,\n            drawCalls: 0,\n            memoryUsage: this.getMemoryUsage()\n        };\n    }\n\n    public shouldReduceQuality(): boolean {\n        const avgFps = this.getAverageFPS();\n        return avgFps < this.warningThreshold && this.consecutiveLowFrames > 5;\n    }\n\n    public shouldIncreaseQuality(): boolean {\n        const avgFps = this.getAverageFPS();\n        return avgFps >= 58 && this.consecutiveLowFrames === 0;\n    }\n\n    private getAverageFPS(): number {\n        if (this.frames.length === 0) return 60;\n        const avgFrameTime = this.frames.reduce((a, b) => a + b, 0) / this.frames.length;\n        return Math.round(1000 / avgFrameTime);\n    }\n\n    private getMemoryUsage(): number | undefined {\n        if ('memory' in performance) {\n            const memory = (performance as any).memory;\n            if (memory && memory.usedJSHeapSize) {\n                return Math.round(memory.usedJSHeapSize / 1048576);\n            }\n        }\n        return undefined;\n    }\n\n    public reset(): void {\n        this.fps = 60;\n        this.frameTime = 0;\n        this.lastTime = performance.now();\n        this.deltaTime = 0;\n        this.frameCount = 0;\n        this.lastFpsUpdate = this.lastTime;\n        this.frames = [];\n        this.consecutiveLowFrames = 0;\n    }\n\n    public getPerformanceScore(): number {\n        const avgFps = this.getAverageFPS();\n        const score = Math.min(100, (avgFps / 60) * 100);\n        return Math.round(score);\n    }\n\n    public logMetrics(): void {\n        const metrics = this.getMetrics();\n        console.log(\n            `FPS: ${metrics.fps} | ` +\n            `Frame Time: ${metrics.frameTime.toFixed(2)}ms | ` +\n            `Memory: ${metrics.memoryUsage || 'N/A'}MB | ` \n          // `Score: ${this.getPerformanceScore()}%`\n        );\n    }\n}","import { Scene } from 'phaser';\nimport { SceneKeys, ISceneData } from '@/types/GameTypes';\nimport { SceneManager } from '@systems/core/SceneManager';\nimport { DeviceDetection } from '@utils/DeviceDetection';\nimport { PerformanceMonitor } from '@utils/PerformanceMonitor';\nimport { GAME_CONSTANTS, HD_SCALE } from '@config/GameConfig';\n\nexport class BootScene extends Scene {\n    private sceneManager!: SceneManager;\n    private deviceDetection!: DeviceDetection;\n    private performanceMonitor!: PerformanceMonitor;\n\n    constructor() {\n        super({ key: SceneKeys.BOOT });\n    }\n\n    public init(_data: ISceneData): void {\n        console.log('BootScene: Initializing game systems...');\n        \n        this.deviceDetection = DeviceDetection.getInstance();\n        this.performanceMonitor = new PerformanceMonitor();\n        this.sceneManager = SceneManager.getInstance(this.game);\n        \n        this.performanceMonitor.setEventEmitter(this.game.events);\n        \n        this.setupDeviceListeners();\n        this.checkDeviceCapabilities();\n    }\n\n    public preload(): void {\n        const loadingText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            'Initializing...',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: `${12 * HD_SCALE}px`,\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        const progressBar = this.add.graphics();\n        const progressBox = this.add.graphics();\n        const width = 160 * HD_SCALE;\n        const height = 25 * HD_SCALE;\n        const x = this.cameras.main.centerX - width / 2;\n        const y = this.cameras.main.centerY + (20 * HD_SCALE);\n\n        progressBox.fillStyle(0x222222, 0.8);\n        progressBox.fillRect(x, y, width, height);\n\n        this.load.on('progress', (value: number) => {\n            progressBar.clear();\n            progressBar.fillStyle(0xffffff, 1);\n            progressBar.fillRect(x + (5 * HD_SCALE), y + (5 * HD_SCALE), (width - (10 * HD_SCALE)) * value, height - (10 * HD_SCALE));\n        });\n\n        this.load.on('complete', () => {\n            progressBar.destroy();\n            progressBox.destroy();\n            loadingText.destroy();\n        });\n    }\n\n    public create(): void {\n        console.log('BootScene: System initialization complete');\n        \n        const capabilities = this.deviceDetection.getCapabilities();\n        console.log('Device Capabilities:', capabilities);\n        \n        const qualityPreset = this.deviceDetection.getQualityPreset();\n        console.log(`Quality Preset: ${qualityPreset}`);\n        \n        this.setupGlobalEventListeners();\n        \n        // Set current scene first\n        this.sceneManager.setCurrentScene(SceneKeys.BOOT);\n        \n        // Then transition to PreloadScene\n        console.log('BootScene: About to transition to PRELOAD');\n        console.log('BootScene: SceneManager instance exists:', !!this.sceneManager);\n        console.log('BootScene: Available scenes:', this.game.scene.keys);\n        \n        try {\n            this.sceneManager.transitionTo(SceneKeys.PRELOAD);\n            console.log('BootScene: Transition to PRELOAD initiated successfully');\n        } catch (error) {\n            console.error('BootScene: Error transitioning to PRELOAD:', error);\n            // Fallback to direct scene start\n            this.scene.start(SceneKeys.PRELOAD);\n        }\n    }\n\n    public override update(time: number, _delta: number): void {\n        this.performanceMonitor.update(time);\n    }\n\n    private setupDeviceListeners(): void {\n        window.addEventListener('resize', () => {\n            this.deviceDetection.updateOrientation();\n            this.handleOrientationChange();\n        });\n\n        window.addEventListener('orientationchange', () => {\n            this.deviceDetection.updateOrientation();\n            this.handleOrientationChange();\n        });\n\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                this.handleGamePause();\n            } else {\n                this.handleGameResume();\n            }\n        });\n    }\n\n    private checkDeviceCapabilities(): void {\n        const capabilities = this.deviceDetection.getCapabilities();\n        \n        if (!capabilities.hasWebGL) {\n            console.error('WebGL not supported on this device');\n            this.showErrorMessage('WebGL is required to play this game');\n            return;\n        }\n\n        if (capabilities.isLandscape && capabilities.isMobile) {\n            console.warn('Device is in landscape mode');\n        }\n\n        if (capabilities.maxTextureSize < 2048) {\n            console.warn('Device has limited texture size support');\n        }\n    }\n\n    private handleOrientationChange(): void {\n        const capabilities = this.deviceDetection.getCapabilities();\n        \n        if (capabilities.isMobile && capabilities.isLandscape) {\n            console.log('Please rotate device to portrait mode');\n        }\n        \n        const width = Math.min(capabilities.screenWidth, GAME_CONSTANTS.MAX_WIDTH);\n        const height = Math.min(capabilities.screenHeight, GAME_CONSTANTS.MAX_HEIGHT);\n        \n        this.scale.resize(width, height);\n    }\n\n    private handleGamePause(): void {\n        console.log('Game paused (tab inactive)');\n        this.sceneManager.pauseCurrentScene();\n        this.sound.pauseAll();\n    }\n\n    private handleGameResume(): void {\n        console.log('Game resumed (tab active)');\n        this.sceneManager.resumeCurrentScene();\n        this.sound.resumeAll();\n    }\n\n    private setupGlobalEventListeners(): void {\n        this.game.events.on('performance-warning', (data: { fps: number; severity: string }) => {\n            console.warn(`Performance warning: FPS ${data.fps} (${data.severity})`);\n            \n            if (data.severity === 'critical') {\n                this.handleCriticalPerformance();\n            }\n        });\n\n        this.game.events.on('scene-ready', (data: { scene: string; previousScene: string }) => {\n            console.log(`Scene ready: ${data.scene} (from ${data.previousScene})`);\n        });\n    }\n\n    private handleCriticalPerformance(): void {\n        console.error('Critical performance issue detected');\n    }\n\n    private showErrorMessage(message: string): void {\n        const errorText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            message,\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: `${10 * HD_SCALE}px`,\n                color: '#ff0000',\n                align: 'center',\n                wordWrap: { width: 150 * HD_SCALE }\n            }\n        ).setOrigin(0.5);\n\n        this.add.rectangle(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            errorText.width + (20 * HD_SCALE),\n            errorText.height + (20 * HD_SCALE),\n            0x000000,\n            0.8\n        ).setOrigin(0.5);\n\n        errorText.setDepth(1);\n    }\n}","import { IAssetManifest, IAssetManifestItem } from '@/types/GameTypes';\n\nexport const ASSET_KEYS = {\n    IMAGES: {\n        LOGO: 'logo',\n        BUBBLE: 'bubble',\n        BACKGROUND: 'background',\n        BUTTON: 'button',\n        PARTICLE: 'particle',\n        PLANET: 'planet',\n        BUBBLE_PLANET: 'bubble_planet'\n    },\n    AUDIO: {\n        BUBBLE_SHOOT: 'bubble-shoot',\n        BUBBLE_ATTACH: 'bubble-attach',\n        BUBBLES_DROP: 'bubbles-drop',\n        COMBO_3: 'combo-3',\n        COMBO_4: 'combo-4',\n        COMBO_5_PLUS: 'combo-5-plus',\n        COMBO_CELEBRATION: 'combo-celebration',\n        ARSENAL_PICKUP: 'arsenal-pickup',\n        SUCCESS_OBJECTIVE: 'success-objective',\n        VICTORY: 'victory',\n        DEFEAT: 'defeat',\n        BACKGROUND_MUSIC: 'background-music'\n    },\n    ATLASES: {\n        UI: 'ui_atlas',\n        BUBBLES: 'bubbles_atlas',\n        EFFECTS: 'effects_atlas'\n    },\n    JSON: {\n        LEVELS: 'levels',\n        PARTICLE_CONFIGS: 'particle_configs',\n        LOCALIZATION: 'localization'\n    }\n};\n\nexport function createAssetManifest(): IAssetManifest {\n    const manifest: IAssetManifest = {\n        images: [\n            {\n                key: ASSET_KEYS.IMAGES.LOGO,\n                url: 'assets/images/logo-placeholder.png',\n                type: 'image',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.IMAGES.BACKGROUND,\n                url: 'assets/images/background-placeholder.png',\n                type: 'image',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.IMAGES.PLANET,\n                url: 'assets/sprites/planeta.png',\n                type: 'image',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.IMAGES.BUBBLE_PLANET,\n                url: 'assets/sprites/bubble_planet.png',\n                type: 'image',\n                data: {}\n            }\n        ],\n        audio: [\n            {\n                key: ASSET_KEYS.AUDIO.BUBBLE_SHOOT,\n                url: 'assets/sounds/bubble-shoot.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.BUBBLE_ATTACH,\n                url: 'assets/sounds/bubbles-attach.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.BUBBLES_DROP,\n                url: 'assets/sounds/bubbles-drop.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.COMBO_3,\n                url: 'assets/sounds/combo-3.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.COMBO_4,\n                url: 'assets/sounds/combo-4.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.COMBO_5_PLUS,\n                url: 'assets/sounds/combo-5-plus.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.COMBO_CELEBRATION,\n                url: 'assets/sounds/combo-celebration.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.ARSENAL_PICKUP,\n                url: 'assets/sounds/arsenal-pickup.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.SUCCESS_OBJECTIVE,\n                url: 'assets/sounds/success-objective.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.VICTORY,\n                url: 'assets/sounds/victory.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.DEFEAT,\n                url: 'assets/sounds/defeat.mp3',\n                type: 'audio',\n                data: {}\n            },\n            {\n                key: ASSET_KEYS.AUDIO.BACKGROUND_MUSIC,\n                url: 'assets/sounds/background-music.mp3',\n                type: 'audio',\n                data: {}\n            }\n        ],\n        atlases: [],\n        json: []\n    };\n\n    return manifest;\n}\n\nexport class AssetLoader {\n    private scene: Phaser.Scene;\n    private manifest: IAssetManifest;\n    private loadedCount: number = 0;\n    private totalCount: number = 0;\n\n    constructor(scene: Phaser.Scene) {\n        this.scene = scene;\n        this.manifest = createAssetManifest();\n        this.calculateTotalAssets();\n    }\n\n    private calculateTotalAssets(): void {\n        this.totalCount = \n            this.manifest.images.length +\n            this.manifest.audio.length +\n            this.manifest.atlases.length +\n            this.manifest.json.length;\n    }\n\n    public loadAssets(onProgress?: (progress: number) => void): void {\n        if (onProgress) {\n            this.scene.load.on('progress', (value: number) => {\n                onProgress(value);\n            });\n        }\n\n        this.scene.load.on('fileprogress', (file: Phaser.Loader.File) => {\n            console.log(`Loading: ${file.key}`);\n        });\n\n        this.loadImages();\n        this.loadAudio();\n        this.loadAtlases();\n        this.loadJSON();\n\n        this.scene.load.on('complete', () => {\n            console.log('All assets loaded');\n        });\n    }\n\n    private loadImages(): void {\n        this.manifest.images.forEach((item: IAssetManifestItem) => {\n            if (this.scene.textures.exists(item.key)) {\n                console.log(`Image ${item.key} already loaded`);\n                return;\n            }\n            this.scene.load.image(item.key, item.url);\n        });\n    }\n\n    private loadAudio(): void {\n        this.manifest.audio.forEach((item: IAssetManifestItem) => {\n            if (this.scene.cache.audio.exists(item.key)) {\n                console.log(`Audio ${item.key} already loaded`);\n                return;\n            }\n            this.scene.load.audio(item.key, item.url);\n        });\n    }\n\n    private loadAtlases(): void {\n        this.manifest.atlases.forEach((item: IAssetManifestItem) => {\n            if (this.scene.textures.exists(item.key)) {\n                console.log(`Atlas ${item.key} already loaded`);\n                return;\n            }\n            const jsonUrl = item.url.replace('.png', '.json');\n            this.scene.load.atlas(item.key, item.url, jsonUrl);\n        });\n    }\n\n    private loadJSON(): void {\n        this.manifest.json.forEach((item: IAssetManifestItem) => {\n            if (this.scene.cache.json.exists(item.key)) {\n                console.log(`JSON ${item.key} already loaded`);\n                return;\n            }\n            this.scene.load.json(item.key, item.url);\n        });\n    }\n\n    public getProgress(): number {\n        return this.loadedCount / Math.max(1, this.totalCount);\n    }\n\n    public getTotalAssets(): number {\n        return this.totalCount;\n    }\n\n    public getLoadedAssets(): number {\n        return this.loadedCount;\n    }\n}","import { Scene } from 'phaser';\nimport { SceneKeys, ISceneData, GameEvents } from '@/types/GameTypes';\nimport { SceneManager } from '@systems/core/SceneManager';\nimport { AssetLoader, ASSET_KEYS } from '@config/AssetManifest';\nimport { GAME_CONSTANTS } from '@config/GameConfig';\nimport { PerformanceMonitor } from '@utils/PerformanceMonitor';\n\nexport class PreloadScene extends Scene {\n    private sceneManager!: SceneManager;\n    private assetLoader!: AssetLoader;\n    private performanceMonitor!: PerformanceMonitor;\n    private loadingText!: Phaser.GameObjects.Text;\n    private progressBar!: Phaser.GameObjects.Graphics;\n    private progressBox!: Phaser.GameObjects.Graphics;\n    private percentText!: Phaser.GameObjects.Text;\n    private assetText!: Phaser.GameObjects.Text;\n\n    constructor() {\n        super({ key: SceneKeys.PRELOAD });\n    }\n\n    public init(_data: ISceneData): void {\n        console.log('PreloadScene: Starting asset loading...');\n        this.sceneManager = SceneManager.getInstance();\n        this.performanceMonitor = new PerformanceMonitor();\n        this.assetLoader = new AssetLoader(this);\n    }\n\n    public preload(): void {\n        this.createLoadingUI();\n        this.setupLoadingListeners();\n        \n        this.createPlaceholderAssets();\n        \n        this.assetLoader.loadAssets((progress: number) => {\n            this.updateProgress(progress);\n        });\n    }\n\n    public create(): void {\n        console.log('PreloadScene: All assets loaded');\n        \n        this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY + 100,\n            'Assets Loaded!',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '20px',\n                color: GAME_CONSTANTS.COLORS.UI_SUCCESS,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        this.cleanupLoadingUI();\n\n        // Wait a moment before transitioning\n        this.time.delayedCall(500, () => {\n            console.log('PreloadScene: Transitioning to MenuScene');\n            this.game.events.emit(GameEvents.LOADING_COMPLETE);\n            this.sceneManager.setCurrentScene(SceneKeys.PRELOAD);\n            this.sceneManager.transitionTo(SceneKeys.MENU);\n            console.log('PreloadScene: MenuScene transition initiated');\n        });\n    }\n\n    public override update(time: number, _delta: number): void {\n        this.performanceMonitor.update(time);\n    }\n\n    private createLoadingUI(): void {\n        const centerX = this.cameras.main.centerX;\n        const centerY = this.cameras.main.centerY;\n\n        this.add.text(\n            centerX,\n            centerY - 100,\n            'Bubble Battle Royale',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '32px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        this.loadingText = this.add.text(\n            centerX,\n            centerY - 40,\n            'Loading...',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '20px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        const progressBarWidth = 320;\n        const progressBarHeight = 50;\n        const progressBarX = centerX - progressBarWidth / 2;\n        const progressBarY = centerY;\n\n        this.progressBox = this.add.graphics();\n        this.progressBox.fillStyle(0x222222, 0.8);\n        this.progressBox.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);\n\n        this.progressBar = this.add.graphics();\n\n        this.percentText = this.add.text(\n            centerX,\n            centerY + 25,\n            '0%',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '18px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        this.assetText = this.add.text(\n            centerX,\n            centerY + 70,\n            '',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '14px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center'\n            }\n        ).setOrigin(0.5);\n\n        this.createLoadingAnimation();\n    }\n\n    private createLoadingAnimation(): void {\n        const bubbleColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];\n        const bubbles: Phaser.GameObjects.Arc[] = [];\n        const centerX = this.cameras.main.centerX;\n        const centerY = this.cameras.main.centerY + 150;\n        const spacing = 40;\n\n        for (let i = 0; i < 5; i++) {\n            const bubble = this.add.circle(\n                centerX + (i - 2) * spacing,\n                centerY,\n                15,\n                bubbleColors[i],\n                1\n            );\n            bubbles.push(bubble);\n\n            this.tweens.add({\n                targets: bubble,\n                y: centerY - 20,\n                duration: 500,\n                ease: 'Sine.easeInOut',\n                yoyo: true,\n                repeat: -1,\n                delay: i * 100\n            });\n        }\n    }\n\n    private setupLoadingListeners(): void {\n        this.load.on('progress', (value: number) => {\n            this.updateProgress(value);\n        });\n\n        this.load.on('fileprogress', (file: Phaser.Loader.File) => {\n            this.assetText.setText(`Loading: ${file.key}`);\n        });\n\n        this.load.on('complete', () => {\n            console.log('Asset loading complete');\n            this.assetText.setText('Complete!');\n        });\n\n        this.load.on('loaderror', (file: Phaser.Loader.File) => {\n            console.error(`Failed to load: ${file.key}`);\n            this.assetText.setText(`Error loading: ${file.key}`);\n        });\n    }\n\n    private updateProgress(value: number): void {\n        const percent = Math.floor(value * 100);\n        this.percentText.setText(`${percent}%`);\n\n        this.progressBar.clear();\n        this.progressBar.fillStyle(0xffffff, 1);\n        \n        const progressBarWidth = 320;\n        const progressBarHeight = 50;\n        const centerX = this.cameras.main.centerX;\n        const centerY = this.cameras.main.centerY;\n        const progressBarX = centerX - progressBarWidth / 2;\n        const progressBarY = centerY;\n        \n        this.progressBar.fillRect(\n            progressBarX + 10,\n            progressBarY + 10,\n            (progressBarWidth - 20) * value,\n            progressBarHeight - 20\n        );\n\n        if (value >= 0.5) {\n            this.loadingText.setText('Loading Assets...');\n        }\n        if (value >= 0.8) {\n            this.loadingText.setText('Almost Ready...');\n        }\n    }\n\n    private createPlaceholderAssets(): void {\n        const graphics = this.make.graphics({ x: 0, y: 0 });\n        \n        graphics.fillStyle(0x3498db, 1);\n        graphics.fillCircle(32, 32, 32);\n        graphics.generateTexture(ASSET_KEYS.IMAGES.LOGO, 64, 64);\n        \n        graphics.clear();\n        graphics.fillStyle(0x2c3e50, 1);\n        graphics.fillRect(0, 0, this.cameras.main.width, this.cameras.main.height);\n        graphics.generateTexture(ASSET_KEYS.IMAGES.BACKGROUND, this.cameras.main.width, this.cameras.main.height);\n        \n        // Create particle texture\n        graphics.clear();\n        graphics.fillStyle(0xffffff, 1);\n        graphics.fillCircle(8, 8, 8);\n        graphics.generateTexture('particle', 16, 16);\n        \n        graphics.destroy();\n    }\n\n    private cleanupLoadingUI(): void {\n        if (this.progressBar) {\n            this.progressBar.destroy();\n        }\n        if (this.progressBox) {\n            this.progressBox.destroy();\n        }\n        if (this.percentText) {\n            this.percentText.destroy();\n        }\n        if (this.loadingText) {\n            this.loadingText.setText('Ready!');\n        }\n    }\n}","import { Scene } from 'phaser';\nimport { SceneKeys, ISceneData } from '@/types/GameTypes';\nimport { SceneManager } from '@systems/core/SceneManager';\nimport { GAME_CONSTANTS } from '@config/GameConfig';\nimport { ASSET_KEYS } from '@config/AssetManifest';\nimport { PerformanceMonitor } from '@utils/PerformanceMonitor';\n\nexport class MenuScene extends Scene {\n    private sceneManager!: SceneManager;\n    private performanceMonitor!: PerformanceMonitor;\n    private buttons: Phaser.GameObjects.Container[] = [];\n    private titleText!: Phaser.GameObjects.Text;\n    private versionText!: Phaser.GameObjects.Text;\n    private fpsText!: Phaser.GameObjects.Text;\n\n    constructor() {\n        super({ key: SceneKeys.MENU });\n    }\n\n    public init(_data: ISceneData): void {\n        console.log('MenuScene: Initializing main menu...');\n        this.sceneManager = SceneManager.getInstance();\n        this.sceneManager.setCurrentScene(SceneKeys.MENU);\n        this.performanceMonitor = new PerformanceMonitor();\n        if (this.game && this.game.events) {\n            this.performanceMonitor.setEventEmitter(this.game.events);\n        }\n    }\n\n    public create(): void {\n        // Debug: Check actual game FPS settings\n        console.log('MenuScene: create() called');\n        console.log('Game FPS Target:', this.game.config.fps);\n        console.log('Game Loop Type:', this.game.loop?.type);\n        console.log('Game Loop Target FPS:', this.game.loop?.targetFps);\n        console.log('Game Loop Actual FPS:', this.game.loop?.actualFps);\n        \n        this.createBackground();\n        this.createTitle();\n        this.createMenuButtons();\n        this.createVersionInfo();\n        this.createFPSDisplay();\n        this.addAnimations();\n    }\n\n    public override update(_time: number, _delta: number): void {\n        // Update FPS display once per second instead of every frame\n        // Check that time exists before accessing it\n        if (this.fpsText && this.time && this.time.now % 1000 < 16) {\n            const fps = Math.round(this.game.loop.actualFps);\n            this.fpsText.setText(`FPS: ${fps}`);\n            \n            // Simple color update\n            if (fps < 30) {\n                this.fpsText.setTint(0xff0000);\n            } else if (fps < 50) {\n                this.fpsText.setTint(0xffff00);\n            } else {\n                this.fpsText.setTint(0x00ff00);\n            }\n        }\n    }\n\n    private createBackground(): void {\n        const bg = this.add.image(0, 0, ASSET_KEYS.IMAGES.BACKGROUND);\n        bg.setOrigin(0, 0);\n        bg.setDisplaySize(this.cameras.main.width, this.cameras.main.height);\n        bg.setTint(0x1a1a2e);\n\n        for (let i = 0; i < 20; i++) {\n            const bubble = this.add.circle(\n                Phaser.Math.Between(0, this.cameras.main.width),\n                Phaser.Math.Between(0, this.cameras.main.height),\n                Phaser.Math.Between(10, 30),\n                Phaser.Math.Between(0x3498db, 0x9b59b6),\n                0.2\n            );\n\n            this.tweens.add({\n                targets: bubble,\n                y: bubble.y - Phaser.Math.Between(50, 150),\n                x: bubble.x + Phaser.Math.Between(-30, 30),\n                alpha: 0,\n                duration: Phaser.Math.Between(3000, 6000),\n                ease: 'Sine.easeOut',\n                repeat: -1,\n                delay: Phaser.Math.Between(0, 3000)\n            });\n        }\n    }\n\n    private createTitle(): void {\n        this.titleText = this.add.text(\n            this.cameras.main.centerX,\n            100,\n            'Bubble Battle\\nRoyale',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '42px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center',\n                stroke: '#000000',\n                strokeThickness: 4\n            }\n        ).setOrigin(0.5);\n\n        this.tweens.add({\n            targets: this.titleText,\n            scaleX: 1.05,\n            scaleY: 1.05,\n            duration: 2000,\n            ease: 'Sine.easeInOut',\n            yoyo: true,\n            repeat: -1\n        });\n    }\n\n    private createMenuButtons(): void {\n        const buttonData = [\n            { text: 'PLAY', action: () => this.startGame() },\n            { text: 'PRACTICE', action: () => this.startPractice() },\n            { text: 'SETTINGS', action: () => this.openSettings() },\n            { text: 'ABOUT', action: () => this.showAbout() }\n        ];\n\n        const startY = 250;\n        const spacing = 70;\n\n        buttonData.forEach((data, index) => {\n            const button = this.createButton(\n                this.cameras.main.centerX,\n                startY + (index * spacing),\n                data.text,\n                data.action\n            );\n            this.buttons.push(button);\n\n            button.setAlpha(0);\n            button.setScale(0.8);\n            \n            this.tweens.add({\n                targets: button,\n                alpha: 1,\n                scaleX: 1,\n                scaleY: 1,\n                duration: 500,\n                ease: 'Back.easeOut',\n                delay: 100 + (index * 100)\n            });\n        });\n    }\n\n    private createButton(x: number, y: number, text: string, callback: () => void): Phaser.GameObjects.Container {\n        const container = this.add.container(x, y);\n\n        const bg = this.add.rectangle(0, 0, 250, 50, 0x3498db, 1);\n        bg.setStrokeStyle(2, 0xffffff, 1);\n        bg.setInteractive({ useHandCursor: true });\n\n        const buttonText = this.add.text(0, 0, text, {\n            fontFamily: 'Arial, sans-serif',\n            fontSize: '20px',\n            color: GAME_CONSTANTS.COLORS.UI_TEXT,\n            align: 'center'\n        }).setOrigin(0.5);\n\n        container.add([bg, buttonText]);\n\n        bg.on('pointerover', () => {\n            bg.setFillStyle(0x5dade2);\n            this.tweens.add({\n                targets: container,\n                scaleX: 1.1,\n                scaleY: 1.1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n\n        bg.on('pointerout', () => {\n            bg.setFillStyle(0x3498db);\n            this.tweens.add({\n                targets: container,\n                scaleX: 1,\n                scaleY: 1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n\n        bg.on('pointerdown', () => {\n            container.setScale(0.95);\n        });\n\n        bg.on('pointerup', () => {\n            container.setScale(1);\n            callback();\n        });\n\n        return container;\n    }\n\n    private createVersionInfo(): void {\n        this.versionText = this.add.text(\n            10,\n            this.cameras.main.height - 30,\n            'v1.0.0 - Development Build',\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '12px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT\n            }\n        ).setOrigin(0, 0.5).setAlpha(0.5);\n    }\n\n    private createFPSDisplay(): void {\n        this.fpsText = this.add.text(\n            this.cameras.main.width - 10,\n            10,\n            'FPS: 60',\n            {\n                fontFamily: 'monospace',\n                fontSize: '14px',\n                color: '#00ff00'\n            }\n        ).setOrigin(1, 0);\n    }\n\n    private addAnimations(): void {\n        this.add.particles(0, 0, ASSET_KEYS.IMAGES.LOGO, {\n            x: { min: 0, max: this.cameras.main.width },\n            y: this.cameras.main.height + 50,\n            lifespan: 8000,\n            speedY: { min: -100, max: -50 },\n            scale: { start: 0.1, end: 0 },\n            quantity: 1,\n            frequency: 2000,\n            alpha: { start: 0.3, end: 0 },\n            tint: [0x3498db, 0x9b59b6, 0xe74c3c, 0xf39c12]\n        });\n    }\n\n    private startGame(): void {\n        console.log('Opening theme selection...');\n        this.tweens.add({\n            targets: this.buttons,\n            alpha: 0,\n            duration: 300,\n            onComplete: () => {\n                this.sceneManager.transitionTo(SceneKeys.THEME_SELECT);\n            }\n        });\n    }\n\n    private startPractice(): void {\n        console.log('Starting practice mode...');\n        this.showMessage('Practice Mode Coming Soon!');\n    }\n\n    private openSettings(): void {\n        console.log('Opening settings...');\n        this.showMessage('Settings Coming Soon!');\n    }\n\n    private showAbout(): void {\n        console.log('Showing about...');\n        this.showMessage('Bubble Battle Royale\\nBuilt with Phaser 3 & TypeScript\\n\\nA competitive bubble shooter game!');\n    }\n\n    private showMessage(text: string): void {\n        const overlay = this.add.rectangle(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            this.cameras.main.width,\n            this.cameras.main.height,\n            0x000000,\n            0.7\n        );\n\n        const messageBox = this.add.rectangle(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            400,\n            200,\n            0x2c3e50,\n            1\n        );\n        messageBox.setStrokeStyle(2, 0xffffff);\n\n        const messageText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY - 30,\n            text,\n            {\n                fontFamily: 'Arial, sans-serif',\n                fontSize: '18px',\n                color: GAME_CONSTANTS.COLORS.UI_TEXT,\n                align: 'center',\n                wordWrap: { width: 350 }\n            }\n        ).setOrigin(0.5);\n\n        const closeButton = this.createButton(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY + 60,\n            'CLOSE',\n            () => {\n                overlay.destroy();\n                messageBox.destroy();\n                messageText.destroy();\n                closeButton.destroy();\n            }\n        );\n\n        overlay.setInteractive();\n        overlay.on('pointerdown', () => {\n            overlay.destroy();\n            messageBox.destroy();\n            messageText.destroy();\n            closeButton.destroy();\n        });\n    }\n}","/**\n * BackgroundSystem - Premium Visual Background with Best UX/UI Practices\n * Features:\n * - Dynamic gradient backgrounds with smooth transitions\n * - Parallax layers for depth\n * - Ambient particle effects\n * - Performance optimized for mobile\n * - Non-intrusive design that enhances gameplay\n */\n\nimport { Scene } from 'phaser';\nimport { HD_SCALE } from '@/config/GameConfig';\n\ninterface IBackgroundConfig {\n    theme?: 'ocean' | 'sunset' | 'forest' | 'space' | 'aurora';\n    quality?: 'low' | 'medium' | 'high' | 'ultra';\n    enableParticles?: boolean;\n    enableAnimation?: boolean;\n}\n\nexport class BackgroundSystem {\n    private scene: Scene;\n    private config: IBackgroundConfig;\n    \n    // Gradient layers\n    private gradientGraphics!: Phaser.GameObjects.Graphics;\n    private gradientTexture?: Phaser.Textures.CanvasTexture;\n    \n    // Parallax elements\n    private parallaxLayers: Phaser.GameObjects.Container[] = [];\n    \n    // Particle effects\n    private particleEmitters: Phaser.GameObjects.Particles.ParticleEmitter[] = [];\n    \n    // Ambient elements\n    private ambientElements: Phaser.GameObjects.GameObject[] = [];\n    \n    // Animation timers\n    private animationTimers: Phaser.Time.TimerEvent[] = [];\n    \n    // Color schemes for different themes with unique particle types\n    private readonly themes = {\n        ocean: {\n            colors: [0x001a33, 0x003366, 0x004d99, 0x0066cc],\n            accent: 0x00ccff,\n            particles: 0x66ddff,\n            name: 'Ocean Depths',\n            particleType: 'bubbles' as const,\n            secondaryParticles: 0x99eeff\n        },\n        sunset: {\n            colors: [0x1a0033, 0x330066, 0x660099, 0x9900cc],\n            accent: 0xff6600,\n            particles: 0xffaa00,\n            name: 'Twilight',\n            particleType: 'fireflies' as const,\n            secondaryParticles: 0xffcc66\n        },\n        forest: {\n            colors: [0x001a00, 0x003300, 0x004d00, 0x006600],\n            accent: 0x00ff00,\n            particles: 0x44aa44, // More visible green\n            name: 'Mystic Forest',\n            particleType: 'leaves' as const,\n            secondaryParticles: 0x66dd66 // Brighter leaves\n        },\n        space: {\n            colors: [0x000011, 0x000022, 0x000033, 0x000044],\n            accent: 0x9966ff,\n            particles: 0xffffff,\n            name: 'Deep Space',\n            particleType: 'stars' as const,\n            secondaryParticles: 0xaabbff\n        },\n        aurora: {\n            colors: [0x001122, 0x002244, 0x003366, 0x004488],\n            accent: 0x00ff99,\n            particles: 0x00ffaa, // Bright aurora green\n            name: 'Northern Lights',\n            particleType: 'aurora' as const,\n            secondaryParticles: 0xaaffff // Bright cyan\n        }\n    };\n    \n    private currentTheme: typeof this.themes.ocean;\n    private width: number;\n    private height: number;\n\n    constructor(scene: Scene, config: IBackgroundConfig = {}) {\n        this.scene = scene;\n        this.config = {\n            theme: config.theme || 'ocean',\n            quality: config.quality || 'high',\n            enableParticles: config.enableParticles !== false,\n            enableAnimation: config.enableAnimation !== false\n        };\n        \n        this.currentTheme = this.themes[this.config.theme!];\n        this.width = scene.cameras.main.width;\n        this.height = scene.cameras.main.height;\n        \n        this.create();\n    }\n\n    private create(): void {\n        // Create gradient background\n        this.createGradientBackground();\n        \n        // Add parallax layers based on quality\n        if (this.config.quality !== 'low') {\n            this.createParallaxLayers();\n        }\n        \n        // Add ambient particles\n        if (this.config.enableParticles && this.config.quality !== 'low') {\n            this.createAmbientParticles();\n        }\n        \n        // Add animated elements for high quality, or always for space theme\n        if ((this.config.quality === 'high' || this.config.quality === 'ultra') || \n            this.currentTheme.particleType === 'stars') {\n            this.createAnimatedElements();\n        }\n        \n        // Start animations if enabled\n        if (this.config.enableAnimation) {\n            this.startAnimations();\n        }\n    }\n\n    private createGradientBackground(): void {\n        this.gradientGraphics = this.scene.add.graphics();\n        \n        // Create smooth vertical gradient\n        const colors = this.currentTheme.colors;\n        const gradientHeight = this.height / (colors.length - 1);\n        \n        for (let i = 0; i < colors.length - 1; i++) {\n            const color1 = colors[i];\n            const color2 = colors[i + 1];\n            \n            // Create gradient between two colors\n            for (let y = 0; y < gradientHeight; y++) {\n                const ratio = y / gradientHeight;\n                const blendedColor = this.blendColors(color1, color2, ratio);\n                \n                this.gradientGraphics.fillStyle(blendedColor, 1);\n                this.gradientGraphics.fillRect(\n                    0,\n                    i * gradientHeight + y,\n                    this.width,\n                    1\n                );\n            }\n        }\n        \n        // Add subtle noise texture for depth (ultra quality)\n        if (this.config.quality === 'ultra') {\n            this.addNoiseTexture();\n        }\n        \n        // Set as background (behind everything)\n        this.gradientGraphics.setDepth(-1000);\n    }\n\n    private createParallaxLayers(): void {\n        // Create theme-specific background elements instead of geometric shapes\n        const layerCount = this.config.quality === 'ultra' ? 3 : 2;\n        \n        for (let i = 0; i < layerCount; i++) {\n            const layer = this.scene.add.container(0, 0);\n            layer.setDepth(-900 + i * 10);\n            \n            // Add theme-specific elements\n            const elementCount = this.config.quality === 'ultra' ? 6 : 3;\n            for (let j = 0; j < elementCount; j++) {\n                const element = this.createThemeElement(i);\n                if (element) {\n                    element.x = Phaser.Math.Between(0, this.width);\n                    element.y = Phaser.Math.Between(0, this.height);\n                    layer.add(element);\n                }\n            }\n            \n            this.parallaxLayers.push(layer);\n        }\n    }\n\n    private createThemeElement(layerIndex: number): Phaser.GameObjects.GameObject | null {\n        const alpha = 0.02 + layerIndex * 0.015; // Very subtle\n        const scale = 0.5 + layerIndex * 0.3;\n        \n        switch (this.currentTheme.particleType) {\n            case 'bubbles':\n                // Ocean theme - create subtle water bubbles\n                const bubble = this.scene.add.circle(\n                    0, 0,\n                    Phaser.Math.Between(20, 40) * HD_SCALE * scale,\n                    this.currentTheme.secondaryParticles,\n                    alpha\n                );\n                bubble.setStrokeStyle(1, this.currentTheme.particles, alpha * 2);\n                return bubble;\n                \n            case 'fireflies':\n                // Sunset theme - create glowing orbs\n                const firefly = this.scene.add.circle(\n                    0, 0,\n                    Phaser.Math.Between(3, 8) * HD_SCALE * scale,\n                    this.currentTheme.particles,\n                    alpha * 3\n                );\n                // Add glow effect\n                this.scene.tweens.add({\n                    targets: firefly,\n                    alpha: { from: alpha * 2, to: alpha * 4 },\n                    duration: Phaser.Math.Between(2000, 4000),\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                return firefly;\n                \n            case 'leaves':\n                // Forest theme - simple ellipse leaves that actually work\n                const bgLeaf = this.scene.add.ellipse(\n                    0, 0,\n                    18 * HD_SCALE * scale,\n                    25 * HD_SCALE * scale,\n                    Phaser.Math.RND.pick([0x5ca05c, 0x6cae6c, 0x4c904c]), // Natural greens\n                    0.12 // Subtle background opacity\n                );\n                bgLeaf.setAngle(Phaser.Math.Between(0, 360));\n                // Gentle rotation\n                this.scene.tweens.add({\n                    targets: bgLeaf,\n                    angle: `+=${Phaser.Math.Between(-30, 30)}`,\n                    duration: Phaser.Math.Between(8000, 12000),\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                return bgLeaf;\n                \n            case 'stars':\n                // Space theme - no geometric shapes, let the planets be the focus\n                return null;\n                \n            case 'aurora':\n                // Aurora theme - ethereal light pillars\n                const pillar = this.scene.add.rectangle(\n                    0, 0,\n                    Phaser.Math.Between(80, 120) * HD_SCALE * scale,\n                    500 * HD_SCALE * scale,\n                    Phaser.Math.RND.pick([0x00ffcc, 0x99ffee, 0xccffff]),\n                    0.06 + layerIndex * 0.02 // Layer depth\n                );\n                pillar.setBlendMode(Phaser.BlendModes.ADD);\n                pillar.setAngle(Phaser.Math.Between(-15, 15));\n                // Ethereal shimmering\n                this.scene.tweens.add({\n                    targets: pillar,\n                    alpha: { from: 0.04, to: 0.08 },\n                    scaleX: { from: 0.8, to: 1.2 },\n                    angle: pillar.angle + Phaser.Math.Between(-5, 5),\n                    duration: Phaser.Math.Between(12000, 18000),\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                return pillar;\n                \n            default:\n                return null;\n        }\n    }\n\n    private drawLeaf(graphics: Phaser.GameObjects.Graphics, x: number, y: number, size: number): void {\n        // Draw a simple diamond/leaf shape using fillPoints\n        const points = [\n            x, y - size * 1.5,     // Top\n            x - size * 0.7, y,     // Left\n            x, y + size * 1.5,     // Bottom\n            x + size * 0.7, y      // Right\n        ];\n        graphics.fillPoints(points, true);\n    }\n\n    private createAmbientParticles(): void {\n        // Significantly reduced particles for better FPS\n        let particleCount = this.config.quality === 'ultra' ? 8 : 4;\n        let delay = 500; // Slower creation\n        \n        // Minimal particles for all themes\n        if (this.currentTheme.particleType === 'stars') {\n            particleCount = this.config.quality === 'ultra' ? 12 : 6; // Just a few stars\n            delay = 300;\n        }\n        \n        for (let i = 0; i < particleCount; i++) {\n            this.scene.time.delayedCall(i * delay, () => {\n                this.createThemeParticle();\n            });\n        }\n        \n        // Secondary effects disabled for performance\n        // if (this.config.quality === 'ultra') {\n        //     this.createSecondaryEffect();\n        // }\n    }\n\n    private createThemeParticle(): void {\n        let particle: Phaser.GameObjects.GameObject;\n        const startX = Phaser.Math.Between(0, this.width);\n        const startY = this.currentTheme.particleType === 'leaves' ? -20 : this.height + 20;\n        \n        switch (this.currentTheme.particleType) {\n            case 'bubbles':\n                // Ocean bubbles rising up\n                particle = this.scene.add.circle(\n                    startX,\n                    this.height + 20,\n                    Phaser.Math.Between(3, 8) * HD_SCALE,\n                    this.currentTheme.particles,\n                    Phaser.Math.FloatBetween(0.1, 0.2)\n                );\n                // Add shimmer effect\n                (particle as Phaser.GameObjects.Arc).setStrokeStyle(\n                    1,\n                    this.currentTheme.secondaryParticles,\n                    0.3\n                );\n                // Float up with wobble\n                this.scene.tweens.add({\n                    targets: particle,\n                    y: -20,\n                    x: startX + Math.sin(Date.now() * 0.001) * 30,\n                    duration: Phaser.Math.Between(12000, 18000),\n                    ease: 'Linear',\n                    onComplete: () => this.recycleParticle(particle)\n                });\n                // Wobble horizontally\n                this.scene.tweens.add({\n                    targets: particle,\n                    x: `+=${Phaser.Math.Between(-30, 30)}`,\n                    duration: 2000,\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                break;\n                \n            case 'fireflies':\n                // Glowing fireflies with erratic movement\n                particle = this.scene.add.circle(\n                    startX,\n                    Phaser.Math.Between(this.height * 0.3, this.height * 0.7),\n                    Phaser.Math.Between(2, 4) * HD_SCALE,\n                    this.currentTheme.particles,\n                    0.8\n                );\n                // Glow pulsing\n                this.scene.tweens.add({\n                    targets: particle,\n                    scale: { from: 0.8, to: 1.3 },\n                    alpha: { from: 0.4, to: 1 },\n                    duration: Phaser.Math.Between(1000, 2000),\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                // Erratic floating movement\n                this.createFireflyPath(particle);\n                // Auto-recycle after some time\n                this.scene.time.delayedCall(Phaser.Math.Between(15000, 20000), () => {\n                    this.recycleParticle(particle);\n                });\n                break;\n                \n            case 'leaves':\n                // Falling leaves - using simple shapes that work\n                const leafSize = Phaser.Math.Between(10, 18) * HD_SCALE;\n                particle = this.scene.add.ellipse(\n                    startX,\n                    startY,\n                    leafSize * 0.8,\n                    leafSize * 1.3,\n                    Phaser.Math.RND.pick([0x5ca05c, 0x7cb87c, 0x4c904c, 0x6cae6c]), // Various green tones\n                    0.6\n                );\n                (particle as Phaser.GameObjects.Ellipse).setStrokeStyle(1, 0x3a7a3a, 0.8);\n                (particle as Phaser.GameObjects.Ellipse).setAngle(Phaser.Math.Between(0, 360));\n                // Fall with realistic leaf motion\n                const fallDuration = Phaser.Math.Between(10000, 15000);\n                this.scene.tweens.add({\n                    targets: particle,\n                    y: this.height + 20,\n                    angle: `+=${Phaser.Math.Between(90, 270)}`,\n                    duration: fallDuration,\n                    ease: 'Linear',\n                    onComplete: () => this.recycleParticle(particle)\n                });\n                // Gentle sway side to side\n                this.scene.tweens.add({\n                    targets: particle,\n                    x: `+=${Phaser.Math.Between(-60, 60)}`,\n                    duration: 2500,\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                // Subtle scale pulsing for depth\n                this.scene.tweens.add({\n                    targets: particle,\n                    scaleX: { from: 1, to: 0.85 },\n                    scaleY: { from: 1, to: 1.1 },\n                    duration: 3000,\n                    yoyo: true,\n                    repeat: -1,\n                    ease: 'Sine.easeInOut'\n                });\n                break;\n                \n            case 'stars':\n                // Deep space - realistic stars\n                const starSize = Phaser.Math.FloatBetween(0.5, 2) * HD_SCALE;\n                particle = this.scene.add.circle(\n                    Phaser.Math.Between(0, this.width),\n                    Phaser.Math.Between(0, this.height),\n                    starSize,\n                    0xffffff,\n                    Phaser.Math.FloatBetween(0.5, 0.9) // Start visible\n                );\n                \n                // Some stars just stay static, others twinkle\n                if (Phaser.Math.Between(0, 10) > 7) {\n                    // 30% twinkle\n                    this.scene.tweens.add({\n                        targets: particle,\n                        alpha: { from: particle.alpha, to: particle.alpha * 0.3 },\n                        duration: Phaser.Math.Between(2000, 4000),\n                        yoyo: true,\n                        repeat: Phaser.Math.Between(1, 3),\n                        ease: 'Sine.easeInOut',\n                        onComplete: () => {\n                            // Fade out and recycle\n                            this.scene.tweens.add({\n                                targets: particle,\n                                alpha: 0,\n                                duration: 1000,\n                                onComplete: () => this.recycleParticle(particle)\n                            });\n                        }\n                    });\n                } else {\n                    // 70% stay static for a while then fade\n                    this.scene.time.delayedCall(Phaser.Math.Between(10000, 20000), () => {\n                        if (particle && particle.active) {\n                            this.scene.tweens.add({\n                                targets: particle,\n                                alpha: 0,\n                                duration: 2000,\n                                onComplete: () => this.recycleParticle(particle)\n                            });\n                        }\n                    });\n                }\n                break;\n                \n            case 'aurora':\n                // Beautiful flowing aurora curtains\n                const curtainX = Phaser.Math.Between(50, this.width - 50);\n                const curtainWidth = Phaser.Math.Between(100, 180) * HD_SCALE;\n                const curtainColor = Phaser.Math.RND.pick([\n                    0x00ffaa, // Green aurora\n                    0x00ddff, // Cyan aurora  \n                    0x99ffdd, // Mint aurora\n                    0xffaaff, // Pink aurora\n                    0xaaccff  // Blue aurora\n                ]);\n                \n                // Create tall vertical curtain\n                particle = this.scene.add.rectangle(\n                    curtainX,\n                    this.height / 2,\n                    curtainWidth,\n                    this.height * 1.5,\n                    curtainColor,\n                    0.12 // Visible but subtle\n                );\n                \n                // Set blend mode for glow effect\n                (particle as Phaser.GameObjects.Rectangle).setBlendMode(Phaser.BlendModes.ADD);\n                \n                // Slight initial angle for natural look\n                particle.setAngle(Phaser.Math.Between(-10, 10));\n                \n                // Beautiful flowing animation\n                this.scene.tweens.add({\n                    targets: particle,\n                    // Opacity pulse\n                    alpha: { \n                        from: 0.08, \n                        to: 0.18\n                    },\n                    // Width breathing\n                    scaleX: { \n                        from: 0.7, \n                        to: 1.2\n                    },\n                    // Gentle sway\n                    x: curtainX + Phaser.Math.Between(-40, 40),\n                    // Subtle rotation\n                    angle: particle.angle + Phaser.Math.Between(-5, 5),\n                    duration: Phaser.Math.Between(10000, 15000),\n                    yoyo: true,\n                    ease: 'Sine.easeInOut',\n                    onComplete: () => this.recycleParticle(particle)\n                });\n                \n                // Add shimmer effect - color shift\n                let colorPhase = 0;\n                const shimmerTimer = this.scene.time.addEvent({\n                    delay: 3000,\n                    callback: () => {\n                        if (particle && particle.active) {\n                            const colors = [curtainColor, 0x00ffcc, 0xaaffff];\n                            colorPhase = (colorPhase + 1) % colors.length;\n                            this.scene.tweens.add({\n                                targets: particle,\n                                duration: 2000,\n                                onUpdate: (tween) => {\n                                    const progress = tween.progress;\n                                    const fromColor = colors[colorPhase];\n                                    const toColor = colors[(colorPhase + 1) % colors.length];\n                                    const blended = Phaser.Display.Color.Interpolate.ColorWithColor(\n                                        Phaser.Display.Color.IntegerToColor(fromColor),\n                                        Phaser.Display.Color.IntegerToColor(toColor),\n                                        1,\n                                        progress\n                                    );\n                                    (particle as Phaser.GameObjects.Rectangle).setFillStyle(\n                                        Phaser.Display.Color.GetColor(blended.r, blended.g, blended.b),\n                                        particle.alpha\n                                    );\n                                }\n                            });\n                        } else {\n                            shimmerTimer.destroy();\n                        }\n                    },\n                    loop: true\n                });\n                break;\n                \n            default:\n                return;\n        }\n        \n        particle.setDepth(-850);\n        this.ambientElements.push(particle);\n    }\n    \n    private createFireflyPath(firefly: Phaser.GameObjects.GameObject): void {\n        // Create random floating movement for firefly\n        const moveFirefly = () => {\n            const newX = firefly.x + Phaser.Math.Between(-100, 100);\n            const newY = firefly.y + Phaser.Math.Between(-50, 50);\n            \n            // Keep within screen bounds\n            const boundedX = Phaser.Math.Clamp(newX, 50, this.width - 50);\n            const boundedY = Phaser.Math.Clamp(newY, this.height * 0.2, this.height * 0.8);\n            \n            this.scene.tweens.add({\n                targets: firefly,\n                x: boundedX,\n                y: boundedY,\n                duration: Phaser.Math.Between(2000, 3000),\n                ease: 'Sine.easeInOut',\n                onComplete: () => {\n                    // Continue moving if firefly still exists\n                    if (firefly && firefly.active) {\n                        moveFirefly();\n                    }\n                }\n            });\n        };\n        \n        // Start the movement\n        moveFirefly();\n    }\n    \n    private recycleParticle(particle: Phaser.GameObjects.GameObject): void {\n        particle.destroy();\n        this.ambientElements = this.ambientElements.filter(e => e !== particle);\n        // Create a new particle to maintain the effect\n        this.createThemeParticle();\n    }\n\n    private createSecondaryEffect(): void {\n        const sparkleTimer = this.scene.time.addEvent({\n            delay: 500,\n            callback: () => {\n                // Create secondary effects based on theme\n                switch (this.currentTheme.particleType) {\n                    case 'bubbles':\n                        // Small bubble clusters\n                        const clusterX = Phaser.Math.Between(0, this.width);\n                        for (let i = 0; i < 3; i++) {\n                            const smallBubble = this.scene.add.circle(\n                                clusterX + Phaser.Math.Between(-20, 20),\n                                this.height + 10,\n                                Phaser.Math.Between(1, 3) * HD_SCALE,\n                                this.currentTheme.secondaryParticles,\n                                0.2\n                            );\n                            smallBubble.setDepth(-840);\n                            this.ambientElements.push(smallBubble);\n                            this.scene.tweens.add({\n                                targets: smallBubble,\n                                y: -10,\n                                duration: Phaser.Math.Between(8000, 10000),\n                                delay: i * 100,\n                                ease: 'Linear',\n                                onComplete: () => {\n                                    smallBubble.destroy();\n                                    this.ambientElements = this.ambientElements.filter(e => e !== smallBubble);\n                                }\n                            });\n                        }\n                        break;\n                        \n                    case 'fireflies':\n                        // Spark trails\n                        const spark = this.scene.add.circle(\n                            Phaser.Math.Between(0, this.width),\n                            Phaser.Math.Between(this.height * 0.2, this.height * 0.8),\n                            1 * HD_SCALE,\n                            this.currentTheme.secondaryParticles,\n                            1\n                        );\n                        spark.setDepth(-840);\n                        this.ambientElements.push(spark);\n                        this.scene.tweens.add({\n                            targets: spark,\n                            alpha: { from: 1, to: 0 },\n                            scale: { from: 1, to: 0 },\n                            duration: 1000,\n                            ease: 'Power2',\n                            onComplete: () => {\n                                spark.destroy();\n                                this.ambientElements = this.ambientElements.filter(e => e !== spark);\n                            }\n                        });\n                        break;\n                        \n                    case 'stars':\n                        // Minimal space dust - very subtle\n                        const dust = this.scene.add.circle(\n                            Phaser.Math.Between(0, this.width),\n                            Phaser.Math.Between(0, this.height),\n                            0.5 * HD_SCALE, // Tiny\n                            0xccddff,\n                            Phaser.Math.FloatBetween(0.3, 0.5)\n                        );\n                        dust.setDepth(-840);\n                        this.ambientElements.push(dust);\n                        \n                        // Very slow drift\n                        this.scene.tweens.add({\n                            targets: dust,\n                            x: dust.x + Phaser.Math.Between(-10, 10),\n                            y: dust.y + Phaser.Math.Between(-10, 10),\n                            alpha: 0,\n                            duration: Phaser.Math.Between(5000, 8000),\n                            ease: 'Linear',\n                            onComplete: () => {\n                                dust.destroy();\n                                this.ambientElements = this.ambientElements.filter(e => e !== dust);\n                            }\n                        });\n                        break;\n                        \n                    default:\n                        // Generic sparkle for other themes\n                        const sparkle = this.scene.add.star(\n                            Phaser.Math.Between(0, this.width),\n                            Phaser.Math.Between(0, this.height),\n                            4, 2 * HD_SCALE, 4 * HD_SCALE,\n                            this.currentTheme.particles\n                        );\n                        sparkle.setAlpha(0);\n                        sparkle.setDepth(-840);\n                        this.ambientElements.push(sparkle);\n                        this.scene.tweens.add({\n                            targets: sparkle,\n                            alpha: { from: 0, to: 0.3, yoyo: true },\n                            scale: { from: 0, to: 1, yoyo: true },\n                            angle: 180,\n                            duration: 1500,\n                            ease: 'Cubic.easeOut',\n                            onComplete: () => {\n                                sparkle.destroy();\n                                this.ambientElements = this.ambientElements.filter(e => e !== sparkle);\n                            }\n                        });\n                        break;\n                }\n            },\n            loop: true\n        });\n        \n        this.animationTimers.push(sparkleTimer);\n    }\n\n    private createAnimatedElements(): void {\n        // Add special elements for specific themes\n        if (this.currentTheme.particleType === 'stars') {\n            // Always add planet and shooting stars for space theme\n            console.log('Space theme detected, creating planet and shooting stars');\n            this.createBackgroundPlanet();\n            this.createShootingStarTimer();\n        }\n    }\n    \n    private createBackgroundPlanet(): void {\n        // Single Earth planet - optimized for performance\n        \n        if (this.scene.textures.exists('planet')) {\n            const earthX = this.width * 0.82; // Top-right position\n            const earthY = this.height * 0.18;\n            const earthScale = 0.12; // No HD_SCALE needed, image has high resolution\n            \n            const earth = this.scene.add.image(earthX, earthY, 'planet');\n            earth.setScale(earthScale);\n            earth.setAlpha(0.10); // Very subtle\n            earth.setDepth(-998); // Far back\n            \n            // Subtle floating motion (no rotation for performance)\n            this.scene.tweens.add({\n                targets: earth,\n                y: earthY + (8 * HD_SCALE), // Small movement\n                duration: 45000, // Slow floating\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut'\n            });\n            \n            this.ambientElements.push(earth);\n            console.log('Earth planet loaded in background');\n        }\n    }\n    \n    private createFloatingBubblesBetweenPlanets(): void {\n        // Removed for performance - no floating bubbles between planets\n    }\n    \n    private createShootingStarTimer(): void {\n        // First shooting star after 5 seconds\n        this.scene.time.delayedCall(5000, () => {\n            this.createShootingStar();\n            console.log('Creating first shooting star');\n        });\n        \n        // Create recurring shooting stars\n        const createNextStar = () => {\n            const delay = Phaser.Math.Between(12000, 25000); // Random delay\n            this.scene.time.delayedCall(delay, () => {\n                if (this.scene && this.scene.scene.isActive()) {\n                    this.createShootingStar();\n                    console.log('Creating shooting star');\n                    createNextStar(); // Schedule next one\n                }\n            });\n        };\n        \n        createNextStar();\n    }\n    \n    private createShootingStar(): void {\n        // Create a realistic shooting star with gradient trail\n        const startX = Phaser.Math.Between(0, this.width * 0.6);\n        const startY = Phaser.Math.Between(0, this.height * 0.4);\n        \n        // Create shooting star container\n        const shootingContainer = this.scene.add.container(startX, startY);\n        \n        // Create gradient trail using multiple segments\n        const trailLength = 8;\n        for (let i = trailLength; i > 0; i--) {\n            const segment = this.scene.add.circle(\n                -i * 8, 0,\n                (trailLength - i) * 0.3 + 0.5, // Taper from thin to thick\n                0xffffff,\n                (1 - i / trailLength) * 0.5 // Fade from transparent to bright\n            );\n            segment.setBlendMode(Phaser.BlendModes.ADD);\n            shootingContainer.add(segment);\n        }\n        \n        // Bright head\n        const head = this.scene.add.circle(0, 0, 1.5 * HD_SCALE, 0xffffff, 1);\n        head.setBlendMode(Phaser.BlendModes.ADD);\n        shootingContainer.add(head);\n        \n        shootingContainer.add(head);\n        shootingContainer.setDepth(-800); // Behind most things\n        shootingContainer.setAngle(35); // Natural angle\n        this.ambientElements.push(shootingContainer);\n        \n        // Quick, subtle animation\n        const endX = startX + Phaser.Math.Between(300, 450);\n        const endY = startY + Phaser.Math.Between(150, 250);\n        \n        this.scene.tweens.add({\n            targets: shootingContainer,\n            x: endX,\n            y: endY,\n            duration: 600,\n            ease: 'Power2.easeIn',\n            onUpdate: (tween) => {\n                // Fade out naturally\n                const progress = tween.progress;\n                shootingContainer.alpha = 1 - progress * 0.7;\n            },\n            onComplete: () => {\n                shootingContainer.destroy();\n                this.ambientElements = this.ambientElements.filter(e => e !== shootingContainer);\n            }\n        });\n    }\n\n    private startAnimations(): void {\n        // Parallax movement on scene update\n        if (this.parallaxLayers.length > 0) {\n            const updateEvent = this.scene.time.addEvent({\n                delay: 50,\n                callback: this.updateParallax.bind(this),\n                loop: true\n            });\n            this.animationTimers.push(updateEvent);\n        }\n        \n        // Gradient color shifting for ultra quality\n        if (this.config.quality === 'ultra') {\n            this.startGradientAnimation();\n        }\n    }\n\n    private updateParallax(): void {\n        this.parallaxLayers.forEach((layer, index) => {\n            const speed = (index + 1) * 0.1;\n            layer.x -= speed;\n            \n            // Wrap around\n            if (layer.x < -100) {\n                layer.x = 0;\n            }\n        });\n    }\n\n    private startGradientAnimation(): void {\n        // Subtle color shift over time\n        let hueShift = 0;\n        \n        const gradientTimer = this.scene.time.addEvent({\n            delay: 100,\n            callback: () => {\n                hueShift += 0.5;\n                if (hueShift > 360) hueShift = 0;\n                \n                // Apply subtle hue shift to accent elements\n                this.ambientElements.forEach(element => {\n                    if ('setTint' in element) {\n                        const shifted = this.shiftHue(this.currentTheme.accent, hueShift);\n                        (element as any).setTint(shifted);\n                    }\n                });\n            },\n            loop: true\n        });\n        \n        this.animationTimers.push(gradientTimer);\n    }\n\n    private addNoiseTexture(): void {\n        // Add subtle noise for texture\n        const noiseGraphics = this.scene.add.graphics();\n        noiseGraphics.setAlpha(0.02); // Very subtle\n        \n        for (let i = 0; i < 1000; i++) {\n            const x = Phaser.Math.Between(0, this.width);\n            const y = Phaser.Math.Between(0, this.height);\n            const alpha = Phaser.Math.FloatBetween(0.1, 0.3);\n            \n            noiseGraphics.fillStyle(0xffffff, alpha);\n            noiseGraphics.fillRect(x, y, 1, 1);\n        }\n        \n        noiseGraphics.setDepth(-999);\n    }\n\n    private blendColors(color1: number, color2: number, ratio: number): number {\n        const r1 = (color1 >> 16) & 0xff;\n        const g1 = (color1 >> 8) & 0xff;\n        const b1 = color1 & 0xff;\n        \n        const r2 = (color2 >> 16) & 0xff;\n        const g2 = (color2 >> 8) & 0xff;\n        const b2 = color2 & 0xff;\n        \n        const r = Math.floor(r1 + (r2 - r1) * ratio);\n        const g = Math.floor(g1 + (g2 - g1) * ratio);\n        const b = Math.floor(b1 + (b2 - b1) * ratio);\n        \n        return (r << 16) | (g << 8) | b;\n    }\n\n    private shiftHue(color: number, degrees: number): number {\n        // Convert to HSL, shift hue, convert back\n        const r = ((color >> 16) & 0xff) / 255;\n        const g = ((color >> 8) & 0xff) / 255;\n        const b = (color & 0xff) / 255;\n        \n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        const l = (max + min) / 2;\n        \n        if (max === min) {\n            return color; // Gray, no hue to shift\n        }\n        \n        const d = max - min;\n        const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        \n        let h;\n        if (max === r) {\n            h = ((g - b) / d + (g < b ? 6 : 0)) / 6;\n        } else if (max === g) {\n            h = ((b - r) / d + 2) / 6;\n        } else {\n            h = ((r - g) / d + 4) / 6;\n        }\n        \n        h = (h + degrees / 360) % 1;\n        \n        // Convert back to RGB\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1/6) return p + (q - p) * 6 * t;\n            if (t < 1/2) return q;\n            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n            return p;\n        };\n        \n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        \n        const newR = Math.floor(hue2rgb(p, q, h + 1/3) * 255);\n        const newG = Math.floor(hue2rgb(p, q, h) * 255);\n        const newB = Math.floor(hue2rgb(p, q, h - 1/3) * 255);\n        \n        return (newR << 16) | (newG << 8) | newB;\n    }\n\n    public setTheme(theme: 'ocean' | 'sunset' | 'forest' | 'space' | 'aurora'): void {\n        this.config.theme = theme;\n        this.currentTheme = this.themes[theme];\n        \n        // Recreate background with new theme\n        this.destroy();\n        this.create();\n    }\n\n    public setQuality(quality: 'low' | 'medium' | 'high' | 'ultra'): void {\n        this.config.quality = quality;\n        \n        // Recreate with new quality settings\n        this.destroy();\n        this.create();\n    }\n\n    public destroy(): void {\n        // Clean up graphics\n        this.gradientGraphics?.destroy();\n        \n        // Clean up parallax layers\n        this.parallaxLayers.forEach(layer => layer.destroy());\n        this.parallaxLayers = [];\n        \n        // Clean up particles\n        this.particleEmitters.forEach(emitter => emitter.destroy());\n        this.particleEmitters = [];\n        \n        // Clean up ambient elements\n        this.ambientElements.forEach(element => element.destroy());\n        this.ambientElements = [];\n        \n        // Clean up timers\n        this.animationTimers.forEach(timer => timer.destroy());\n        this.animationTimers = [];\n    }\n}","/**\n * ThemeSelectScene - Beautiful theme selection screen\n * Allows players to choose their preferred visual theme before starting the game\n */\n\nimport { Scene } from 'phaser';\nimport { SceneKeys } from '@/types/GameTypes';\nimport { BackgroundSystem } from '@/systems/visual/BackgroundSystem';\nimport { HD_SCALE } from '@/config/GameConfig';\n\nexport type ThemeType = 'ocean' | 'sunset' | 'forest' | 'space' | 'aurora';\n\ninterface ThemeOption {\n    key: ThemeType;\n    name: string;\n    description: string;\n    colors: number[];\n    icon: string;\n}\n\nexport class ThemeSelectScene extends Scene {\n    private backgroundSystem!: BackgroundSystem;\n    private selectedTheme: ThemeType = 'ocean';\n    private themeContainers: Phaser.GameObjects.Container[] = [];\n    private titleText!: Phaser.GameObjects.Text;\n    private confirmButton!: Phaser.GameObjects.Container;\n    private previewBackground!: BackgroundSystem;\n    \n    private themes: ThemeOption[] = [\n        {\n            key: 'ocean',\n            name: 'Ocean Depths',\n            description: 'Dive into deep blue waters',\n            colors: [0x001a33, 0x003366, 0x004d99, 0x0066cc],\n            icon: '🌊'\n        },\n        {\n            key: 'sunset',\n            name: 'Twilight Dream',\n            description: 'Purple and orange sunset vibes',\n            colors: [0x1a0033, 0x330066, 0x660099, 0xff6600],\n            icon: '🌅'\n        },\n        {\n            key: 'forest',\n            name: 'Mystic Forest',\n            description: 'Natural green serenity',\n            colors: [0x001a00, 0x003300, 0x004d00, 0x006600],\n            icon: '🌲'\n        },\n        {\n            key: 'space',\n            name: 'Deep Space',\n            description: 'Journey through the cosmos',\n            colors: [0x000011, 0x000022, 0x000033, 0x9966ff],\n            icon: '🚀'\n        },\n        {\n            key: 'aurora',\n            name: 'Northern Lights',\n            description: 'Magical aurora borealis',\n            colors: [0x001122, 0x002244, 0x003366, 0x00ff99],\n            icon: '🌌'\n        }\n    ];\n\n    constructor() {\n        super({ key: SceneKeys.THEME_SELECT });\n    }\n\n    create(): void {\n        const { width, height } = this.cameras.main;\n        \n        // Create preview background (starts with ocean)\n        this.previewBackground = new BackgroundSystem(this, {\n            theme: 'ocean',\n            quality: 'high',\n            enableParticles: true,\n            enableAnimation: true\n        });\n        \n        // Add dark overlay for better text visibility\n        const overlay = this.add.graphics();\n        overlay.fillStyle(0x000000, 0.3);\n        overlay.fillRect(0, 0, width, height);\n        overlay.setDepth(100);\n        \n        // Title - optimized for mobile\n        this.titleText = this.add.text(width / 2, 40 * HD_SCALE, 'Choose Your Theme', {\n            fontSize: `${24 * HD_SCALE}px`,\n            fontFamily: 'Arial Black',\n            color: '#ffffff',\n            stroke: '#000000',\n            strokeThickness: 3\n        });\n        this.titleText.setOrigin(0.5);\n        this.titleText.setDepth(101);\n        \n        // Add glow effect to title\n        this.tweens.add({\n            targets: this.titleText,\n            scale: { from: 0.95, to: 1.05 },\n            duration: 2000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Create theme selection cards\n        this.createThemeCards();\n        \n        // Create confirm button\n        this.createConfirmButton();\n        \n        // Add keyboard shortcuts\n        this.setupKeyboardControls();\n        \n        // Select first theme by default\n        this.selectTheme(0);\n    }\n\n    private createThemeCards(): void {\n        const { width, height } = this.cameras.main;\n        \n        // Mobile-first vertical layout - optimized for small screens\n        const cardWidth = width * 0.85; // Use 85% of screen width for better mobile fit\n        const cardHeight = 65 * HD_SCALE; // Slightly taller for better touch targets\n        const spacing = 10 * HD_SCALE; // Proportional spacing\n        const titleHeight = 80 * HD_SCALE; // Account for title\n        const buttonHeight = 100 * HD_SCALE; // Account for button at bottom\n        \n        // Calculate available height and distribute cards evenly\n        const availableHeight = height - titleHeight - buttonHeight;\n        const totalCardHeight = (cardHeight * this.themes.length) + (spacing * (this.themes.length - 1));\n        \n        // Center cards vertically in available space\n        const startY = titleHeight + (availableHeight - totalCardHeight) / 2;\n        const centerX = width / 2;\n        \n        this.themes.forEach((theme, index) => {\n            const y = startY + (index * (cardHeight + spacing));\n            const container = this.createThemeCard(theme, centerX, y, cardWidth, cardHeight, index);\n            this.themeContainers.push(container);\n        });\n    }\n\n    private createThemeCard(theme: ThemeOption, x: number, y: number, width: number, height: number, index: number): Phaser.GameObjects.Container {\n        const container = this.add.container(x, y);\n        container.setDepth(102);\n        \n        // Card background\n        const bg = this.add.graphics();\n        bg.fillStyle(0x000000, 0.7);\n        bg.fillRoundedRect(-width/2, -height/2, width, height, 10);\n        bg.lineStyle(2, 0xffffff, 0.3);\n        bg.strokeRoundedRect(-width/2, -height/2, width, height, 10);\n        container.add(bg);\n        \n        // Selection glow (hidden by default)\n        const glow = this.add.graphics();\n        glow.lineStyle(3, 0x00ff00, 1);\n        glow.strokeRoundedRect(-width/2 - 3, -height/2 - 3, width + 6, height + 6, 12);\n        glow.setVisible(false);\n        container.add(glow);\n        container.setData('glow', glow);\n        \n        // Optimized horizontal layout for mobile\n        // Theme icon on the left\n        const iconX = -width/2 + 30 * HD_SCALE;\n        const icon = this.add.text(iconX, 0, theme.icon, {\n            fontSize: `${28 * HD_SCALE}px`,\n            fontFamily: 'Arial'\n        });\n        icon.setOrigin(0.5);\n        container.add(icon);\n        \n        // Theme name - larger and better positioned\n        const nameText = this.add.text(-20 * HD_SCALE, -10 * HD_SCALE, theme.name, {\n            fontSize: `${16 * HD_SCALE}px`,\n            fontFamily: 'Arial Black',\n            color: '#ffffff',\n            align: 'left'\n        });\n        nameText.setOrigin(0, 0.5);\n        container.add(nameText);\n        \n        // Theme description below name\n        const descText = this.add.text(-20 * HD_SCALE, 10 * HD_SCALE, theme.description, {\n            fontSize: `${11 * HD_SCALE}px`,\n            fontFamily: 'Arial',\n            color: '#aaaaaa',\n            align: 'left'\n        });\n        descText.setOrigin(0, 0.5);\n        container.add(descText);\n        \n        // Color preview dots on the right - horizontal layout\n        const dotSize = 8 * HD_SCALE;\n        const dotSpacing = 12 * HD_SCALE;\n        const dotsStartX = width/2 - (theme.colors.length * dotSpacing + 20 * HD_SCALE);\n        \n        theme.colors.forEach((color, i) => {\n            const dot = this.add.circle(\n                dotsStartX + (i * dotSpacing),\n                0,\n                dotSize / 2,\n                color\n            );\n            dot.setStrokeStyle(1, 0xffffff, 0.3);\n            container.add(dot);\n        });\n        \n        // Make interactive\n        container.setInteractive(new Phaser.Geom.Rectangle(-width/2, -height/2, width, height), Phaser.Geom.Rectangle.Contains);\n        \n        // Hover effects\n        container.on('pointerover', () => {\n            this.tweens.add({\n                targets: container,\n                scale: 1.05,\n                duration: 200,\n                ease: 'Power2'\n            });\n            bg.clear();\n            bg.fillStyle(0x000000, 0.9);\n            bg.fillRoundedRect(-width/2, -height/2, width, height, 10);\n            bg.lineStyle(3, 0xffffff, 0.5);\n            bg.strokeRoundedRect(-width/2, -height/2, width, height, 10);\n        });\n        \n        container.on('pointerout', () => {\n            if (this.selectedTheme !== theme.key) {\n                this.tweens.add({\n                    targets: container,\n                    scale: 1,\n                    duration: 200,\n                    ease: 'Power2'\n                });\n                bg.clear();\n                bg.fillStyle(0x000000, 0.7);\n                bg.fillRoundedRect(-width/2, -height/2, width, height, 10);\n                bg.lineStyle(3, 0xffffff, 0.3);\n                bg.strokeRoundedRect(-width/2, -height/2, width, height, 10);\n            }\n        });\n        \n        // Click to select\n        container.on('pointerdown', () => {\n            this.selectTheme(index);\n        });\n        \n        // Add entrance animation\n        container.setScale(0);\n        container.setAlpha(0);\n        this.tweens.add({\n            targets: container,\n            scale: 1,\n            alpha: 1,\n            duration: 500,\n            delay: index * 100,\n            ease: 'Back.easeOut'\n        });\n        \n        return container;\n    }\n\n    private createConfirmButton(): void {\n        const { width, height } = this.cameras.main;\n        const buttonY = height - 50 * HD_SCALE; // Very close to bottom for mobile\n        \n        this.confirmButton = this.add.container(width / 2, buttonY);\n        this.confirmButton.setDepth(103);\n        \n        // Button background - optimized for mobile touch\n        const bg = this.add.graphics();\n        const buttonWidth = width * 0.65; // 65% of screen width\n        const buttonHeight = 40 * HD_SCALE; // Good touch target size\n        \n        bg.fillStyle(0x00ff00, 0.8);\n        bg.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 10);\n        this.confirmButton.add(bg);\n        \n        // Button text - optimized size for mobile\n        const text = this.add.text(0, 0, 'START GAME', {\n            fontSize: `${18 * HD_SCALE}px`,\n            fontFamily: 'Arial Black',\n            color: '#000000'\n        });\n        text.setOrigin(0.5);\n        this.confirmButton.add(text);\n        \n        // Make interactive\n        this.confirmButton.setInteractive(new Phaser.Geom.Rectangle(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight), Phaser.Geom.Rectangle.Contains);\n        \n        // Hover effect\n        this.confirmButton.on('pointerover', () => {\n            bg.clear();\n            bg.fillStyle(0x00ff00, 1);\n            bg.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 10);\n            this.tweens.add({\n                targets: this.confirmButton,\n                scale: 1.1,\n                duration: 200,\n                ease: 'Power2'\n            });\n        });\n        \n        this.confirmButton.on('pointerout', () => {\n            bg.clear();\n            bg.fillStyle(0x00ff00, 0.8);\n            bg.fillRoundedRect(-buttonWidth/2, -buttonHeight/2, buttonWidth, buttonHeight, 10);\n            this.tweens.add({\n                targets: this.confirmButton,\n                scale: 1,\n                duration: 200,\n                ease: 'Power2'\n            });\n        });\n        \n        // Click to start game\n        this.confirmButton.on('pointerdown', () => {\n            this.startGame();\n        });\n        \n        // Pulsing animation\n        this.tweens.add({\n            targets: this.confirmButton,\n            scale: { from: 0.95, to: 1.05 },\n            duration: 1000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n    }\n\n    private selectTheme(index: number): void {\n        const theme = this.themes[index];\n        this.selectedTheme = theme.key;\n        \n        // Update preview background\n        this.previewBackground.setTheme(theme.key);\n        \n        // Update visual selection\n        this.themeContainers.forEach((container, i) => {\n            const glow = container.getData('glow') as Phaser.GameObjects.Graphics;\n            if (i === index) {\n                glow.setVisible(true);\n                container.setScale(1.1);\n                \n                // Bounce animation\n                this.tweens.add({\n                    targets: container,\n                    y: container.y - 10,\n                    duration: 200,\n                    yoyo: true,\n                    ease: 'Power2'\n                });\n            } else {\n                glow.setVisible(false);\n                container.setScale(1);\n            }\n        });\n        \n        // Store selection\n        this.registry.set('selectedTheme', theme.key);\n    }\n\n    private setupKeyboardControls(): void {\n        // Number keys 1-5 for quick selection\n        this.input.keyboard?.on('keydown-ONE', () => this.selectTheme(0));\n        this.input.keyboard?.on('keydown-TWO', () => this.selectTheme(1));\n        this.input.keyboard?.on('keydown-THREE', () => this.selectTheme(2));\n        this.input.keyboard?.on('keydown-FOUR', () => this.selectTheme(3));\n        this.input.keyboard?.on('keydown-FIVE', () => this.selectTheme(4));\n        \n        // Enter or Space to confirm\n        this.input.keyboard?.on('keydown-ENTER', () => this.startGame());\n        this.input.keyboard?.on('keydown-SPACE', () => this.startGame());\n        \n        // ESC to go back\n        this.input.keyboard?.on('keydown-ESC', () => {\n            this.scene.start(SceneKeys.MENU);\n        });\n    }\n\n    private startGame(): void {\n        // Clean up\n        this.previewBackground.destroy();\n        \n        // Transition effect\n        const fadeOut = this.add.graphics();\n        fadeOut.fillStyle(0x000000, 0);\n        fadeOut.fillRect(0, 0, this.cameras.main.width, this.cameras.main.height);\n        fadeOut.setDepth(1000);\n        \n        this.tweens.add({\n            targets: fadeOut,\n            alpha: 1,\n            duration: 500,\n            ease: 'Power2',\n            onComplete: () => {\n                // Start game with selected theme\n                this.scene.start(SceneKeys.GAME, {\n                    theme: this.selectedTheme\n                });\n            }\n        });\n    }\n\n    shutdown(): void {\n        this.previewBackground?.destroy();\n    }\n}","export interface IArenaConfig {\n    width: number;\n    height: number;\n    playerZoneHeight: number;\n    opponentZoneHeight: number;\n    objectiveZoneHeight: number;\n    bubbleSize: number;\n    objectiveSize: number;\n    launcherOffset: number;\n}\n\nexport interface IBubbleData {\n    gridX: number;\n    gridY: number;\n    color: BubbleColor;\n    isSpecial: boolean;\n}\n\nexport interface IHexPosition {\n    q: number; // column\n    r: number; // row\n    s: number; // constraint: q + r + s = 0\n}\n\nexport interface IPixelPosition {\n    x: number;\n    y: number;\n}\n\nexport enum BubbleColor {\n    RED = 0xff0000,\n    BLUE = 0x0000ff,\n    GREEN = 0x00ff00,\n    YELLOW = 0xffff00,\n    PURPLE = 0xff00ff\n}\n\nexport enum ArenaZone {\n    PLAYER = 'player',\n    OPPONENT = 'opponent',\n    OBJECTIVE = 'objective',\n    NEUTRAL = 'neutral'\n}\n\nexport interface IZoneBounds {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    zone: ArenaZone;\n}\n\nexport interface ILauncherConfig {\n    x: number;\n    y: number;\n    angle: number;\n    zone: ArenaZone;\n}\n\nexport interface IObjectiveConfig {\n    x: number;\n    y: number;\n    size: number;\n    health: number;\n}","import { IArenaConfig } from '@/types/ArenaTypes';\n\nconst HD_SCALE = 2.5;  // Ultra HD scaling factor restored\n\nexport const ARENA_CONFIG: IArenaConfig = {\n    width: 375 * HD_SCALE,  // 937.5 Ultra HD width\n    height: 667 * HD_SCALE, // 1667.5 Ultra HD height\n    playerZoneHeight: 267 * HD_SCALE,    // 667.5 Ultra HD\n    opponentZoneHeight: 267 * HD_SCALE,  // 667.5 Ultra HD\n    objectiveZoneHeight: 133 * HD_SCALE, // 332.5 Ultra HD\n    bubbleSize: 28 * HD_SCALE,  // 70 Ultra HD (reduced from 32)\n    objectiveSize: 28 * HD_SCALE, // 70 Ultra HD (reduced from 32)\n    launcherOffset: 45 * HD_SCALE  // 112.5 Ultra HD (reduced from 50)\n};\n\nexport const BUBBLE_CONFIG = {\n    SIZE: 28 * HD_SCALE,  // 70 Ultra HD (reduced from 32)\n    GAP: 0,  // No gap - bubbles touch perfectly\n    COLORS: 5,\n    POOL_SIZE: 50, // OPTIMIZED: Reduced pool size for better iOS performance\n    HEX_WIDTH: 28 * HD_SCALE,  // 70 Ultra HD (reduced)\n    HEX_HEIGHT: 24 * HD_SCALE, // 60 Ultra HD (SIZE * 0.866)\n    ANIMATION_DURATION: 200,\n    FALL_SPEED: 500 * HD_SCALE  // 1250 Ultra HD\n};\n\nexport const GRID_CONFIG = {\n    ROWS: 15,\n    COLS: 11,\n    CENTER_ROW: 7,\n    CENTER_COL: 5,\n    OBJECTIVE_RADIUS: 3 // Bubbles around objective in hex rings\n};\n\nexport const DANGER_ZONE_CONFIG = {\n    PLAYER_OFFSET: 120 * HD_SCALE,    // 300 Ultra HD\n    OPPONENT_OFFSET: 120 * HD_SCALE,  // 300 Ultra HD\n    LINE_COLOR: 0xFFFFFF,\n    LINE_ALPHA: 0.08,\n    LINE_WIDTH: 1 * HD_SCALE,  // 2.5 Ultra HD\n    PULSE_DURATION: 1000\n};\n\nexport const ZONE_COLORS = {\n    PLAYER: 0x3498db,\n    OPPONENT: 0xe74c3c,\n    OBJECTIVE: 0xf39c12,\n    NEUTRAL: 0x95a5a6,\n    DEBUG_ALPHA: 0.2\n};\n\nexport const Z_LAYERS = {\n    BACKGROUND: 0,\n    ZONE_DEBUG: 1,\n    GRID_DEBUG: 2,\n    BUBBLES_BACK: 10,\n    BUBBLES: 15,  // Grid bubbles\n    BUBBLES_FRONT: 20,  // Projectile bubbles\n    OBJECTIVE: 25,  // Objective should be above bubbles\n    LAUNCHERS: 40,\n    UI: 50,\n    FLOATING_UI: 60,  // For floating power-ups\n    DEBUG_OVERLAY: 100\n};","import { IHexPosition, IPixelPosition } from '@/types/ArenaTypes';\nimport { BUBBLE_CONFIG, GRID_CONFIG } from '@/config/ArenaConfig';\n\nexport class BubbleGrid {\n    private centerX: number;\n    private centerY: number;\n    private hexSize: number;\n    private gridMap: Map<string, IHexPosition>;\n\n    constructor(centerX: number, centerY: number) {\n        this.centerX = centerX;\n        this.centerY = centerY;\n        // Use bubble radius plus small spacing\n        this.hexSize = (BUBBLE_CONFIG.SIZE / 2) + 1;\n        this.gridMap = new Map();\n        this.initializeGrid();\n    }\n\n    private initializeGrid(): void {\n        // Initialize hex grid positions\n        for (let q = -GRID_CONFIG.CENTER_COL; q <= GRID_CONFIG.CENTER_COL; q++) {\n            for (let r = -GRID_CONFIG.CENTER_ROW; r <= GRID_CONFIG.CENTER_ROW; r++) {\n                const s = -q - r;\n                const key = this.getKey(q, r);\n                this.gridMap.set(key, { q, r, s });\n            }\n        }\n    }\n\n    public hexToPixel(hex: IHexPosition): IPixelPosition {\n        // Simple offset grid for bubble shooters\n        // Odd rows are offset by half a bubble width\n        const rowHeight = this.hexSize * Math.sqrt(3);\n        const colWidth = this.hexSize * 2;\n        \n        // Calculate position with offset for odd rows\n        const isOddRow = Math.abs(hex.r) % 2 === 1;\n        const xOffset = isOddRow ? this.hexSize : 0;\n        \n        const x = hex.q * colWidth + xOffset;\n        const y = hex.r * rowHeight;\n        \n        return {\n            x: this.centerX + x,\n            y: this.centerY + y\n        };\n    }\n\n    public pixelToHex(pixel: IPixelPosition): IHexPosition {\n        const x = pixel.x - this.centerX;\n        const y = pixel.y - this.centerY;\n        \n        const rowHeight = this.hexSize * Math.sqrt(3);\n        const colWidth = this.hexSize * 2;\n        \n        // Estimate row\n        const r = Math.round(y / rowHeight);\n        \n        // Adjust x for odd row offset\n        const isOddRow = Math.abs(r) % 2 === 1;\n        const adjustedX = isOddRow ? x - this.hexSize : x;\n        \n        // Estimate column\n        const q = Math.round(adjustedX / colWidth);\n        \n        return { q, r, s: -q - r };\n    }\n\n    private roundHex(q: number, r: number): IHexPosition {\n        const s = -q - r;\n        \n        let rq = Math.round(q);\n        let rr = Math.round(r);\n        let rs = Math.round(s);\n        \n        const qDiff = Math.abs(rq - q);\n        const rDiff = Math.abs(rr - r);\n        const sDiff = Math.abs(rs - s);\n        \n        if (qDiff > rDiff && qDiff > sDiff) {\n            rq = -rr - rs;\n        } else if (rDiff > sDiff) {\n            rr = -rq - rs;\n        } else {\n            rs = -rq - rr;\n        }\n        \n        return { q: rq, r: rr, s: rs };\n    }\n\n    public getNeighbors(hex: IHexPosition): IHexPosition[] {\n        // For offset grid, neighbors depend on whether we're in an odd or even row\n        const isOddRow = Math.abs(hex.r) % 2 === 1;\n        \n        let directions: Array<{q: number, r: number}> = [];\n        \n        if (!isOddRow) {\n            // Even row neighbors\n            directions = [\n                { q: 0, r: -1 },   // Top\n                { q: 1, r: 0 },    // Right\n                { q: 0, r: 1 },    // Bottom\n                { q: -1, r: 1 },   // Bottom-left\n                { q: -1, r: 0 },   // Left\n                { q: -1, r: -1 }   // Top-left\n            ];\n        } else {\n            // Odd row neighbors (offset by half)\n            directions = [\n                { q: 0, r: -1 },   // Top\n                { q: 1, r: -1 },   // Top-right\n                { q: 1, r: 0 },    // Right\n                { q: 1, r: 1 },    // Bottom-right\n                { q: 0, r: 1 },    // Bottom\n                { q: -1, r: 0 }    // Left\n            ];\n        }\n        \n        return directions.map(dir => ({\n            q: hex.q + dir.q,\n            r: hex.r + dir.r,\n            s: 0 // Not used in offset grid\n        }));\n    }\n\n    public getDistance(a: IHexPosition, b: IHexPosition): number {\n        return (Math.abs(a.q - b.q) + Math.abs(a.r - b.r) + Math.abs(a.s - b.s)) / 2;\n    }\n\n    public getRing(center: IHexPosition, radius: number): IHexPosition[] {\n        if (radius === 0) return [center];\n        \n        const results: IHexPosition[] = [];\n        const directions = [\n            { q: 1, r: 0, s: -1 },\n            { q: 1, r: -1, s: 0 },\n            { q: 0, r: -1, s: 1 },\n            { q: -1, r: 0, s: 1 },\n            { q: -1, r: 1, s: 0 },\n            { q: 0, r: 1, s: -1 }\n        ];\n        \n        let hex = {\n            q: center.q + directions[4].q * radius,\n            r: center.r + directions[4].r * radius,\n            s: center.s + directions[4].s * radius\n        };\n        \n        for (let i = 0; i < 6; i++) {\n            for (let j = 0; j < radius; j++) {\n                results.push({ ...hex });\n                hex = {\n                    q: hex.q + directions[i].q,\n                    r: hex.r + directions[i].r,\n                    s: hex.s + directions[i].s\n                };\n            }\n        }\n        \n        return results;\n    }\n\n    public getSpiral(center: IHexPosition, maxRadius: number): IHexPosition[] {\n        const results: IHexPosition[] = [];\n        \n        for (let radius = 0; radius <= maxRadius; radius++) {\n            const ring = this.getRing(center, radius);\n            results.push(...ring);\n        }\n        \n        return results;\n    }\n\n    private getKey(q: number, r: number): string {\n        return `${q},${r}`;\n    }\n\n    public isValidPosition(hex: IHexPosition): boolean {\n        const key = this.getKey(hex.q, hex.r);\n        return this.gridMap.has(key);\n    }\n\n    public getGridBounds(): { minQ: number; maxQ: number; minR: number; maxR: number } {\n        return {\n            minQ: -GRID_CONFIG.CENTER_COL,\n            maxQ: GRID_CONFIG.CENTER_COL,\n            minR: -GRID_CONFIG.CENTER_ROW,\n            maxR: GRID_CONFIG.CENTER_ROW\n        };\n    }\n    \n    /**\n     * Get all bubbles currently in the grid\n     */\n    public getAllBubbles(): any[] {\n        // This would need to be implemented with actual bubble tracking\n        return [];\n    }\n    \n    /**\n     * Get bubble at specific world position\n     */\n    public getBubbleAt(x: number, y: number): any | null {\n        // Convert world position to hex position\n        const hex = this.pixelToHex({ x, y });\n        const key = this.getKey(hex.q, hex.r);\n        \n        // This would need actual bubble tracking\n        return null;\n    }\n    \n    /**\n     * Get bubbles within radius of a point\n     */\n    public getBubblesInRadius(x: number, y: number, radius: number): any[] {\n        // This would need actual implementation with bubble tracking\n        return [];\n    }\n}","import { BubbleColor, IHexPosition } from '@/types/ArenaTypes';\nimport { BUBBLE_CONFIG, Z_LAYERS } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\n\nexport class Bubble extends Phaser.GameObjects.Container {\n    private bubbleSprite: Phaser.GameObjects.Arc;\n    private innerGradient?: Phaser.GameObjects.Arc;\n    private highlightSprite?: Phaser.GameObjects.Arc;\n    private secondaryHighlight?: Phaser.GameObjects.Arc;\n    private shadowSprite?: Phaser.GameObjects.Arc;\n    private rimLight?: Phaser.GameObjects.Arc;\n    private gridPosition: IHexPosition | null = null;\n    private color: BubbleColor;\n    private isSpecial: boolean = false;\n    private pooled: boolean = false;\n    private shooter: 'player' | 'ai' | 'none' = 'none';\n    private idleAnimation?: Phaser.Tweens.Tween;\n\n    constructor(scene: Phaser.Scene, x: number, y: number, color: BubbleColor) {\n        super(scene, x, y);\n        \n        this.color = color;\n        const radius = BUBBLE_CONFIG.SIZE / 2;\n        \n        // Premium bubble design with multiple layers\n        // 1. Simple shadow without blend mode\n        this.shadowSprite = scene.add.circle(3, 5, radius, 0x000000, 0.2);\n        // NO BLEND MODE for performance\n        this.shadowSprite.setScale(0.95);\n        \n        // 2. Main bubble base\n        this.bubbleSprite = scene.add.circle(0, 0, radius, color);\n        \n        // 3. HD inner gradient with better depth\n        this.innerGradient = scene.add.circle(0, 2, radius - 4, this.getDarkerColor(color));\n        this.innerGradient.setAlpha(0.5);\n        this.innerGradient.setScale(0.9);\n        \n        // 4. HD rim lighting for 3D pop\n        this.rimLight = scene.add.circle(0, 0, radius - 2, this.getLighterColor(color));\n        this.rimLight.setAlpha(0.0); // Will be visible only at edges via stroke\n        this.rimLight.setStrokeStyle(3, this.getLighterColor(color), 0.6);\n        \n        // 5. Simple highlight without blend mode\n        this.highlightSprite = scene.add.ellipse(\n            -radius * 0.35,\n            -radius * 0.4,\n            radius * 0.75,\n            radius * 0.55,\n            0xFFFFFF,\n            0.3\n        );\n        // NO BLEND MODE for performance\n        \n        // 6. Simple secondary highlight\n        this.secondaryHighlight = scene.add.circle(\n            radius * 0.3,\n            -radius * 0.35,\n            radius * 0.25,\n            0xFFFFFF,\n            0.2\n        );\n        // NO BLEND MODE for performance\n        \n        // 7. Ultra HD border for crisp definition\n        this.bubbleSprite.setStrokeStyle(3, this.getDarkerColor(color), 1);\n        \n        // Add all elements in proper order for best visual effect\n        this.add([\n            this.shadowSprite,\n            this.bubbleSprite,\n            this.innerGradient,\n            this.rimLight,\n            this.highlightSprite,\n            this.secondaryHighlight\n        ]);\n        \n        this.setSize(BUBBLE_CONFIG.SIZE, BUBBLE_CONFIG.SIZE);\n        this.setDepth(Z_LAYERS.BUBBLES);\n        \n        scene.add.existing(this);\n        \n        // No idle animation - keep bubbles static\n        // this.addIdleAnimation();\n    }\n    \n    private addIdleAnimation(): void {\n        // DISABLED - No idle animations to keep bubbles static\n        // Only animate highlight shimmer if needed\n        if (this.highlightSprite && false) { // Disabled for now\n            this.scene.tweens.add({\n                targets: this.highlightSprite,\n                alpha: { from: 0.4, to: 0.6 },\n                duration: 3000,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut',\n                delay: Math.random() * 1000\n            });\n        }\n    }\n\n    public setGridPosition(hex: IHexPosition | null): void {\n        this.gridPosition = hex;\n    }\n\n    public getGridPosition(): IHexPosition | null {\n        return this.gridPosition;\n    }\n    \n    public setShooter(shooter: 'player' | 'ai'): void {\n        this.shooter = shooter;\n    }\n    \n    public getShooter(): 'player' | 'ai' | 'none' {\n        return this.shooter;\n    }\n\n    public getColor(): BubbleColor {\n        return this.color;\n    }\n    \n    public setColor(color: BubbleColor): void {\n        this.color = color;\n        // Update all color-dependent elements\n        this.bubbleSprite.setFillStyle(color);\n        this.bubbleSprite.setStrokeStyle(2, this.getDarkerColor(color), 1);\n        \n        if (this.innerGradient) {\n            this.innerGradient.setFillStyle(this.getDarkerColor(color));\n        }\n        \n        if (this.rimLight) {\n            this.rimLight.setStrokeStyle(2, this.getLighterColor(color), 0.5);\n        }\n    }\n\n    public setTint(tint: number): void {\n        this.bubbleSprite.setFillStyle(tint);\n    }\n\n    public clearTint(): void {\n        this.bubbleSprite.setFillStyle(this.color);\n    }\n\n    public setSpecial(special: boolean): void {\n        this.isSpecial = special;\n        if (special) {\n            this.addGlow();\n        } else {\n            this.removeGlow();\n        }\n    }\n\n    public getIsSpecial(): boolean {\n        return this.isSpecial;\n    }\n\n    private addGlow(): void {\n        // No scale animation - just visual glow\n        // Add pulsing glow ring behind bubble\n        const glow = this.scene.add.circle(0, 0, BUBBLE_CONFIG.SIZE / 2 + (3 * HD_SCALE), this.color, 0.4);\n        glow.setStrokeStyle(2, this.getLighterColor(this.color), 0.6);\n        this.addAt(glow, 0);\n        \n        // Animate only the glow opacity, not the bubble scale\n        this.scene.tweens.add({\n            targets: glow,\n            alpha: { from: 0.2, to: 0.5 },\n            duration: 800,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n    }\n\n    private removeGlow(): void {\n        // Remove the glow element if it exists\n        if (this.length > 6) { // We have 6 base elements, glow would be 7th\n            const glowElement = this.getAt(0);\n            this.scene.tweens.killTweensOf(glowElement);\n            this.removeAt(0);\n            glowElement.destroy();\n        }\n    }\n\n    private getDarkerColor(color: BubbleColor): number {\n        // Create darker shade for depth\n        const r = (color >> 16) & 0xff;\n        const g = (color >> 8) & 0xff;\n        const b = color & 0xff;\n        \n        // Much darker for inner gradient\n        return (Math.floor(r * 0.5) << 16) | \n               (Math.floor(g * 0.5) << 8) | \n               Math.floor(b * 0.5);\n    }\n    \n    private getLighterColor(color: BubbleColor): number {\n        // Create lighter shade for rim lighting\n        const r = (color >> 16) & 0xff;\n        const g = (color >> 8) & 0xff;\n        const b = color & 0xff;\n        \n        // Lighter version for rim\n        const lr = Math.min(255, Math.floor(r * 1.3 + 50));\n        const lg = Math.min(255, Math.floor(g * 1.3 + 50));\n        const lb = Math.min(255, Math.floor(b * 1.3 + 50));\n        \n        return (lr << 16) | (lg << 8) | lb;\n    }\n\n    /**\n     * Adds colorblind-friendly patterns to bubbles\n     * Each color gets a unique pattern for accessibility\n     */\n    private addColorblindPattern(color: BubbleColor): void {\n        if (!this.patternSprite) return;\n        \n        this.patternSprite.clear();\n        this.patternSprite.lineStyle(1 * HD_SCALE, 0xffffff, 0.4);\n        \n        const radius = BUBBLE_CONFIG.SIZE / 2;\n        \n        switch (color) {\n            case BubbleColor.RED:\n                // Horizontal lines pattern\n                for (let y = -radius + (2 * HD_SCALE); y < radius; y += (3 * HD_SCALE)) {\n                    const x = Math.sqrt(radius * radius - y * y) * 0.8;\n                    this.patternSprite.lineBetween(-x, y, x, y);\n                }\n                break;\n                \n            case BubbleColor.BLUE:\n                // Vertical lines pattern\n                for (let x = -radius + (2 * HD_SCALE); x < radius; x += (3 * HD_SCALE)) {\n                    const y = Math.sqrt(radius * radius - x * x) * 0.8;\n                    this.patternSprite.lineBetween(x, -y, x, y);\n                }\n                break;\n                \n            case BubbleColor.GREEN:\n                // Diagonal lines (top-left to bottom-right)\n                for (let offset = -radius; offset < radius; offset += (3 * HD_SCALE)) {\n                    const startX = Math.max(-radius * 0.7, offset - radius * 0.7);\n                    const startY = Math.max(-radius * 0.7, -offset - radius * 0.7);\n                    const endX = Math.min(radius * 0.7, offset + radius * 0.7);\n                    const endY = Math.min(radius * 0.7, -offset + radius * 0.7);\n                    this.patternSprite.lineBetween(startX, startY, endX, endY);\n                }\n                break;\n                \n            case BubbleColor.YELLOW:\n                // Dots pattern\n                for (let x = -radius + (3 * HD_SCALE); x < radius; x += (4 * HD_SCALE)) {\n                    for (let y = -radius + (3 * HD_SCALE); y < radius; y += (4 * HD_SCALE)) {\n                        if (x * x + y * y < radius * radius * 0.7) {\n                            this.patternSprite.fillStyle(0xffffff, 0.5);\n                            this.patternSprite.fillCircle(x, y, 1 * HD_SCALE);\n                        }\n                    }\n                }\n                break;\n                \n            case BubbleColor.PURPLE:\n                // Cross-hatch pattern (X pattern)\n                for (let offset = -radius; offset < radius; offset += (3 * HD_SCALE)) {\n                    // Diagonal 1\n                    const x1 = Math.max(-radius * 0.7, offset - radius * 0.7);\n                    const y1 = Math.max(-radius * 0.7, -offset - radius * 0.7);\n                    const x2 = Math.min(radius * 0.7, offset + radius * 0.7);\n                    const y2 = Math.min(radius * 0.7, -offset + radius * 0.7);\n                    this.patternSprite.lineBetween(x1, y1, x2, y2);\n                    \n                    // Diagonal 2 (opposite)\n                    this.patternSprite.lineBetween(x1, -y1, x2, -y2);\n                }\n                break;\n        }\n    }\n\n    public pop(): void {\n        // Stop idle animation\n        if (this.idleAnimation) {\n            this.idleAnimation.stop();\n        }\n        \n        // Dynamic pop animation\n        this.scene.tweens.add({\n            targets: this,\n            scaleX: 1.3,\n            scaleY: 1.3,\n            alpha: 0,\n            duration: BUBBLE_CONFIG.ANIMATION_DURATION,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                this.setVisible(false);\n                this.returnToPool();\n            }\n        });\n        \n        // Rotate for dynamic effect\n        this.scene.tweens.add({\n            targets: this,\n            angle: Phaser.Math.Between(-45, 45),\n            duration: BUBBLE_CONFIG.ANIMATION_DURATION,\n            ease: 'Power2'\n        });\n        \n        // Create enhanced particle effect\n        this.createPopParticles();\n    }\n\n    private createPopParticles(): void {\n        // Premium particle explosion\n        const particleCount = 8;\n        const colors = [this.color, this.getLighterColor(this.color), 0xFFFFFF];\n        \n        for (let i = 0; i < particleCount; i++) {\n            const size = Phaser.Math.Between(2, 6);\n            const colorIndex = i % colors.length;\n            const particle = this.scene.add.circle(\n                this.x, \n                this.y, \n                size,\n                colors[colorIndex],\n                1\n            );\n            // NO BLEND MODE for performance\n            \n            const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.3;\n            const speed = Phaser.Math.Between(50, 150);\n            const rotationSpeed = Phaser.Math.Between(-360, 360);\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: this.x + Math.cos(angle) * speed,\n                y: this.y + Math.sin(angle) * speed + Phaser.Math.Between(-10, 30),\n                scale: 0,\n                alpha: 0,\n                angle: rotationSpeed,\n                duration: 400 + Math.random() * 100,\n                ease: 'Expo.easeOut',\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n        \n        // Simple flash effect for impact\n        const flash1 = this.scene.add.circle(this.x, this.y, BUBBLE_CONFIG.SIZE / 2, 0xFFFFFF, 0.4);\n        // NO BLEND MODE for performance\n        \n        this.scene.tweens.add({\n            targets: flash1,\n            scale: 2,\n            alpha: 0,\n            duration: 250,\n            ease: 'Power2',\n            onComplete: () => {\n                flash1.destroy();\n            }\n        });\n        \n        // Ring burst effect\n        const ring = this.scene.add.circle(this.x, this.y, BUBBLE_CONFIG.SIZE / 2, this.color, 0);\n        ring.setStrokeStyle(3, this.color, 0.8);\n        \n        this.scene.tweens.add({\n            targets: ring,\n            scale: 2.5,\n            alpha: 0,\n            duration: 300,\n            ease: 'Power2',\n            onComplete: () => {\n                ring.destroy();\n            }\n        });\n    }\n\n    public reset(x: number, y: number, color?: BubbleColor): void {\n        this.setPosition(x, y);\n        this.setAlpha(1);\n        this.setScale(1);\n        this.setVisible(true);\n        this.gridPosition = null;\n        this.isSpecial = false;\n        this.pooled = false;\n        \n        // Update color if provided\n        if (color !== undefined) {\n            this.setColor(color);\n        }\n    }\n\n    public returnToPool(): void {\n        this.pooled = true;\n        this.setVisible(false);\n        this.gridPosition = null;\n        // Reset position to avoid positioning bugs when reused\n        this.setPosition(0, 0);\n        this.setScale(1);\n        this.setAlpha(1);\n        this.setAngle(0);\n        this.clearTint();\n    }\n\n    public isPooled(): boolean {\n        return this.pooled;\n    }\n\n    public static getRandomColor(): BubbleColor {\n        const colors = [\n            BubbleColor.RED,\n            BubbleColor.BLUE,\n            BubbleColor.GREEN,\n            BubbleColor.YELLOW,\n            BubbleColor.PURPLE\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n}","import { Scene } from 'phaser';\n\n// Event types for different scoring scenarios\nexport enum ScoreEventType {\n    BUBBLE_MATCH = 'bubble_match',\n    ORPHAN_DROP = 'orphan_drop',\n    POWER_UP = 'power_up',\n    CHAIN_COMBO = 'chain_combo',\n    SPECIAL_BONUS = 'special_bonus',\n    OBJECTIVE_HIT = 'objective_hit',\n    TIME_BONUS = 'time_bonus',\n    PERFECT_SHOT = 'perfect_shot'\n}\n\n// Context for scoring calculation\nexport interface ScoreContext {\n    type: ScoreEventType;\n    baseValue: number;\n    position: { x: number; y: number };\n    matchSize?: number;\n    comboLevel?: number;\n    isPlayer: boolean;\n    bubbleColor?: number;\n    metadata?: Record<string, any>;\n}\n\n// Result of score calculation\nexport interface ScoreResult {\n    finalScore: number;\n    displayText: string;\n    visualEffectLevel: number; // 1-5 for effect intensity\n    color: number;\n    comboMultiplier?: number;\n}\n\n// Interface for scoring modules\nexport interface IScoringModule {\n    type: ScoreEventType;\n    calculateScore(context: ScoreContext): ScoreResult;\n    canProcess(context: ScoreContext): boolean;\n    priority: number; // Higher priority processes first\n}\n\n// Score event for queue processing\ninterface ScoreEvent {\n    context: ScoreContext;\n    timestamp: number;\n    processed: boolean;\n}\n\nexport class ScoreEventManager {\n    private scene: Scene;\n    private modules: Map<ScoreEventType, IScoringModule[]> = new Map();\n    private eventQueue: ScoreEvent[] = [];\n    private processing: boolean = false;\n    private totalPlayerScore: number = 0;\n    private totalOpponentScore: number = 0;\n    \n    // Performance optimization\n    private readonly MAX_QUEUE_SIZE = 50;\n    private readonly PROCESS_INTERVAL = 16; // ~60fps\n    \n    // Event callbacks\n    private scoreUpdateCallbacks: ((score: number, isPlayer: boolean) => void)[] = [];\n    private visualEffectCallbacks: ((result: ScoreResult, position: { x: number; y: number }) => void)[] = [];\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.initializeDefaultModules();\n        this.startProcessing();\n    }\n    \n    private initializeDefaultModules(): void {\n        // Register default scoring modules\n        this.registerModule(new BubbleMatchModule());\n        this.registerModule(new OrphanDropModule());\n        this.registerModule(new ChainComboModule());\n    }\n    \n    public registerModule(module: IScoringModule): void {\n        if (!this.modules.has(module.type)) {\n            this.modules.set(module.type, []);\n        }\n        \n        const modules = this.modules.get(module.type)!;\n        modules.push(module);\n        \n        // Sort by priority\n        modules.sort((a, b) => b.priority - a.priority);\n    }\n    \n    public queueEvent(context: ScoreContext): void {\n        // Add to queue\n        this.eventQueue.push({\n            context,\n            timestamp: Date.now(),\n            processed: false\n        });\n        \n        // Limit queue size for performance\n        if (this.eventQueue.length > this.MAX_QUEUE_SIZE) {\n            this.eventQueue.shift();\n        }\n    }\n    \n    private startProcessing(): void {\n        this.scene.time.addEvent({\n            delay: this.PROCESS_INTERVAL,\n            callback: this.processQueue,\n            callbackScope: this,\n            loop: true\n        });\n    }\n    \n    private processQueue(): void {\n        if (this.processing || this.eventQueue.length === 0) return;\n        \n        this.processing = true;\n        \n        // Process up to 5 events per frame to maintain performance\n        const eventsToProcess = Math.min(5, this.eventQueue.length);\n        \n        for (let i = 0; i < eventsToProcess; i++) {\n            const event = this.eventQueue.shift();\n            if (!event || event.processed) continue;\n            \n            this.processEvent(event);\n        }\n        \n        this.processing = false;\n    }\n    \n    private processEvent(event: ScoreEvent): void {\n        const { context } = event;\n        const modules = this.modules.get(context.type) || [];\n        \n        let finalResult: ScoreResult | null = null;\n        \n        // Process through all applicable modules\n        for (const module of modules) {\n            if (module.canProcess(context)) {\n                const result = module.calculateScore(context);\n                \n                // Combine results if multiple modules apply\n                if (finalResult) {\n                    finalResult.finalScore += result.finalScore;\n                    finalResult.visualEffectLevel = Math.max(\n                        finalResult.visualEffectLevel,\n                        result.visualEffectLevel\n                    );\n                } else {\n                    finalResult = result;\n                }\n            }\n        }\n        \n        if (finalResult) {\n            // Update scores\n            if (context.isPlayer) {\n                this.totalPlayerScore += finalResult.finalScore;\n                this.notifyScoreUpdate(this.totalPlayerScore, true);\n            } else {\n                this.totalOpponentScore += finalResult.finalScore;\n                this.notifyScoreUpdate(this.totalOpponentScore, false);\n            }\n            \n            // Trigger visual effects\n            this.notifyVisualEffect(finalResult, context.position);\n            \n            // Emit scene event for other systems\n            this.scene.events.emit('score-calculated', {\n                context,\n                result: finalResult\n            });\n        }\n        \n        event.processed = true;\n    }\n    \n    public onScoreUpdate(callback: (score: number, isPlayer: boolean) => void): void {\n        this.scoreUpdateCallbacks.push(callback);\n    }\n    \n    public onVisualEffect(callback: (result: ScoreResult, position: { x: number; y: number }) => void): void {\n        this.visualEffectCallbacks.push(callback);\n    }\n    \n    private notifyScoreUpdate(score: number, isPlayer: boolean): void {\n        this.scoreUpdateCallbacks.forEach(cb => cb(score, isPlayer));\n    }\n    \n    private notifyVisualEffect(result: ScoreResult, position: { x: number; y: number }): void {\n        this.visualEffectCallbacks.forEach(cb => cb(result, position));\n    }\n    \n    public getPlayerScore(): number {\n        return this.totalPlayerScore;\n    }\n    \n    public getOpponentScore(): number {\n        return this.totalOpponentScore;\n    }\n    \n    public reset(): void {\n        this.totalPlayerScore = 0;\n        this.totalOpponentScore = 0;\n        this.eventQueue = [];\n        this.processing = false;\n    }\n    \n    public destroy(): void {\n        this.reset();\n        this.modules.clear();\n        this.scoreUpdateCallbacks = [];\n        this.visualEffectCallbacks = [];\n    }\n}\n\n// Default Scoring Modules\n\nclass BubbleMatchModule implements IScoringModule {\n    type = ScoreEventType.BUBBLE_MATCH;\n    priority = 100;\n    \n    private readonly BASE_POINTS: { [key: number]: number } = {\n        3: 10,\n        4: 20,\n        5: 30,\n        6: 40,\n        7: 50\n    };\n    \n    canProcess(context: ScoreContext): boolean {\n        return context.type === this.type && (context.matchSize ?? 0) >= 3;\n    }\n    \n    calculateScore(context: ScoreContext): ScoreResult {\n        const matchSize = context.matchSize ?? 3;\n        const basePoints = this.BASE_POINTS[Math.min(matchSize, 7)] || this.BASE_POINTS[7];\n        \n        // Calculate multiplier and text based on match size\n        let multiplier = 1.0;\n        let displayText = `+${basePoints}`;\n        let effectLevel = 1;\n        \n        if (matchSize >= 7) {\n            multiplier = 2.0;\n            const finalScore = Math.floor(basePoints * multiplier);\n            displayText = `PERFECT!\\n+${finalScore}`;\n            effectLevel = 5;\n        } else if (matchSize >= 6) {\n            multiplier = 1.8;\n            const finalScore = Math.floor(basePoints * multiplier);\n            displayText = `AMAZING!\\n+${finalScore}`;\n            effectLevel = 4;\n        } else if (matchSize >= 5) {\n            multiplier = 1.5;\n            const finalScore = Math.floor(basePoints * multiplier);\n            displayText = `GREAT!\\n+${finalScore}`;\n            effectLevel = 3;\n        } else if (matchSize >= 4) {\n            multiplier = 1.2;\n            const finalScore = Math.floor(basePoints * multiplier);\n            displayText = `GOOD!\\n+${finalScore}`;\n            effectLevel = 2;\n        }\n        \n        return {\n            finalScore: Math.floor(basePoints * multiplier),\n            displayText,\n            visualEffectLevel: effectLevel,\n            color: context.bubbleColor || 0xFFD700,\n            comboMultiplier: multiplier\n        };\n    }\n}\n\nclass OrphanDropModule implements IScoringModule {\n    type = ScoreEventType.ORPHAN_DROP;\n    priority = 90;\n    \n    canProcess(context: ScoreContext): boolean {\n        return context.type === this.type;\n    }\n    \n    calculateScore(context: ScoreContext): ScoreResult {\n        const dropCount = context.metadata?.dropCount || 1;\n        const pointsPerDrop = 5;\n        const totalPoints = dropCount * pointsPerDrop;\n        \n        // Different text for different drop amounts\n        let displayText = '';\n        if (dropCount <= 3) {\n            displayText = `DROP!\\n+${totalPoints}`;\n        } else if (dropCount <= 6) {\n            displayText = `NICE DROP!\\n+${totalPoints}`;\n        } else {\n            displayText = `MEGA DROP!\\n+${totalPoints}`;\n        }\n        \n        return {\n            finalScore: totalPoints,\n            displayText,\n            visualEffectLevel: Math.min(Math.ceil(dropCount / 3), 3),\n            color: 0x00BFFF,\n            comboMultiplier: 1.0\n        };\n    }\n}\n\nclass ChainComboModule implements IScoringModule {\n    type = ScoreEventType.CHAIN_COMBO;\n    priority = 80;\n    \n    private chainCount: number = 0;\n    private lastChainTime: number = 0;\n    private readonly CHAIN_TIMEOUT = 2000;\n    \n    canProcess(context: ScoreContext): boolean {\n        if (context.type !== ScoreEventType.BUBBLE_MATCH) return false;\n        \n        const now = Date.now();\n        const isChain = (now - this.lastChainTime) < this.CHAIN_TIMEOUT;\n        \n        if (isChain) {\n            this.chainCount++;\n        } else {\n            this.chainCount = 0;\n        }\n        \n        this.lastChainTime = now;\n        return isChain && this.chainCount > 1;\n    }\n    \n    calculateScore(context: ScoreContext): ScoreResult {\n        const chainBonus = this.chainCount * 10;\n        \n        return {\n            finalScore: chainBonus,\n            displayText: `CHAIN x${this.chainCount}`,\n            visualEffectLevel: Math.min(this.chainCount, 4),\n            color: 0xFF69B4,\n            comboMultiplier: 1.0 + (this.chainCount * 0.1)\n        };\n    }\n}","import { Scene } from 'phaser';\nimport { ScoreEventManager, ScoreEventType } from '../scoring/ScoreEventManager';\n\n// Power-up types\nexport enum PowerUpType {\n    BOMB = 'bomb',           // Explodes in area\n    LASER = 'laser',         // Destroys entire line\n    RAINBOW = 'rainbow',     // Matches any color\n    MULTIPLIER = 'multiplier', // Score multiplier\n    FREEZE = 'freeze',       // Slows down time\n    LIGHTNING = 'lightning', // Chain reaction\n    MAGNET = 'magnet',      // Attracts bubbles\n    SHIELD = 'shield'       // Protection from danger\n}\n\n// Power-up configuration\nexport interface PowerUpConfig {\n    type: PowerUpType;\n    name: string;\n    description: string;\n    icon: string;\n    color: number;\n    rarity: number; // 1-5 (common to legendary)\n    duration?: number; // For time-based power-ups\n    radius?: number; // For area effects\n    power?: number; // Effect strength\n}\n\n// Power-up instance\nexport interface PowerUp {\n    id: string;\n    type: PowerUpType;\n    config: PowerUpConfig;\n    active: boolean;\n    position?: { x: number; y: number };\n    owner: 'player' | 'opponent';\n    activatedAt?: number;\n    expiresAt?: number;\n}\n\n// Power-up effect handler\nexport interface IPowerUpEffect {\n    type: PowerUpType;\n    canActivate(powerUp: PowerUp, target?: any): boolean;\n    activate(powerUp: PowerUp, target?: any): void;\n    update?(powerUp: PowerUp, delta: number): void;\n    deactivate(powerUp: PowerUp): void;\n}\n\nexport class PowerUpManager {\n    private scene: Scene;\n    private scoreEventManager?: ScoreEventManager;\n    private powerUps: Map<string, PowerUp> = new Map();\n    private effects: Map<PowerUpType, IPowerUpEffect> = new Map();\n    private activePowerUps: PowerUp[] = [];\n    \n    // Power-up configurations\n    private readonly POWER_UP_CONFIGS: Map<PowerUpType, PowerUpConfig> = new Map([\n        [PowerUpType.BOMB, {\n            type: PowerUpType.BOMB,\n            name: 'Bomb',\n            description: 'Explodes bubbles in area',\n            icon: '💣',\n            color: 0xFF4500,\n            rarity: 2,\n            radius: 100,\n            power: 3\n        }],\n        [PowerUpType.LASER, {\n            type: PowerUpType.LASER,\n            name: 'Laser',\n            description: 'Destroys entire line',\n            icon: '⚡',\n            color: 0x00FFFF,\n            rarity: 3,\n            power: 5\n        }],\n        [PowerUpType.RAINBOW, {\n            type: PowerUpType.RAINBOW,\n            name: 'Rainbow',\n            description: 'Matches any color',\n            icon: '🌈',\n            color: 0xFF69B4,\n            rarity: 4,\n            duration: 10000\n        }],\n        [PowerUpType.MULTIPLIER, {\n            type: PowerUpType.MULTIPLIER,\n            name: 'Score x2',\n            description: 'Doubles score for 30 seconds',\n            icon: '✨',\n            color: 0xFFD700,\n            rarity: 3,\n            duration: 30000,\n            power: 2\n        }],\n        [PowerUpType.FREEZE, {\n            type: PowerUpType.FREEZE,\n            name: 'Freeze',\n            description: 'Slows down time',\n            icon: '❄️',\n            color: 0x87CEEB,\n            rarity: 2,\n            duration: 15000,\n            power: 0.5\n        }],\n        [PowerUpType.LIGHTNING, {\n            type: PowerUpType.LIGHTNING,\n            name: 'Lightning',\n            description: 'Chain reaction destruction',\n            icon: '⚡',\n            color: 0xFFFF00,\n            rarity: 5,\n            power: 7\n        }],\n        [PowerUpType.MAGNET, {\n            type: PowerUpType.MAGNET,\n            name: 'Magnet',\n            description: 'Attracts matching bubbles',\n            icon: '🧲',\n            color: 0x808080,\n            rarity: 3,\n            duration: 20000,\n            radius: 150\n        }],\n        [PowerUpType.SHIELD, {\n            type: PowerUpType.SHIELD,\n            name: 'Shield',\n            description: 'Protection from danger',\n            icon: '🛡️',\n            color: 0x4169E1,\n            rarity: 4,\n            duration: 45000\n        }]\n    ]);\n    \n    constructor(scene: Scene, scoreEventManager?: ScoreEventManager) {\n        this.scene = scene;\n        this.scoreEventManager = scoreEventManager;\n        this.initializeEffects();\n    }\n    \n    private initializeEffects(): void {\n        // Register default power-up effects\n        this.registerEffect(new BombEffect(this.scene));\n        this.registerEffect(new MultiplierEffect(this.scene));\n        // Add more effects as needed\n    }\n    \n    public registerEffect(effect: IPowerUpEffect): void {\n        this.effects.set(effect.type, effect);\n    }\n    \n    public createPowerUp(type: PowerUpType, owner: 'player' | 'opponent', position?: { x: number; y: number }): PowerUp | null {\n        const config = this.POWER_UP_CONFIGS.get(type);\n        if (!config) return null;\n        \n        const powerUp: PowerUp = {\n            id: `${type}_${Date.now()}_${Math.random()}`,\n            type,\n            config,\n            active: false,\n            owner,\n            position\n        };\n        \n        this.powerUps.set(powerUp.id, powerUp);\n        return powerUp;\n    }\n    \n    public activatePowerUp(powerUpId: string, target?: any): boolean {\n        const powerUp = this.powerUps.get(powerUpId);\n        if (!powerUp || powerUp.active) return false;\n        \n        const effect = this.effects.get(powerUp.type);\n        if (!effect || !effect.canActivate(powerUp, target)) return false;\n        \n        // Mark as active\n        powerUp.active = true;\n        powerUp.activatedAt = Date.now();\n        \n        // Set expiration if duration-based\n        if (powerUp.config.duration) {\n            powerUp.expiresAt = Date.now() + powerUp.config.duration;\n        }\n        \n        // Add to active list\n        this.activePowerUps.push(powerUp);\n        \n        // Activate effect\n        effect.activate(powerUp, target);\n        \n        // Emit event for scoring\n        if (this.scoreEventManager) {\n            this.scoreEventManager.queueEvent({\n                type: ScoreEventType.POWER_UP,\n                baseValue: 100, // Base points for using power-up\n                position: powerUp.position || { x: 0, y: 0 },\n                isPlayer: powerUp.owner === 'player',\n                metadata: {\n                    powerUpType: powerUp.type,\n                    rarity: powerUp.config.rarity\n                }\n            });\n        }\n        \n        // Show activation feedback\n        this.showActivationFeedback(powerUp);\n        \n        return true;\n    }\n    \n    private showActivationFeedback(powerUp: PowerUp): void {\n        if (!powerUp.position) return;\n        \n        // Create activation visual\n        const flash = this.scene.add.graphics();\n        flash.fillStyle(powerUp.config.color, 0.5);\n        flash.fillCircle(0, 0, 50);\n        flash.setPosition(powerUp.position.x, powerUp.position.y);\n        flash.setDepth(1500);\n        flash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        // Animate\n        this.scene.tweens.add({\n            targets: flash,\n            alpha: 0,\n            scale: 3,\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                flash.destroy();\n            }\n        });\n        \n        // Show power-up name\n        const text = this.scene.add.text(\n            powerUp.position.x,\n            powerUp.position.y - 30,\n            powerUp.config.name.toUpperCase(),\n            {\n                fontSize: '28px',\n                color: '#FFFFFF',\n                fontFamily: 'Arial Black',\n                stroke: '#000000',\n                strokeThickness: 4\n            }\n        );\n        text.setOrigin(0.5);\n        text.setDepth(1501);\n        \n        this.scene.tweens.add({\n            targets: text,\n            y: text.y - 50,\n            alpha: 0,\n            scale: 1.5,\n            duration: 1000,\n            ease: 'Power2.easeOut',\n            onComplete: () => {\n                text.destroy();\n            }\n        });\n    }\n    \n    public update(delta: number): void {\n        const now = Date.now();\n        \n        // Update active power-ups\n        this.activePowerUps = this.activePowerUps.filter(powerUp => {\n            // Check expiration\n            if (powerUp.expiresAt && now >= powerUp.expiresAt) {\n                this.deactivatePowerUp(powerUp);\n                return false;\n            }\n            \n            // Update effect\n            const effect = this.effects.get(powerUp.type);\n            if (effect && effect.update) {\n                effect.update(powerUp, delta);\n            }\n            \n            return powerUp.active;\n        });\n    }\n    \n    private deactivatePowerUp(powerUp: PowerUp): void {\n        powerUp.active = false;\n        \n        const effect = this.effects.get(powerUp.type);\n        if (effect) {\n            effect.deactivate(powerUp);\n        }\n        \n        // Remove from active list\n        const index = this.activePowerUps.indexOf(powerUp);\n        if (index > -1) {\n            this.activePowerUps.splice(index, 1);\n        }\n    }\n    \n    public getActivePowerUps(owner?: 'player' | 'opponent'): PowerUp[] {\n        if (owner) {\n            return this.activePowerUps.filter(p => p.owner === owner);\n        }\n        return [...this.activePowerUps];\n    }\n    \n    public hasActivePowerUp(type: PowerUpType, owner?: 'player' | 'opponent'): boolean {\n        return this.activePowerUps.some(p => \n            p.type === type && (!owner || p.owner === owner)\n        );\n    }\n    \n    public reset(): void {\n        // Deactivate all power-ups\n        this.activePowerUps.forEach(powerUp => {\n            this.deactivatePowerUp(powerUp);\n        });\n        \n        this.powerUps.clear();\n        this.activePowerUps = [];\n    }\n    \n    public destroy(): void {\n        this.reset();\n        this.effects.clear();\n    }\n}\n\n// Example Power-Up Effects\n\nclass BombEffect implements IPowerUpEffect {\n    type = PowerUpType.BOMB;\n    private scene: Scene;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n    }\n    \n    canActivate(powerUp: PowerUp, target?: any): boolean {\n        return powerUp.position !== undefined;\n    }\n    \n    activate(powerUp: PowerUp, target?: any): void {\n        if (!powerUp.position) return;\n        \n        const radius = powerUp.config.radius || 100;\n        \n        // Create explosion visual\n        const explosion = this.scene.add.circle(\n            powerUp.position.x,\n            powerUp.position.y,\n            radius,\n            0xFF4500,\n            0.3\n        );\n        explosion.setDepth(1000);\n        \n        this.scene.tweens.add({\n            targets: explosion,\n            scale: { from: 0, to: 1 },\n            alpha: { from: 0.8, to: 0 },\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                explosion.destroy();\n            }\n        });\n        \n        // Emit event to destroy bubbles in radius\n        this.scene.events.emit('bomb-exploded', {\n            position: powerUp.position,\n            radius,\n            owner: powerUp.owner\n        });\n    }\n    \n    deactivate(powerUp: PowerUp): void {\n        // Bomb is instant, no deactivation needed\n    }\n}\n\nclass MultiplierEffect implements IPowerUpEffect {\n    type = PowerUpType.MULTIPLIER;\n    private scene: Scene;\n    private originalMultiplier: number = 1;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n    }\n    \n    canActivate(powerUp: PowerUp): boolean {\n        return true;\n    }\n    \n    activate(powerUp: PowerUp): void {\n        // Store original multiplier and apply new one\n        const multiplier = powerUp.config.power || 2;\n        \n        // Emit event to apply multiplier\n        this.scene.events.emit('score-multiplier-changed', {\n            multiplier,\n            owner: powerUp.owner\n        });\n        \n        // Show multiplier indicator\n        if (powerUp.owner === 'player') {\n            this.showMultiplierIndicator(multiplier);\n        }\n    }\n    \n    update(powerUp: PowerUp, delta: number): void {\n        // Could show remaining time\n        if (powerUp.expiresAt) {\n            const remaining = Math.max(0, powerUp.expiresAt - Date.now());\n            // Update UI with remaining time\n        }\n    }\n    \n    deactivate(powerUp: PowerUp): void {\n        // Reset multiplier\n        this.scene.events.emit('score-multiplier-changed', {\n            multiplier: 1,\n            owner: powerUp.owner\n        });\n    }\n    \n    private showMultiplierIndicator(multiplier: number): void {\n        const indicator = this.scene.add.text(\n            this.scene.cameras.main.centerX,\n            100,\n            `SCORE x${multiplier}`,\n            {\n                fontSize: '32px',\n                color: '#FFD700',\n                fontFamily: 'Arial Black',\n                stroke: '#000000',\n                strokeThickness: 4\n            }\n        );\n        indicator.setOrigin(0.5);\n        indicator.setDepth(1500);\n        \n        this.scene.tweens.add({\n            targets: indicator,\n            scale: { from: 0, to: 1.2 },\n            duration: 500,\n            ease: 'Back.easeOut',\n            yoyo: true,\n            hold: 1000,\n            onComplete: () => {\n                indicator.destroy();\n            }\n        });\n    }\n}","import { Scene } from 'phaser';\nimport { Bubble } from './Bubble';\nimport { PowerUpType } from '@/systems/powerups/PowerUpManager';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\n\n/**\n * Mystery Bubble that cycles through different power-ups\n * Shows the current power-up icon inside a semi-transparent bubble\n */\nexport class MysteryBubble extends Bubble {\n    private powerUpIcon!: Phaser.GameObjects.Text;\n    private currentPowerUp: PowerUpType;\n    private powerUpCycleTimer?: Phaser.Time.TimerEvent;\n    private glowEffect!: Phaser.GameObjects.Graphics;\n    private iconBg!: Phaser.GameObjects.Graphics;\n    \n    // Power-up rotation sequence\n    private powerUpSequence: PowerUpType[] = [\n        PowerUpType.RAINBOW,\n        PowerUpType.BOMB,\n        PowerUpType.LIGHTNING,\n        PowerUpType.FREEZE,\n        PowerUpType.LASER,\n        PowerUpType.MULTIPLIER\n    ];\n    private sequenceIndex: number = 0;\n    \n    // Power-up icons and colors\n    private powerUpIcons: Record<PowerUpType, { icon: string; color: number }> = {\n        [PowerUpType.RAINBOW]: { icon: '🌈', color: 0xFF69B4 },\n        [PowerUpType.BOMB]: { icon: '💣', color: 0xFF4500 },\n        [PowerUpType.LIGHTNING]: { icon: '⚡', color: 0xFFD700 },\n        [PowerUpType.FREEZE]: { icon: '❄️', color: 0x00CED1 },\n        [PowerUpType.LASER]: { icon: '🎯', color: 0x00FF00 },\n        [PowerUpType.MULTIPLIER]: { icon: '✨', color: 0x9370DB },\n        [PowerUpType.SHIELD]: { icon: '🛡️', color: 0x4169E1 },\n        [PowerUpType.MAGNET]: { icon: '🧲', color: 0xDC143C }\n    };\n    \n    constructor(scene: Scene, x: number, y: number) {\n        // Use random color as base\n        super(scene, x, y, Bubble.getRandomColor());\n        \n        // Start with a random power-up\n        this.sequenceIndex = Math.floor(Math.random() * this.powerUpSequence.length);\n        this.currentPowerUp = this.powerUpSequence[this.sequenceIndex];\n        \n        this.createMysteryVisuals();\n        this.startPowerUpCycle();\n    }\n    \n    private createMysteryVisuals(): void {\n        // Make base bubble semi-transparent so we can see the power-up inside\n        const bubbleSprite = this.list[0] as Phaser.GameObjects.Arc;\n        if (bubbleSprite) {\n            bubbleSprite.setAlpha(0.4); // Semi-transparent\n        }\n        \n        // Create a subtle glow effect\n        this.glowEffect = this.scene.add.graphics();\n        this.updateGlowEffect();\n        this.addAt(this.glowEffect, 0); // Add behind bubble\n        \n        // Create icon background circle for better visibility - LARGER\n        this.iconBg = this.scene.add.graphics();\n        this.iconBg.fillStyle(0x000000, 0.3);\n        this.iconBg.fillCircle(0, 0, 10 * HD_SCALE);\n        this.add(this.iconBg);\n        \n        // Create power-up icon - MUCH LARGER for visibility\n        this.powerUpIcon = this.scene.add.text(0, 0, '', {\n            fontSize: `${14 * HD_SCALE}px`,\n            fontFamily: 'Arial'\n        });\n        this.powerUpIcon.setOrigin(0.5);\n        this.add(this.powerUpIcon);\n        \n        // Update to show current power-up\n        this.updatePowerUpDisplay();\n        \n        // Add subtle pulse animation\n        this.scene.tweens.add({\n            targets: [this.powerUpIcon, this.iconBg],\n            scale: { from: 0.9, to: 1.1 },\n            duration: 1500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n    }\n    \n    private updateGlowEffect(): void {\n        if (!this.glowEffect) return;\n        \n        this.glowEffect.clear();\n        const config = this.powerUpIcons[this.currentPowerUp];\n        \n        // Create gradient glow - LARGER for bigger icon\n        this.glowEffect.fillStyle(config.color, 0.2);\n        this.glowEffect.fillCircle(0, 0, 14 * HD_SCALE);\n        this.glowEffect.fillStyle(config.color, 0.1);\n        this.glowEffect.fillCircle(0, 0, 18 * HD_SCALE);\n    }\n    \n    private updatePowerUpDisplay(): void {\n        const config = this.powerUpIcons[this.currentPowerUp];\n        this.powerUpIcon.setText(config.icon);\n        \n        // Update glow color\n        this.updateGlowEffect();\n        \n        // Add a small pop animation when changing\n        this.scene.tweens.add({\n            targets: this.powerUpIcon,\n            scale: { from: 1.3, to: 1 },\n            duration: 300,\n            ease: 'Back.easeOut'\n        });\n    }\n    \n    private startPowerUpCycle(): void {\n        // Change power-up every 2-3 seconds\n        const cycleFunction = () => {\n            this.cyclePowerUp();\n            // Schedule next cycle\n            this.powerUpCycleTimer = this.scene.time.delayedCall(\n                Phaser.Math.Between(2000, 3000),\n                cycleFunction\n            );\n        };\n        \n        // Start the first cycle\n        this.powerUpCycleTimer = this.scene.time.delayedCall(\n            Phaser.Math.Between(2000, 3000),\n            cycleFunction\n        );\n    }\n    \n    private cyclePowerUp(): void {\n        // Move to next power-up in sequence\n        this.sequenceIndex = (this.sequenceIndex + 1) % this.powerUpSequence.length;\n        this.currentPowerUp = this.powerUpSequence[this.sequenceIndex] || PowerUpType.RAINBOW;\n        this.updatePowerUpDisplay();\n    }\n    \n    /**\n     * Get the current power-up type\n     */\n    public getCurrentPowerUp(): PowerUpType {\n        return this.currentPowerUp;\n    }\n    \n    /**\n     * Override to identify as mystery bubble\n     */\n    public isMysteryBubble(): boolean {\n        return true;\n    }\n    \n    /**\n     * Collect power-up when bubble is destroyed\n     */\n    public collectPowerUp(isPlayerShot: boolean = true): void {\n        // console.log(`Collecting power-up: ${this.currentPowerUp} at position (${this.x}, ${this.y}) for ${isPlayerShot ? 'player' : 'opponent'}`);\n        \n        // Create visual feedback at bubble position\n        const config = this.powerUpIcons[this.currentPowerUp];\n        \n        // Create large icon that floats up and fades - LARGER\n        const floatingIcon = this.scene.add.text(this.x, this.y, config.icon, {\n            fontSize: `${24 * HD_SCALE}px`,\n            fontFamily: 'Arial'\n        });\n        floatingIcon.setOrigin(0.5);\n        floatingIcon.setDepth(Z_LAYERS.FLOATING_UI);\n        \n        // Add \"POWER-UP!\" text - LARGER\n        const powerUpText = this.scene.add.text(this.x, this.y + (15 * HD_SCALE), 'POWER-UP!', {\n            fontSize: `${12 * HD_SCALE}px`,\n            fontFamily: 'Arial Black',\n            color: '#FFFFFF',\n            stroke: '#000000',\n            strokeThickness: 2 * HD_SCALE\n        });\n        powerUpText.setOrigin(0.5);\n        powerUpText.setDepth(Z_LAYERS.FLOATING_UI);\n        \n        // Animate both elements\n        this.scene.tweens.add({\n            targets: [floatingIcon, powerUpText],\n            y: this.y - (25 * HD_SCALE),\n            alpha: 0,\n            scale: 1.5,\n            duration: 1000,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                floatingIcon.destroy();\n                powerUpText.destroy();\n            }\n        });\n        \n        // Flash effect\n        const flash = this.scene.add.circle(this.x, this.y, 15 * HD_SCALE, config.color, 0.5);\n        flash.setDepth(Z_LAYERS.FLOATING_UI - 1);\n        \n        this.scene.tweens.add({\n            targets: flash,\n            scale: 2,\n            alpha: 0,\n            duration: 400,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                flash.destroy();\n            }\n        });\n        \n        // Emit event to add power-up to inventory\n        // Owner is determined by who shot the bubble that caused the match\n        const owner = isPlayerShot ? 'player' : 'opponent';\n        // console.log(`Emitting power-up-collected event: type=${this.currentPowerUp}, owner=${owner}`);\n        \n        this.scene.events.emit('power-up-collected', {\n            type: this.currentPowerUp,\n            x: this.x,\n            y: this.y,\n            owner: owner\n        });\n    }\n    \n    public override destroy(): void {\n        // console.log('MysteryBubble destroy called, visible:', this.visible);\n        \n        if (this.powerUpCycleTimer) {\n            this.powerUpCycleTimer.destroy();\n        }\n        \n        // Note: Power-ups are collected through MatchDetectionSystem now\n        // This destroy method is called when returning to pool, not when collecting\n        \n        super.destroy();\n    }\n}","import { ArenaZone, BubbleColor } from '@/types/ArenaTypes';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\nimport { Bubble } from './Bubble';\nimport { PowerUpType } from '@/systems/powerups/PowerUpManager';\n\n// Arsenal slot interface for integrated weapon system\ninterface ArsenalSlot {\n    container: Phaser.GameObjects.Container;\n    background: Phaser.GameObjects.Graphics;\n    icon: Phaser.GameObjects.Text;\n    countText: Phaser.GameObjects.Text;\n    energyConduit?: Phaser.GameObjects.Graphics;\n    position: { x: number, y: number };\n    powerUpType: PowerUpType | undefined;\n    count: number;\n    isActive: boolean;\n    cooldownOverlay?: Phaser.GameObjects.Graphics;\n    progressArc?: Phaser.GameObjects.Graphics;\n}\n\n/**\n * EXCEPTIONAL LAUNCHER - Premium Mobile-First Game Experience\n * \n * A sophisticated, unified launcher optimized for mobile devices (375x667px).\n * Every detail is crafted for mobile clarity, accessibility, and engaging gameplay.\n * \n * MOBILE-FIRST DESIGN PRINCIPLES:\n * - INTEGRATED: Uses existing BUBBLE_POSITION_Y (-35) for loaded bubble\n * - UNIFIED: Uses existing QUEUE_POSITION_Y (5) for next bubble preview\n * - ACCESSIBLE: 120px touch areas exceed Apple/Android minimums (44px/48dp)\n * - CLEAR: Visual hierarchy clearly distinguishes loaded vs next bubble\n * - OPTIMIZED: Larger text, thicker borders, enhanced contrast for mobile\n * - ENGAGING: Premium animations and feedback designed for mobile sessions\n * \n * VISUAL HIERARCHY:\n * - TOP (-35px): Main firing chamber with loaded bubble (ready to shoot)\n * - BOTTOM (5px): Integrated queue chamber with next bubble (preview)\n * - UNIFIED DESIGN: Single cohesive launcher body connects both chambers\n * \n * MOBILE UX FEATURES:\n * - 120px touch areas for excellent mobile accessibility\n * - Enhanced visual feedback with satisfying animations\n * - Clear state indicators (idle, aiming, charging, ready, cooldown)\n * - Premium mobile interactions with haptic-like feedback\n * - Optimized performance for mobile devices\n */\nexport class Launcher extends Phaser.GameObjects.Container {\n    // === CORE COMPONENTS ===\n    private launcherPlatform?: Phaser.GameObjects.Container;\n    private bubbleChamber?: Phaser.GameObjects.Container;\n    private queuePanel?: Phaser.GameObjects.Container;\n    private effectsLayer?: Phaser.GameObjects.Container;\n    \n    // === VISUAL ELEMENTS ===\n    private platformGraphics: Phaser.GameObjects.Graphics | undefined;\n    private chamberGraphics: Phaser.GameObjects.Graphics | undefined;\n    private queueBackground: Phaser.GameObjects.Graphics | undefined;\n    private queueLabel?: Phaser.GameObjects.Text;\n    private glowEffect: Phaser.GameObjects.Graphics | undefined;\n    \n    // === ENHANCED UX ELEMENTS ===\n    private stateIndicator: Phaser.GameObjects.Graphics | undefined;\n    private readyIndicator: Phaser.GameObjects.Arc | undefined;\n    private queueContainer?: Phaser.GameObjects.Container;\n    private nextBubbleFrame: Phaser.GameObjects.Graphics | undefined;\n    private nextBubbleGraphics: Phaser.GameObjects.Graphics | undefined;\n    private secondBubbleGraphics: Phaser.GameObjects.Graphics | undefined;\n    \n    // === ARSENAL INTEGRATION ===\n    private arsenalSlots: ArsenalSlot[] = [];\n    private weaponRing?: Phaser.GameObjects.Container;\n    private energyConduits: Phaser.GameObjects.Graphics | undefined;\n    private activePowerUp?: PowerUpType;\n    private arsenalContainer?: Phaser.GameObjects.Container;\n    \n    // === ANIMATION SYSTEMS ===\n    private idleAnimation?: Phaser.Tweens.Tween;\n    private chargingTween?: Phaser.Tweens.Tween;\n    private particles?: Phaser.GameObjects.Particles.ParticleEmitter;\n    \n    // === STATE MANAGEMENT ===\n    private zone: ArenaZone;\n    private currentAngle: number = 0;\n    private loadedBubble: Bubble | undefined;\n    private nextBubbleColors: BubbleColor[] = [];\n    private currentTheme: any;\n    private isAiming: boolean = false;\n    private isOpponent: boolean;\n    \n    // === ENHANCED STATE ===\n    private launcherState: 'idle' | 'aiming' | 'charging' | 'ready' | 'cooldown' = 'idle';\n    private powerLevel: number = 0;\n    \n    // === POSITIONING CONSTANTS ===\n    private readonly BUBBLE_POSITION_Y: number;\n    private readonly QUEUE_POSITION_Y: number;\n    \n    // === ARSENAL POSITIONING ===\n    // Better spacing: more separation between slots\n    private readonly ARSENAL_POSITIONS_PLAYER = [\n        { x: 70 * HD_SCALE, y: -35 * HD_SCALE },     // First slot with good separation\n        { x: 110 * HD_SCALE, y: -35 * HD_SCALE },    // 40 unit spacing between slots\n        { x: 150 * HD_SCALE, y: -35 * HD_SCALE }     // More spread out\n    ];\n    private readonly ARSENAL_POSITIONS_OPPONENT = [\n        { x: -70 * HD_SCALE, y: -35 * HD_SCALE },    // Mirror positions for opponent\n        { x: -110 * HD_SCALE, y: -35 * HD_SCALE },\n        { x: -150 * HD_SCALE, y: -35 * HD_SCALE }\n    ];\n    private readonly SLOT_SIZE = 25 * HD_SCALE;  // Further reduced for better spacing\n    \n    // Power-up icons\n    private powerUpIcons: Record<PowerUpType, string> = {\n        [PowerUpType.RAINBOW]: '🌈',\n        [PowerUpType.BOMB]: '💣',\n        [PowerUpType.LIGHTNING]: '⚡',\n        [PowerUpType.FREEZE]: '❄️',\n        [PowerUpType.LASER]: '🎯',\n        [PowerUpType.MULTIPLIER]: '✨',\n        [PowerUpType.SHIELD]: '🛡️',\n        [PowerUpType.MAGNET]: '🧲'\n    };\n\n    constructor(scene: Phaser.Scene, x: number, y: number, zone: ArenaZone) {\n        super(scene, x, y);\n        \n        this.zone = zone;\n        this.isOpponent = (zone === ArenaZone.OPPONENT);\n        \n        // MOBILE-FIRST POSITIONING: Optimized for 375x667px mobile screens\n        this.BUBBLE_POSITION_Y = -28 * HD_SCALE;  // Main chamber position\n        this.QUEUE_POSITION_Y = 25 * HD_SCALE;     // Queue loading chamber position\n        \n        if (this.isOpponent) {\n            this.currentAngle = 90;\n            // Flip the entire launcher for opponent\n            this.setScale(1, -1);\n        } else {\n            this.currentAngle = 270;\n        }\n        \n        // Build the exceptional launcher\n        this.createExceptionalLauncher();\n        \n        // Create integrated arsenal for both player and opponent\n        this.createIntegratedArsenal();\n        \n        this.setDepth(Z_LAYERS.LAUNCHERS);\n        scene.add.existing(this);\n        \n        // Initialize with accessible theme\n        this.updateTheme(BubbleColor.BLUE);\n        this.startEnhancedIdleAnimations();\n        \n        // Setup arsenal event listeners\n        this.setupArsenalListeners();\n        \n        // Add touch area for better mobile interaction\n        this.setupMobileTouchArea();\n    }\n\n    /**\n     * Creates the premium launcher experience with unified design\n     */\n    private createExceptionalLauncher(): void {\n        // Create in perfect hierarchy order\n        this.createLauncherPlatform();\n        this.createBubbleChamber();\n        this.createEnhancedQueueSystem();  // ENHANCED: More visible queue system\n        this.createStateIndicators();       // NEW: Visual state feedback\n        this.createEffectsLayer();\n        \n        // Add all components with perfect layering\n        this.add([\n            this.launcherPlatform!,\n            this.bubbleChamber!,\n            this.queueContainer!,\n            this.effectsLayer!\n        ]);\n    }\n\n    /**\n     * Creates the sophisticated launcher platform\n     */\n    private createLauncherPlatform(): void {\n        this.launcherPlatform = this.scene.add.container(0, 0);\n        this.platformGraphics = this.scene.add.graphics();\n        this.launcherPlatform.add(this.platformGraphics);\n    }\n\n    /**\n     * Creates the premium bubble chamber with perfect positioning\n     */\n    private createBubbleChamber(): void {\n        this.bubbleChamber = this.scene.add.container(0, this.BUBBLE_POSITION_Y);\n        this.chamberGraphics = this.scene.add.graphics();\n        this.glowEffect = this.scene.add.graphics();\n        \n        this.bubbleChamber.add([this.glowEffect, this.chamberGraphics]);\n    }\n\n    /**\n     * ENHANCED: Mobile-first integrated queue system using proper positioning\n     */\n    private createEnhancedQueueSystem(): void {\n        // Use the defined QUEUE_POSITION_Y properly - no arbitrary offset\n        this.queueContainer = this.scene.add.container(0, this.QUEUE_POSITION_Y);\n        \n        // Enhanced queue background with mobile-optimized design\n        this.queueBackground = this.scene.add.graphics();\n        \n        // Next bubble frame indicator with better mobile visibility\n        this.nextBubbleFrame = this.scene.add.graphics();\n        \n        this.queueContainer.add([this.queueBackground, this.nextBubbleFrame]);\n        \n        // No rotation on the whole container - bubbles will have their own animations\n    }\n\n    /**\n     * NEW: Creates visual state indicators for better UX\n     */\n    private createStateIndicators(): void {\n        // State indicator as graphics for drawing\n        this.stateIndicator = this.scene.add.graphics();\n        this.add(this.stateIndicator);\n        \n        // Ready indicator ring around chamber - no default color\n        this.readyIndicator = this.scene.add.circle(0, this.BUBBLE_POSITION_Y, 28 * HD_SCALE, 0x000000, 0);\n        this.readyIndicator.setStrokeStyle(2 * HD_SCALE, 0x000000, 0);\n        this.readyIndicator.setVisible(false);\n        this.add(this.readyIndicator);\n    }\n\n    /**\n     * Creates effects layer for particles and animations\n     */\n    private createEffectsLayer(): void {\n        this.effectsLayer = this.scene.add.container(0, 0);\n    }\n\n    /**\n     * Renders all visual components with unified design\n     */\n    private updateAllVisuals(): void {\n        this.renderLauncherPlatform();\n        this.renderBubbleChamber();\n        this.renderEnhancedQueue();\n        this.renderStateIndicators();\n        this.renderGlowEffects();\n    }\n\n    /**\n     * Renders the sophisticated launcher platform\n     */\n    private renderLauncherPlatform(): void {\n        if (!this.platformGraphics || !this.currentTheme) return;\n        \n        this.platformGraphics.clear();\n        \n        // Create a compact integrated launcher design\n        const topY = this.BUBBLE_POSITION_Y;\n        const bottomY = this.QUEUE_POSITION_Y;\n        const height = Math.abs(bottomY - topY);\n        \n        // Energy flow tube connecting chambers\n        const columnWidth = 24 * HD_SCALE;\n        \n        // Draw energy conduit\n        this.platformGraphics.fillGradientStyle(\n            this.currentTheme.platform.top,\n            this.currentTheme.platform.top,\n            this.currentTheme.platform.bottom,\n            this.currentTheme.platform.bottom,\n            1, 1, 0.7, 0.7\n        );\n        this.platformGraphics.fillRoundedRect(\n            -columnWidth/2, \n            topY + (14 * HD_SCALE), \n            columnWidth, \n            height - (22 * HD_SCALE), \n            8 * HD_SCALE\n        );\n        \n        // Energy flow lines\n        this.platformGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.chamber.highlight, 0.3);\n        this.platformGraphics.lineBetween(-columnWidth/3, topY + 20 * HD_SCALE, -columnWidth/3, bottomY - 10 * HD_SCALE);\n        this.platformGraphics.lineBetween(columnWidth/3, topY + 20 * HD_SCALE, columnWidth/3, bottomY - 10 * HD_SCALE);\n        \n        // Subtle border\n        this.platformGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.platform.rim, 0.3);\n        this.platformGraphics.strokeRoundedRect(\n            -columnWidth/2, \n            topY + (14 * HD_SCALE), \n            columnWidth, \n            height - (22 * HD_SCALE), \n            8 * HD_SCALE\n        );\n    }\n\n    /**\n     * Renders the premium bubble chamber with perfect depth\n     */\n    private renderBubbleChamber(): void {\n        if (!this.chamberGraphics || !this.currentTheme) return;\n        \n        this.chamberGraphics.clear();\n        \n        // Chamber - more prominent than queue\n        const chamberRadius = 24 * HD_SCALE;\n        const innerRadius = 16 * HD_SCALE;\n        \n        // Gradient background\n        this.chamberGraphics.fillGradientStyle(\n            this.currentTheme.chamber.outerTop,\n            this.currentTheme.chamber.outerTop,\n            this.currentTheme.chamber.outerBottom,\n            this.currentTheme.chamber.outerBottom,\n            1, 1, 0.9, 0.9\n        );\n        this.chamberGraphics.fillCircle(0, 0, chamberRadius);\n        \n        // Strong rim for the chamber\n        this.chamberGraphics.lineStyle(3 * HD_SCALE, this.currentTheme.chamber.rim, 1);\n        this.chamberGraphics.strokeCircle(0, 0, chamberRadius);\n        \n        // Inner chamber where bubble sits\n        this.chamberGraphics.fillStyle(0x0a0a0a, 0.9);\n        this.chamberGraphics.fillCircle(0, 0, innerRadius);\n        \n        // Inner rim accent\n        this.chamberGraphics.lineStyle(2 * HD_SCALE, this.currentTheme.chamber.innerRim, 0.8);\n        this.chamberGraphics.strokeCircle(0, 0, innerRadius);\n        \n        // Power indicator ring\n        this.chamberGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.chamber.highlight, 0.5);\n        this.chamberGraphics.strokeCircle(0, 0, innerRadius + (3 * HD_SCALE));\n        \n        // Highlight dot\n        this.chamberGraphics.fillStyle(this.currentTheme.chamber.highlight, 0.4);\n        this.chamberGraphics.fillCircle(-5 * HD_SCALE, -5 * HD_SCALE, 3 * HD_SCALE);\n    }\n\n    /**\n     * MOBILE-FIRST: Renders integrated queue with optimal mobile visibility\n     */\n    private renderEnhancedQueue(): void {\n        if (!this.queueBackground || !this.currentTheme) return;\n        \n        this.queueBackground.clear();\n        \n        // Create a circular loading chamber similar to main chamber\n        const queueRadius = 20 * HD_SCALE;\n        const innerRadius = 14 * HD_SCALE;\n        \n        // Gradient background matching launcher style\n        this.queueBackground.fillGradientStyle(\n            this.currentTheme.chamber.outerTop,\n            this.currentTheme.chamber.outerTop,\n            this.currentTheme.chamber.outerBottom,\n            this.currentTheme.chamber.outerBottom,\n            0.8, 0.8, 0.6, 0.6\n        );\n        this.queueBackground.fillCircle(0, 0, queueRadius);\n        \n        // Rim matching launcher theme\n        this.queueBackground.lineStyle(2.5 * HD_SCALE, this.currentTheme.chamber.rim, 0.8);\n        this.queueBackground.strokeCircle(0, 0, queueRadius);\n        \n        // Inner chamber where bubbles queue\n        this.queueBackground.fillStyle(0x0a0a0a, 0.7);\n        this.queueBackground.fillCircle(0, 0, innerRadius);\n        \n        // Inner rim accent\n        this.queueBackground.lineStyle(1.5 * HD_SCALE, this.currentTheme.chamber.innerRim, 0.6);\n        this.queueBackground.strokeCircle(0, 0, innerRadius);\n        \n        // Loading indicator arc (animated)\n        this.queueBackground.lineStyle(1 * HD_SCALE, this.currentTheme.chamber.highlight, 0.4);\n        this.queueBackground.strokeCircle(0, 0, innerRadius + (2 * HD_SCALE));\n        \n        // Small highlight dots for depth\n        this.queueBackground.fillStyle(this.currentTheme.chamber.highlight, 0.3);\n        this.queueBackground.fillCircle(-4 * HD_SCALE, -4 * HD_SCALE, 2 * HD_SCALE);\n        \n        // Render queue bubbles\n        this.renderEnhancedQueueBubbles();\n    }\n\n    /**\n     * NEW: Renders state indicators for better game feel\n     */\n    private renderStateIndicators(): void {\n        if (!this.readyIndicator) return;\n        \n        // Don't show indicator if we don't have a theme yet\n        if (!this.currentTheme) {\n            this.readyIndicator.setVisible(false);\n            return;\n        }\n        \n        // Update ready indicator based on state - using theme colors\n        switch (this.launcherState) {\n            case 'ready':\n                this.readyIndicator.setVisible(true);\n                // Use the current bubble's theme color instead of hardcoded green\n                this.readyIndicator.setStrokeStyle(2, this.currentTheme.platform.rim, 0.8);\n                break;\n            case 'aiming':\n                this.readyIndicator.setVisible(true);\n                // Use accent color for aiming\n                this.readyIndicator.setStrokeStyle(2, this.currentTheme.glow.aiming, 0.6);\n                break;\n            case 'charging':\n                this.readyIndicator.setVisible(true);\n                // Use pulse color for charging\n                this.readyIndicator.setStrokeStyle(3, this.currentTheme.glow.pulse, 0.9);\n                break;\n            default:\n                this.readyIndicator.setVisible(false);\n                break;\n        }\n    }\n\n    /**\n     * MOBILE-OPTIMIZED: Renders queue bubbles side by side\n     */\n    private renderEnhancedQueueBubbles(): void {\n        if (!this.queueBackground || !this.queueContainer) return;\n        \n        // Render bubbles side by side horizontally\n        if (this.nextBubbleColors.length > 0 && this.nextBubbleColors[0]) {\n            this.createNextBubble(this.nextBubbleColors[0]);\n        }\n        \n        if (this.nextBubbleColors.length > 1 && this.nextBubbleColors[1]) {\n            this.createSecondBubble(this.nextBubbleColors[1]);\n        }\n    }\n    \n    /**\n     * Create the main next bubble\n     */\n    private createNextBubble(color: BubbleColor): void {\n        if (!this.queueContainer) return;\n        \n        // Clear any existing graphics first\n        if (this.nextBubbleGraphics) {\n            this.nextBubbleGraphics.destroy();\n            this.nextBubbleGraphics = undefined;\n        }\n        \n        const bubbleGraphics = this.scene.add.graphics();\n        this.queueContainer.add(bubbleGraphics);\n        this.nextBubbleGraphics = bubbleGraphics;\n        \n        // Center position for main queue bubble\n        bubbleGraphics.x = 0;\n        bubbleGraphics.y = 0;\n        \n        // Draw the next bubble - larger, ready to move up\n        const radius = 11 * HD_SCALE;  // Good size for next bubble\n        this.drawQueueBubble(bubbleGraphics, 0, 0, radius, 1, color);\n        \n        // Set initial scale to 0 for animation\n        bubbleGraphics.setScale(0);\n        \n        // Animate appearance with rotation for loading effect\n        this.scene.tweens.add({\n            targets: bubbleGraphics,\n            scale: 1,\n            rotation: Math.PI * 2,\n            duration: 400,\n            ease: 'Back.easeOut'\n        });\n        \n        // Add pulsing effect to show it's ready\n        this.scene.tweens.add({\n            targets: bubbleGraphics,\n            scale: { from: 1, to: 1.08 },\n            duration: 1200,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.InOut',\n            delay: 400\n        });\n    }\n    \n    /**\n     * Create the small second bubble\n     */\n    private createSecondBubble(color: BubbleColor): void {\n        if (!this.queueContainer) return;\n        \n        // Clear any existing graphics first\n        if (this.secondBubbleGraphics) {\n            this.secondBubbleGraphics.destroy();\n            this.secondBubbleGraphics = undefined;\n        }\n        \n        const bubbleGraphics = this.scene.add.graphics();\n        // Add behind the main bubble\n        this.queueContainer.addAt(bubbleGraphics, 0);\n        this.secondBubbleGraphics = bubbleGraphics;\n        \n        // Position offset to the side - visible but smaller\n        bubbleGraphics.x = 9 * HD_SCALE;\n        bubbleGraphics.y = 7 * HD_SCALE;\n        \n        // Draw the small bubble - smaller, waiting its turn\n        const radius = 7 * HD_SCALE;  // Smaller bubble but visible\n        this.drawQueueBubble(bubbleGraphics, 0, 0, radius, 0.7, color);\n        \n        // Set initial scale to 0 for animation\n        bubbleGraphics.setScale(0);\n        \n        // Animate appearance\n        this.scene.tweens.add({\n            targets: bubbleGraphics,\n            scale: 0.65,  // Keep it smaller\n            duration: 400,\n            ease: 'Back.easeOut'\n        });\n        \n        // Gentle floating motion for dynamic feel\n        this.scene.tweens.add({\n            targets: bubbleGraphics,\n            y: bubbleGraphics.y - 1.5 * HD_SCALE,\n            duration: 2500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.InOut',\n            delay: 200\n        });\n    }\n    \n    /**\n     * Reset all queue bubbles\n     */\n    private resetQueueBubbles(): void {\n        if (this.nextBubbleGraphics) {\n            this.scene.tweens.add({\n                targets: this.nextBubbleGraphics,\n                alpha: 0,\n                scale: 0.5,\n                duration: 150,\n                ease: 'Power2.In',\n                onComplete: () => {\n                    this.nextBubbleGraphics?.destroy();\n                    this.nextBubbleGraphics = undefined;\n                }\n            });\n        }\n        \n        if (this.secondBubbleGraphics) {\n            this.scene.tweens.add({\n                targets: this.secondBubbleGraphics,\n                alpha: 0,\n                scale: 0.5,\n                duration: 150,\n                ease: 'Power2.In',\n                onComplete: () => {\n                    this.secondBubbleGraphics?.destroy();\n                    this.secondBubbleGraphics = undefined;\n                }\n            });\n        }\n    }\n    \n    /**\n     * Draw queue bubble on graphics object\n     */\n    private drawQueueBubble(graphics: Phaser.GameObjects.Graphics, x: number, y: number, radius: number, alpha: number, color: BubbleColor): void {\n        const bubbleTheme = this.getBubbleColors(color);\n        \n        // Main bubble fill with correct color\n        graphics.fillStyle(bubbleTheme.primary);\n        graphics.fillCircle(x, y, radius);\n        \n        // Strong border\n        graphics.lineStyle(2 * HD_SCALE, bubbleTheme.dark, 0.9);\n        graphics.strokeCircle(x, y, radius);\n        \n        // Highlight spot\n        graphics.fillStyle(bubbleTheme.light);\n        graphics.fillCircle(x - radius * 0.3, y - radius * 0.3, radius * 0.35);\n        \n        // Inner glow\n        graphics.fillStyle(bubbleTheme.accent, 0.4);\n        graphics.fillCircle(x, y, radius * 0.6);\n        \n        // Set overall alpha\n        graphics.setAlpha(alpha);\n    }\n    \n    /**\n     * Draw small queue bubble on graphics object\n     */\n    private drawSmallQueueBubble(graphics: Phaser.GameObjects.Graphics, x: number, y: number, radius: number, alpha: number, color: BubbleColor): void {\n        // Just use the same method as the main bubble for consistency\n        this.drawQueueBubble(graphics, x, y, radius, alpha, color);\n    }\n\n\n    /**\n     * Renders premium glow effects\n     */\n    private renderGlowEffects(): void {\n        if (!this.glowEffect || !this.currentTheme) return;\n        \n        this.glowEffect.clear();\n        \n        if (this.isAiming) {\n            // Aiming glow effect\n            this.glowEffect.fillStyle(this.currentTheme.glow.aiming, 0.3);\n            this.glowEffect.fillCircle(0, 0, 30 * HD_SCALE);\n            \n            // Pulsing outer glow\n            this.glowEffect.fillStyle(this.currentTheme.glow.pulse, 0.1);\n            this.glowEffect.fillCircle(0, 0, 35 * HD_SCALE);\n        }\n        \n        if (this.loadedBubble) {\n            // Loaded bubble ambient glow\n            this.glowEffect.fillStyle(this.currentTheme.glow.loaded, 0.2);\n            this.glowEffect.fillCircle(0, 0, 25 * HD_SCALE);\n        }\n    }\n\n    /**\n     * Gets premium theme colors for unified design\n     */\n    private getExceptionalTheme(color: BubbleColor): any {\n        const base = this.getBubbleColors(color);\n        \n        return {\n            platform: {\n                top: base.secondary,\n                bottom: this.darkenColor(base.secondary, 30),\n                rim: base.primary,\n                highlight: base.light,\n                shadow: this.darkenColor(base.dark, 20)\n            },\n            chamber: {\n                outerTop: base.secondary,\n                outerBottom: this.darkenColor(base.secondary, 25),\n                innerTop: this.darkenColor(base.dark, 10),\n                innerBottom: this.darkenColor(base.dark, 40),\n                rim: base.primary,\n                innerRim: base.accent,\n                highlight: base.light,\n                depth: this.darkenColor(base.dark, 30)\n            },\n            queue: {\n                panelTop: 0x2A2A2A,\n                panelBottom: 0x1A1A1A,\n                panelBorder: base.primary,\n                panelGlow: base.light\n            },\n            glow: {\n                aiming: base.primary,\n                pulse: base.light,\n                loaded: base.accent\n            }\n        };\n    }\n\n    /**\n     * Premium color palette for exceptional visual quality\n     */\n    private getBubbleColors(color: BubbleColor): any {\n        switch(color) {\n            case BubbleColor.RED:\n                return {\n                    primary: 0xFF4757,\n                    secondary: 0xE84142,\n                    accent: 0xFF6B7A,\n                    dark: 0xB91E28,\n                    light: 0xFF9CAA\n                };\n            case BubbleColor.BLUE:\n                return {\n                    primary: 0x3742FA,\n                    secondary: 0x2F3542,\n                    accent: 0x5E72FF,\n                    dark: 0x1E2745,\n                    light: 0x8A9CFF\n                };\n            case BubbleColor.GREEN:\n                return {\n                    primary: 0x2ED573,\n                    secondary: 0x1B9F47,\n                    accent: 0x5FE085,\n                    dark: 0x146B34,\n                    light: 0x8EEB9B\n                };\n            case BubbleColor.YELLOW:\n                return {\n                    primary: 0xFFD32A,\n                    secondary: 0xFFB800,\n                    accent: 0xFFDE4D,\n                    dark: 0xCC8F00,\n                    light: 0xFFE870\n                };\n            case BubbleColor.PURPLE: // Actually PINK/MAGENTA (0xff00ff)\n                return {\n                    primary: 0xFF00FF,  // Bright magenta/pink\n                    secondary: 0xE600E6,\n                    accent: 0xFF66FF,\n                    dark: 0xCC00CC,\n                    light: 0xFF99FF\n                };\n            default: // Cyan\n                return {\n                    primary: 0x00D4FF,\n                    secondary: 0x0097CC,\n                    accent: 0x33DDFF,\n                    dark: 0x006B99,\n                    light: 0x66E6FF\n                };\n        }\n    }\n\n    /**\n     * Utility: Darkens a color by percentage\n     */\n    private darkenColor(color: number, percent: number): number {\n        const r = (color >> 16) & 0xFF;\n        const g = (color >> 8) & 0xFF;\n        const b = color & 0xFF;\n        \n        const factor = (100 - percent) / 100;\n        \n        return ((r * factor) << 16) | ((g * factor) << 8) | (b * factor);\n    }\n\n    /**\n     * Updates theme with unified design consistency\n     */\n    private updateTheme(color: BubbleColor): void {\n        // Store current scale before updating\n        const currentScaleY = this.scaleY;\n        \n        this.currentTheme = this.getExceptionalTheme(color);\n        this.updateAllVisuals();\n        \n        // Restore scale after updating visuals\n        if (this.isOpponent) {\n            this.setScale(1, -1);\n        }\n    }\n\n    /**\n     * MOBILE-OPTIMIZED: Enhanced idle animations with clear visual hierarchy\n     */\n    private startEnhancedIdleAnimations(): void {\n        // Optimized breathing effect - more visible on mobile without performance impact\n        this.idleAnimation = this.scene.tweens.add({\n            targets: this.bubbleChamber,\n            scaleX: { from: 1, to: 1.02 },   // Slightly more visible\n            scaleY: { from: 1, to: 1.02 },\n            duration: 2200,                   // Optimized timing for mobile attention\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.InOut'\n        });\n        \n        // Mobile-friendly queue indicator - helps users understand the system\n        if (this.queueContainer) {\n            // Subtle pulsing to indicate \"next bubble\"\n            this.scene.tweens.add({\n                targets: this.queueContainer,\n                alpha: { from: 0.85, to: 1 },\n                duration: 3000,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.InOut'\n            });\n            \n            // Gentle scale animation to draw attention without being distracting\n            this.scene.tweens.add({\n                targets: this.queueContainer,\n                scaleX: { from: 1, to: 1.01 },\n                scaleY: { from: 1, to: 1.01 },\n                duration: 2000,\n                repeat: -1,\n                yoyo: true,\n                ease: 'Sine.InOut'\n            });\n        }\n        \n        // Mobile-optimized ready state indicator\n        if (this.readyIndicator) {\n            this.scene.tweens.add({\n                targets: this.readyIndicator,\n                alpha: { from: 0.4, to: 0.8 },\n                duration: 1800,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.InOut',\n                paused: true  // Activated when launcher is ready\n            });\n        }\n    }\n\n    /**\n     * MOBILE-FIRST: Setup optimized touch interaction with proper accessibility\n     */\n    private setupMobileTouchArea(): void {\n        // Create touch area following mobile accessibility guidelines\n        // iOS: 44x44pt minimum, Android: 48x48dp minimum - we use generous 120px\n        const touchSize = 120; // Premium touch area for excellent mobile UX\n        const touchArea = this.scene.add.rectangle(0, 0, touchSize, touchSize, 0x000000, 0);\n        touchArea.setInteractive({ useHandCursor: true });\n        \n        // Position behind all visual elements for clean design\n        this.addAt(touchArea, 0);\n        \n        // Enhanced mobile feedback system\n        touchArea.on('pointerdown', (pointer: Phaser.Input.Pointer) => {\n            // Satisfying mobile scale feedback - more pronounced\n            this.scene.tweens.add({\n                targets: this,\n                scaleX: 0.92,\n                scaleY: this.isOpponent ? -0.92 : 0.92,  // Maintain flip for opponent\n                duration: 60,\n                yoyo: true,\n                ease: 'Power3.Out'\n            });\n            \n            // Premium mobile ripple effect with better visibility\n            const ripple = this.scene.add.circle(0, 0, 12 * HD_SCALE, 0xffffff, 0.4);\n            this.add(ripple);\n            \n            this.scene.tweens.add({\n                targets: ripple,\n                scale: { from: 0, to: 4 },\n                alpha: { from: 0.4, to: 0 },\n                duration: 500,\n                ease: 'Power2.Out',\n                onComplete: () => ripple.destroy()\n            });\n            \n            // Visual hierarchy pulse for clarity\n            if (this.queueContainer) {\n                this.scene.tweens.add({\n                    targets: this.queueContainer,\n                    scaleX: { from: 1, to: 1.05 },\n                    scaleY: { from: 1, to: 1.05 },\n                    duration: 100,\n                    yoyo: true,\n                    ease: 'Power2.Out'\n                });\n            }\n        });\n        \n        // Subtle hover effect for desktop/tablet hybrid devices\n        touchArea.on('pointerover', () => {\n            this.setHighlight(true);\n        });\n        \n        touchArea.on('pointerout', () => {\n            this.setHighlight(false);\n        });\n    }\n\n    // === PUBLIC INTERFACE - ENHANCED ===\n\n    public setAimAngle(angle: number): void {\n        this.currentAngle = angle;\n        \n        let visualAngle = angle;\n        \n        if (this.zone === ArenaZone.PLAYER) {\n            if (angle > 180) {\n                visualAngle = Phaser.Math.Clamp(angle, 195, 345);\n            } else {\n                visualAngle = Phaser.Math.Clamp(angle, 15, 165);\n            }\n        } else {\n            visualAngle = Phaser.Math.Clamp(angle, 15, 165);\n        }\n        \n        this.currentAngle = visualAngle;\n        \n        // No visual rotation - the launcher stays fixed\n        // The trajectory preview shows the aiming direction\n    }\n\n    public getAimAngle(): number {\n        return this.currentAngle;\n    }\n\n    public getAimDirection(): Phaser.Math.Vector2 {\n        const rad = Phaser.Math.DegToRad(this.currentAngle);\n        return new Phaser.Math.Vector2(Math.cos(rad), Math.sin(rad));\n    }\n\n    public showAiming(show: boolean): void {\n        this.isAiming = show;\n        this.launcherState = show ? 'aiming' : 'idle';\n        \n        // Enhanced aiming feedback\n        if (show) {\n            // Charging animation with better visual feedback\n            this.chargingTween = this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1.08,\n                scaleY: 1.08,\n                duration: 200,\n                ease: 'Power2.Out'\n            });\n            \n            // Add subtle chamber pulsing when aiming\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                alpha: { from: 1, to: 0.9 },\n                duration: 800,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.InOut'\n            });\n        } else {\n            // Return to normal with better transition\n            if (this.chargingTween) {\n                this.chargingTween.stop();\n            }\n            \n            // Stop pulsing\n            if (this.bubbleChamber) {\n                this.scene.tweens.killTweensOf(this.bubbleChamber);\n            }\n            \n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1,\n                scaleY: 1,\n                alpha: 1,\n                duration: 300,\n                ease: 'Elastic.Out'\n            });\n        }\n        \n        // Update all visual feedback systems\n        this.renderStateIndicators();\n        this.renderGlowEffects();\n    }\n\n    public animateShoot(bubbleColor?: BubbleColor): void {\n        this.launcherState = 'charging';\n        this.createEnhancedLaunchEffects(bubbleColor);\n        this.animateEnhancedLaunch();\n        \n        // Enter cooldown state briefly\n        setTimeout(() => {\n            this.launcherState = 'idle';\n            this.renderStateIndicators();\n        }, 500);\n    }\n\n    /**\n     * NEW: Set launcher state with visual updates\n     */\n    public override setState(state: 'idle' | 'aiming' | 'charging' | 'ready' | 'cooldown'): this {\n        this.launcherState = state;\n        this.updateStateIndicator();\n        this.renderStateIndicators();\n        return this;\n    }\n\n    /**\n     * NEW: Update state indicator visuals\n     */\n    private updateStateIndicator(): void {\n        if (!this.stateIndicator) return;\n        \n        // Clear previous state visuals\n        this.stateIndicator.clear();\n        \n        switch (this.launcherState) {\n            case 'idle':\n                // Subtle idle glow\n                this.stateIndicator.fillStyle(0x4CAF50, 0.2);\n                this.stateIndicator.fillCircle(0, 0, 35 * HD_SCALE);\n                break;\n                \n            case 'aiming':\n                // Aiming reticle effect\n                this.stateIndicator.lineStyle(4 * HD_SCALE, 0xFFC107, 0.6);  // HD line width\n                this.stateIndicator.strokeCircle(0, 0, 40 * HD_SCALE);\n                // Add crosshair\n                this.stateIndicator.lineBetween(-10 * HD_SCALE, 0, 10 * HD_SCALE, 0);\n                this.stateIndicator.lineBetween(0, -10 * HD_SCALE, 0, 10 * HD_SCALE);\n                break;\n                \n            case 'charging':\n                // Charging energy effect\n                const chargeColor = this.powerLevel < 30 ? 0xFF5722 : \n                                   this.powerLevel < 70 ? 0xFF9800 : 0x4CAF50;\n                this.stateIndicator.fillStyle(chargeColor, 0.3 + (this.powerLevel / 200));\n                this.stateIndicator.fillCircle(0, 0, (30 * HD_SCALE) + (this.powerLevel / 10));\n                break;\n                \n            case 'ready':\n                // Ready pulse effect\n                this.stateIndicator.fillStyle(0x00BCD4, 0.4);\n                this.stateIndicator.fillCircle(0, 0, 35 * HD_SCALE);\n                if (this.readyIndicator) {\n                    this.readyIndicator.setVisible(true);\n                }\n                break;\n                \n            case 'cooldown':\n                // Cooldown dimmed effect\n                this.stateIndicator.fillStyle(0x9E9E9E, 0.2);\n                this.stateIndicator.fillCircle(0, 0, 30 * HD_SCALE);\n                break;\n        }\n    }\n\n    /**\n     * NEW: Power charging system for better game feel\n     */\n    public startPowerCharge(): void {\n        this.launcherState = 'charging';\n        this.powerLevel = 0;\n        \n        // Visual power buildup\n        this.scene.tweens.add({\n            targets: this,\n            powerLevel: 100,\n            duration: 1500,\n            ease: 'Power2.Out',\n            onUpdate: () => {\n                this.renderPowerIndicator();\n            }\n        });\n        \n        // Chamber charging effect\n        if (this.bubbleChamber) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: { from: 1, to: 1.15 },\n                scaleY: { from: 1, to: 1.15 },\n                duration: 1500,\n                ease: 'Power2.Out'\n            });\n        }\n        \n        this.renderStateIndicators();\n    }\n\n    /**\n     * NEW: Release power charge\n     */\n    public releasePowerCharge(): number {\n        const power = this.powerLevel;\n        this.powerLevel = 0;\n        \n        // Reset chamber size\n        if (this.bubbleChamber) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1,\n                scaleY: 1,\n                duration: 200,\n                ease: 'Power2.Out'\n            });\n        }\n        \n        return power;\n    }\n\n    /**\n     * NEW: Render power charging indicator\n     */\n    private renderPowerIndicator(): void {\n        if (!this.stateIndicator || this.launcherState !== 'charging') return;\n        \n        // Clear previous power indicator\n        if (this.readyIndicator) {\n            const powerColor = this.powerLevel < 30 ? 0xff4444 : \n                              this.powerLevel < 70 ? 0xffaa00 : 0x00ff88;\n            \n            const alpha = 0.3 + (this.powerLevel / 100) * 0.7;\n            this.readyIndicator.setStrokeStyle(3, powerColor, alpha);\n            this.readyIndicator.setVisible(true);\n        }\n    }\n\n    public setHighlight(enabled: boolean): void {\n        const alpha = enabled ? 1.0 : 0.95;\n        \n        // Enhanced highlight with better mobile feedback\n        this.scene.tweens.add({\n            targets: this,\n            alpha,\n            duration: 150,  // Faster response for mobile\n            ease: 'Power2.Out'\n        });\n        \n        // Add subtle glow effect to chamber when highlighted\n        if (this.bubbleChamber && enabled) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1.03,\n                scaleY: 1.03,\n                duration: 150,\n                ease: 'Power2.Out'\n            });\n        } else if (this.bubbleChamber) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1,\n                scaleY: 1,\n                duration: 150,\n                ease: 'Power2.Out'\n            });\n        }\n    }\n\n    public loadBubble(color: BubbleColor): void {\n        // Clear existing bubble\n        if (this.loadedBubble) {\n            this.remove(this.loadedBubble);\n            this.loadedBubble.destroy();\n        }\n        \n        // Mobile-optimized bubble positioning and sizing\n        this.loadedBubble = new Bubble(this.scene, 0, this.BUBBLE_POSITION_Y, color);\n        this.loadedBubble.setScale(1.0); // Slightly larger for mobile clarity (was 0.95)\n        this.add(this.loadedBubble);\n        this.bringToTop(this.loadedBubble);\n        \n        // Update theme to match loaded bubble\n        this.updateTheme(color);\n        \n        // Update ready indicator color to match bubble - no alpha initially\n        if (this.readyIndicator && this.currentTheme) {\n            // Don't set visibility here, let renderStateIndicators handle it\n            // Just prepare the color for when it becomes visible\n            this.readyIndicator.setStrokeStyle(2, this.currentTheme.platform.rim, 0);\n        }\n        \n        // Update arsenal slot colors to match launcher theme\n        this.updateArsenalTheme();\n        \n        // Enhanced mobile loading animation with better visual feedback\n        this.loadedBubble.setScale(0);\n        this.scene.tweens.add({\n            targets: this.loadedBubble,\n            scale: 1.0,\n            duration: 450,\n            ease: 'Back.Out'\n        });\n        \n        // Mobile visual hierarchy: emphasize the loaded bubble is READY TO SHOOT\n        this.scene.tweens.add({\n            targets: this.loadedBubble,\n            alpha: { from: 0.7, to: 1 },\n            duration: 600,\n            ease: 'Power2.InOut',\n            delay: 200\n        });\n        \n        // Update launcher state\n        this.launcherState = 'ready';\n        \n        // Maintain opponent flip consistency\n        if (this.isOpponent && this.scaleY !== -1) {\n            this.setScale(1, -1);\n        }\n        \n        // Update all visual indicators\n        this.renderStateIndicators();\n        \n        // Mobile-friendly chamber response with clearer feedback\n        this.scene.tweens.add({\n            targets: this.bubbleChamber,\n            scaleX: { from: 1, to: 1.12 },\n            scaleY: { from: 1, to: 1.12 },\n            duration: 300,\n            yoyo: true,\n            ease: 'Back.Out'\n        });\n        \n        // Update visual effects\n        this.renderGlowEffects();\n        \n        // Mobile UX: Subtle visual indicator that this is the ACTIVE bubble\n        if (this.bubbleChamber) {\n            this.scene.time.delayedCall(500, () => {\n                this.scene.tweens.add({\n                    targets: this.bubbleChamber,\n                    alpha: { from: 1, to: 0.95 },\n                    duration: 300,\n                    ease: 'Sine.InOut'\n                });\n            });\n        }\n    }\n\n    public getLoadedBubble(): Bubble | undefined {\n        return this.loadedBubble;\n    }\n\n    public clearLoadedBubble(): void {\n        if (this.loadedBubble) {\n            this.remove(this.loadedBubble);\n        }\n        this.loadedBubble = undefined;\n        this.renderGlowEffects();\n        \n        // Ensure flip is maintained for opponent\n        if (this.isOpponent && this.scaleY !== -1) {\n            this.setScale(1, -1);\n        }\n    }\n\n    public updateQueueColors(colors: BubbleColor[]): void {\n        this.nextBubbleColors = colors;\n        \n        if (!this.queueContainer) return;\n        \n        // console.log('Launcher: Updating queue colors:', colors);\n        \n        // Clear existing bubbles with animation\n        if (this.nextBubbleGraphics) {\n            this.scene.tweens.add({\n                targets: this.nextBubbleGraphics,\n                alpha: 0,\n                scale: 0,\n                duration: 150,\n                onComplete: () => {\n                    this.nextBubbleGraphics?.destroy();\n                    this.nextBubbleGraphics = undefined;\n                }\n            });\n        }\n        \n        if (this.secondBubbleGraphics) {\n            this.scene.tweens.add({\n                targets: this.secondBubbleGraphics,\n                alpha: 0,\n                scale: 0,\n                duration: 150,\n                onComplete: () => {\n                    this.secondBubbleGraphics?.destroy();\n                    this.secondBubbleGraphics = undefined;\n                }\n            });\n        }\n        \n        // Create new bubbles with correct colors after a brief delay\n        this.scene.time.delayedCall(200, () => {\n            if (colors.length > 0 && colors[0]) {\n                // console.log('Creating next bubble with color:', colors[0]);\n                this.createNextBubble(colors[0]);\n            }\n            if (colors.length > 1 && colors[1]) {\n                this.scene.time.delayedCall(150, () => {\n                    // console.log('Creating second bubble with color:', colors[1]!);\n                    this.createSecondBubble(colors[1]!);\n                });\n            }\n        });\n    }\n\n    // === PRIVATE ANIMATION METHODS - ENHANCED ===\n\n    private animateEnhancedLaunch(): void {\n        // Enhanced launch recoil with power-based intensity\n        const recoilIntensity = 1 + (this.powerLevel / 100) * 0.5;\n        \n        if (this.bubbleChamber) {\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: 1.15 * recoilIntensity,\n                scaleY: 1.15 * recoilIntensity,\n                duration: 200 + this.powerLevel,\n                yoyo: true,\n                ease: 'Power3.Out'\n            });\n        }\n        \n        // Enhanced platform shake with haptic feel\n        if (this.launcherPlatform) {\n            const shakeIntensity = 2 * recoilIntensity;\n            this.scene.tweens.add({\n                targets: this.launcherPlatform,\n                x: -shakeIntensity,\n                duration: 175,\n                yoyo: true,\n                ease: 'Power2.Out'\n            });\n        }\n        \n        // Power-based launcher recoil\n        const recoilDistance = 3 * recoilIntensity;\n        this.scene.tweens.add({\n            targets: this,\n            y: this.y - (this.isOpponent ? -recoilDistance : recoilDistance),\n            duration: 100,\n            yoyo: true,\n            ease: 'Power2.Out'\n        });\n        \n        // Screen shake for powerful shots\n        if (this.powerLevel > 70) {\n            this.scene.cameras.main.shake(150, 0.01);\n        }\n    }\n\n    private createEnhancedLaunchEffects(bubbleColor?: BubbleColor): void {\n        if (!bubbleColor) return;\n        \n        const colors = this.getBubbleColors(bubbleColor);\n        const effectY = this.isOpponent ? \n            this.y + Math.abs(this.BUBBLE_POSITION_Y) :\n            this.y + this.BUBBLE_POSITION_Y;\n        \n        // Power-based effect intensity\n        const effectIntensity = 0.8 + (this.powerLevel / 100) * 0.4;\n        const particleCount = Math.floor(8 + (this.powerLevel / 100) * 8);\n        \n        // Enhanced muzzle flash\n        const flashSize = 22 * effectIntensity;\n        const flash = this.scene.add.circle(this.x, effectY, flashSize, colors.primary, 0.9);\n        flash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        this.scene.tweens.add({\n            targets: flash,\n            scale: { from: 0.5, to: 2.2 * effectIntensity },\n            alpha: { from: 0.9, to: 0 },\n            duration: 280 + (this.powerLevel * 2),\n            ease: 'Power2.Out',\n            onComplete: () => flash.destroy()\n        });\n        \n        // Power-based sparkle burst\n        for (let i = 0; i < particleCount; i++) {\n            const angle = (Math.PI * 2 / particleCount) * i;\n            const baseDistance = 10 + Math.random() * 12;\n            const distance = baseDistance * effectIntensity;\n            const sparkX = this.x + Math.cos(angle) * distance;\n            const sparkY = effectY + Math.sin(angle) * distance;\n            \n            const sparkleSize = 4.5 * effectIntensity;\n            const sparkle = this.scene.add.circle(sparkX, sparkY, sparkleSize, colors.primary, 0.95);\n            sparkle.setBlendMode(Phaser.BlendModes.ADD);\n            \n            this.scene.tweens.add({\n                targets: sparkle,\n                scale: { from: 1.1, to: 0 },\n                alpha: { from: 0.9, to: 0 },\n                x: sparkX + Math.cos(angle) * 28 * effectIntensity,\n                y: sparkY + Math.sin(angle) * 28 * effectIntensity,\n                duration: 450 + (this.powerLevel * 3),\n                delay: i * 18,\n                ease: 'Power2.Out',\n                onComplete: () => sparkle.destroy()\n            });\n        }\n        \n        // Enhanced energy rings for powerful shots\n        if (this.powerLevel > 50) {\n            for (let r = 0; r < 2; r++) {\n                const ring = this.scene.add.circle(this.x, effectY, 19 + r * 5, colors.primary, 0);\n                ring.setStrokeStyle(3.5 - r * 0.5, colors.primary, 0.9 - r * 0.2);\n                ring.setBlendMode(Phaser.BlendModes.ADD);\n                \n                this.scene.tweens.add({\n                    targets: ring,\n                    scale: { from: 0.6, to: (2.2 + r * 0.3) * effectIntensity },\n                    alpha: { from: 0.8, to: 0 },\n                    duration: 380 + r * 100,\n                    delay: r * 50,\n                    ease: 'Power2.Out',\n                    onComplete: () => ring.destroy()\n                });\n            }\n        } else {\n            // Standard ring for normal shots\n            const ring = this.scene.add.circle(this.x, effectY, 19, colors.primary, 0);\n            ring.setStrokeStyle(3.5, colors.primary, 0.9);\n            ring.setBlendMode(Phaser.BlendModes.ADD);\n            \n            this.scene.tweens.add({\n                targets: ring,\n                scale: { from: 0.6, to: 2.2 },\n                alpha: { from: 0.8, to: 0 },\n                duration: 380,\n                ease: 'Power2.Out',\n                onComplete: () => ring.destroy()\n            });\n        }\n    }\n\n    private updateArsenalTheme(): void {\n        if (!this.arsenalSlots || !this.currentTheme) return;\n        \n        // Update all arsenal slot backgrounds with new theme\n        this.arsenalSlots.forEach(slot => {\n            if (slot.background) {\n                this.drawArsenalSlotBackground(slot.background, slot.isActive);\n            }\n        });\n    }\n    \n    // === ARSENAL INTEGRATION METHODS ===\n    \n    private createIntegratedArsenal(): void {\n        // Create container for arsenal system\n        this.arsenalContainer = this.scene.add.container(0, 0);\n        this.add(this.arsenalContainer);\n        \n        // Create the horizontal chamber design first\n        this.createArsenalChamber();\n        \n        // Use appropriate positions based on player/opponent\n        const positions = this.isOpponent ? \n            this.ARSENAL_POSITIONS_OPPONENT : \n            this.ARSENAL_POSITIONS_PLAYER;\n        \n        // Create arsenal slots in horizontal formation\n        positions.forEach((pos, index) => {\n            const slot = this.createArsenalSlot(pos, index);\n            this.arsenalSlots.push(slot);\n            if (this.arsenalContainer) {\n                this.arsenalContainer.add(slot.container);\n            }\n        });\n        \n        // Position arsenal at higher depth to ensure visibility\n        this.arsenalContainer.setDepth(100);\n    }\n    \n    private createArsenalChamber(): void {\n        if (!this.arsenalContainer || !this.currentTheme) return;\n        \n        const chamberGraphics = this.scene.add.graphics();\n        \n        // Calculate bounds for horizontal chamber\n        const startX = this.isOpponent ? -70 * HD_SCALE : 70 * HD_SCALE;\n        const endX = this.isOpponent ? -150 * HD_SCALE : 150 * HD_SCALE;\n        const chamberY = -35 * HD_SCALE;\n        const chamberHeight = 40 * HD_SCALE;\n        const chamberWidth = Math.abs(endX - startX) + 40 * HD_SCALE;\n        const chamberX = Math.min(startX, endX) - 18 * HD_SCALE;\n        \n        // === LAYER 1: Base Platform (like launcher) ===\n        // Outer shadow/glow\n        chamberGraphics.fillStyle(0x000000, 0.5);\n        chamberGraphics.fillRoundedRect(\n            chamberX - 3,\n            chamberY - chamberHeight/2 - 3,\n            chamberWidth + 6,\n            chamberHeight + 6,\n            15 * HD_SCALE\n        );\n        \n        // Main platform base\n        const gradient = chamberGraphics.fillGradientStyle(\n            this.currentTheme.platform.base,\n            this.currentTheme.platform.base,\n            this.currentTheme.secondary,\n            this.currentTheme.secondary,\n            0.7\n        );\n        chamberGraphics.fillRoundedRect(\n            chamberX,\n            chamberY - chamberHeight/2,\n            chamberWidth,\n            chamberHeight,\n            12 * HD_SCALE\n        );\n        \n        // === LAYER 2: Inner Chamber Details ===\n        // Inner recessed area\n        chamberGraphics.fillStyle(this.currentTheme.chamber.inner, 0.4);\n        chamberGraphics.fillRoundedRect(\n            chamberX + 4 * HD_SCALE,\n            chamberY - chamberHeight/2 + 4 * HD_SCALE,\n            chamberWidth - 8 * HD_SCALE,\n            chamberHeight - 8 * HD_SCALE,\n            10 * HD_SCALE\n        );\n        \n        // === LAYER 3: Tech Details ===\n        // Tech panels between slots\n        const slotSpacing = 40 * HD_SCALE;\n        for (let i = 0; i < 2; i++) {\n            const panelX = startX + (i + 0.5) * slotSpacing * (this.isOpponent ? -1 : 1);\n            \n            // Panel background\n            chamberGraphics.fillStyle(this.currentTheme.platform.detail, 0.3);\n            chamberGraphics.fillRect(\n                panelX - 8 * HD_SCALE,\n                chamberY - 10 * HD_SCALE,\n                16 * HD_SCALE,\n                20 * HD_SCALE\n            );\n            \n            // Panel lines\n            chamberGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.glow.pulse, 0.4);\n            chamberGraphics.lineBetween(\n                panelX - 6 * HD_SCALE,\n                chamberY,\n                panelX + 6 * HD_SCALE,\n                chamberY\n            );\n        }\n        \n        // === LAYER 4: Premium Borders & Rims ===\n        // Outer rim\n        chamberGraphics.lineStyle(3 * HD_SCALE, this.currentTheme.platform.rim, 1);\n        chamberGraphics.strokeRoundedRect(\n            chamberX,\n            chamberY - chamberHeight/2,\n            chamberWidth,\n            chamberHeight,\n            12 * HD_SCALE\n        );\n        \n        // Inner rim detail\n        chamberGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.chamber.detail, 0.6);\n        chamberGraphics.strokeRoundedRect(\n            chamberX + 4 * HD_SCALE,\n            chamberY - chamberHeight/2 + 4 * HD_SCALE,\n            chamberWidth - 8 * HD_SCALE,\n            chamberHeight - 8 * HD_SCALE,\n            10 * HD_SCALE\n        );\n        \n        // === CONNECTING TUBE (Premium Design) ===\n        const tubeStartX = this.isOpponent ? -35 * HD_SCALE : 35 * HD_SCALE;\n        const tubeEndX = startX - (this.isOpponent ? -18 : 18) * HD_SCALE;\n        const tubeY = chamberY;\n        const tubeHeight = 24 * HD_SCALE;\n        \n        // Tube shadow\n        chamberGraphics.fillStyle(0x000000, 0.3);\n        chamberGraphics.fillRect(\n            Math.min(tubeStartX, tubeEndX) - 1,\n            tubeY - tubeHeight/2 - 1,\n            Math.abs(tubeEndX - tubeStartX) + 2,\n            tubeHeight + 2\n        );\n        \n        // Tube main body\n        chamberGraphics.fillStyle(this.currentTheme.platform.base, 0.6);\n        chamberGraphics.fillRect(\n            Math.min(tubeStartX, tubeEndX),\n            tubeY - tubeHeight/2,\n            Math.abs(tubeEndX - tubeStartX),\n            tubeHeight\n        );\n        \n        // Tube inner detail\n        chamberGraphics.fillStyle(this.currentTheme.chamber.inner, 0.3);\n        chamberGraphics.fillRect(\n            Math.min(tubeStartX, tubeEndX) + 2,\n            tubeY - tubeHeight/2 + 2,\n            Math.abs(tubeEndX - tubeStartX) - 4,\n            tubeHeight - 4\n        );\n        \n        // Tube borders\n        chamberGraphics.lineStyle(2 * HD_SCALE, this.currentTheme.platform.rim, 0.9);\n        chamberGraphics.lineBetween(tubeStartX, tubeY - tubeHeight/2, tubeEndX, tubeY - tubeHeight/2);\n        chamberGraphics.lineBetween(tubeStartX, tubeY + tubeHeight/2, tubeEndX, tubeY + tubeHeight/2);\n        \n        // Energy flow lines in tube\n        chamberGraphics.lineStyle(1 * HD_SCALE, this.currentTheme.glow.pulse, 0.5);\n        for (let i = 0; i < 3; i++) {\n            const lineY = tubeY - tubeHeight/2 + (i + 1) * (tubeHeight / 4);\n            chamberGraphics.setLineDash([5 * HD_SCALE, 5 * HD_SCALE]);\n            chamberGraphics.lineBetween(tubeStartX, lineY, tubeEndX, lineY);\n        }\n        chamberGraphics.setLineDash([]);\n        \n        // === DECORATIVE ELEMENTS ===\n        // Corner accents\n        chamberGraphics.lineStyle(2 * HD_SCALE, this.currentTheme.glow.loaded, 0.4);\n        // Top left\n        chamberGraphics.lineBetween(\n            chamberX,\n            chamberY - chamberHeight/2 + 10 * HD_SCALE,\n            chamberX + 10 * HD_SCALE,\n            chamberY - chamberHeight/2\n        );\n        // Top right\n        chamberGraphics.lineBetween(\n            chamberX + chamberWidth - 10 * HD_SCALE,\n            chamberY - chamberHeight/2,\n            chamberX + chamberWidth,\n            chamberY - chamberHeight/2 + 10 * HD_SCALE\n        );\n        \n        this.arsenalContainer.add(chamberGraphics);\n        chamberGraphics.setDepth(-1); // Behind slots\n    }\n    \n    private createArsenalSlot(position: { x: number, y: number }, index: number): ArsenalSlot {\n        const container = this.scene.add.container(position.x, position.y);\n        \n        // Counter-rotate the container for opponent to keep content readable\n        if (this.isOpponent) {\n            container.setScale(1, -1);\n        }\n        \n        // Create slot background with weapon mount design\n        const background = this.scene.add.graphics();\n        this.drawArsenalSlotBackground(background, false);\n        \n        // Create power-up icon\n        const icon = this.scene.add.text(0, 0, '', {\n            fontSize: `${14 * HD_SCALE}px`,  // Further reduced for smaller slots\n            fontFamily: 'Arial'\n        });\n        icon.setOrigin(0.5);\n        icon.setShadow(2, 2, '#000000', 2, true, true);\n        \n        // Create count text\n        const countText = this.scene.add.text(\n            this.SLOT_SIZE/2 - 2,\n            this.SLOT_SIZE/2 - 2,\n            '',\n            {\n                fontSize: `${6 * HD_SCALE}px`,  // Further reduced for smaller slots\n                fontFamily: 'Arial Black',\n                color: '#FFFFFF',\n                stroke: '#000000',\n                strokeThickness: 2 * HD_SCALE\n            }\n        );\n        countText.setOrigin(1, 1);\n        \n        // Add key hint for slots 1-3 (only on desktop)\n        const isMobile = this.scene.game.device.input.touch;\n        if (!isMobile) {\n            const keyHint = this.createKeyHintBadge(index + 1);\n            keyHint.setPosition(-this.SLOT_SIZE/2 + 6, -this.SLOT_SIZE/2 + 6);\n            container.add(keyHint);\n        }\n        \n        container.add([background, icon, countText]);\n        \n        // Make interactive only for player\n        if (!this.isOpponent) {\n            const touchPadding = 6;\n            container.setInteractive(\n                new Phaser.Geom.Rectangle(\n                    -this.SLOT_SIZE/2 - touchPadding,\n                    -this.SLOT_SIZE/2 - touchPadding,\n                    this.SLOT_SIZE + touchPadding * 2,\n                    this.SLOT_SIZE + touchPadding * 2\n                ),\n                Phaser.Geom.Rectangle.Contains\n            );\n            \n            // Add hover/press effects\n            container.on('pointerdown', () => {\n                this.activateArsenalSlot(index);\n            });\n            \n            container.on('pointerover', () => {\n                const baseScale = this.isOpponent ? -1 : 1;\n                this.scene.tweens.add({\n                    targets: container,\n                    scaleX: 1.1,\n                    scaleY: 1.1 * baseScale,\n                    duration: 200,\n                    ease: 'Power2'\n                });\n            });\n            \n            container.on('pointerout', () => {\n                const baseScale = this.isOpponent ? -1 : 1;\n                this.scene.tweens.add({\n                    targets: container,\n                    scaleX: 1.0,\n                    scaleY: 1.0 * baseScale,\n                    duration: 200,\n                    ease: 'Power2'\n                });\n            });\n        }\n        \n        return {\n            container,\n            background,\n            icon,\n            countText,\n            position,\n            powerUpType: undefined,\n            count: 0,\n            isActive: false\n        };\n    }\n    \n    private drawArsenalSlotBackground(graphics: Phaser.GameObjects.Graphics, isActive: boolean): void {\n        graphics.clear();\n        \n        const size = this.SLOT_SIZE;\n        const halfSize = size / 2;\n        \n        if (!this.currentTheme) return;\n        \n        const colors = {\n            primary: this.currentTheme.primary,\n            secondary: this.currentTheme.secondary,\n            glow: this.currentTheme.glow.pulse,\n            rim: this.currentTheme.platform.rim,\n            detail: this.currentTheme.chamber.detail\n        };\n        \n        // === LAYER 1: Shadow/Depth ===\n        graphics.fillStyle(0x000000, 0.4);\n        graphics.fillCircle(2, 3, halfSize + 2);\n        \n        // === LAYER 2: Outer Ring (Mechanical) ===\n        graphics.fillStyle(this.currentTheme.platform.base, 0.7);\n        graphics.fillCircle(0, 0, halfSize + 1);\n        \n        // === LAYER 3: Main Chamber ===\n        graphics.fillStyle(this.currentTheme.chamber.inner, 0.8);\n        graphics.fillCircle(0, 0, halfSize - 2);\n        \n        // === LAYER 4: Inner Core ===\n        graphics.fillStyle(colors.secondary, 0.2);\n        graphics.fillCircle(0, 0, halfSize - 5 * HD_SCALE);\n        \n        // === LAYER 5: Tech Details ===\n        // Radial lines (like launcher queue)\n        graphics.lineStyle(0.5 * HD_SCALE, colors.detail, 0.3);\n        for (let i = 0; i < 8; i++) {\n            const angle = (Math.PI * 2 * i) / 8;\n            const innerR = halfSize - 8 * HD_SCALE;\n            const outerR = halfSize - 3 * HD_SCALE;\n            graphics.lineBetween(\n                Math.cos(angle) * innerR,\n                Math.sin(angle) * innerR,\n                Math.cos(angle) * outerR,\n                Math.sin(angle) * outerR\n            );\n        }\n        \n        // === LAYER 6: Premium Rims ===\n        // Outer rim\n        graphics.lineStyle(2 * HD_SCALE, isActive ? 0xFFD700 : colors.rim, isActive ? 1 : 0.8);\n        graphics.strokeCircle(0, 0, halfSize);\n        \n        // Middle rim\n        graphics.lineStyle(1 * HD_SCALE, colors.detail, 0.5);\n        graphics.strokeCircle(0, 0, halfSize - 3 * HD_SCALE);\n        \n        // Inner rim\n        graphics.lineStyle(1 * HD_SCALE, colors.rim, 0.3);\n        graphics.strokeCircle(0, 0, halfSize - 6 * HD_SCALE);\n        \n        // === LAYER 7: Active State Premium Effects ===\n        if (isActive) {\n            // Outer glow ring\n            graphics.lineStyle(4 * HD_SCALE, 0xFFD700, 0.2);\n            graphics.strokeCircle(0, 0, halfSize + 3 * HD_SCALE);\n            \n            // Middle glow\n            graphics.lineStyle(2 * HD_SCALE, 0xFFD700, 0.4);\n            graphics.strokeCircle(0, 0, halfSize + 1 * HD_SCALE);\n            \n            // Inner bright core\n            graphics.fillStyle(0xFFFFFF, 0.1);\n            graphics.fillCircle(0, 0, halfSize - 7 * HD_SCALE);\n            \n            // Highlight arc (like launcher)\n            graphics.lineStyle(1 * HD_SCALE, 0xFFFFFF, 0.6);\n            graphics.arc(0, 0, halfSize - 4 * HD_SCALE, -Math.PI * 0.7, -Math.PI * 0.3, false);\n            graphics.strokePath();\n        }\n        \n        // === LAYER 8: Glossy Highlight ===\n        graphics.fillStyle(0xFFFFFF, 0.15);\n        graphics.fillEllipse(\n            -halfSize * 0.3,\n            -halfSize * 0.4,\n            halfSize * 0.6,\n            halfSize * 0.4\n        );\n    }\n    \n    private createKeyHintBadge(key: number): Phaser.GameObjects.Container {\n        const badge = this.scene.add.container(0, 0);\n        \n        // Use theme color for badge\n        const badgeColor = this.currentTheme?.glow?.pulse || 0xFFD700;\n        \n        const bg = this.scene.add.circle(0, 0, 7 * HD_SCALE, badgeColor, 0.9);\n        bg.setStrokeStyle(1 * HD_SCALE, 0x000000, 1);\n        \n        const text = this.scene.add.text(0, 0, `${key}`, {\n            fontSize: `${6 * HD_SCALE}px`,  // Further reduced for smaller slots\n            fontFamily: 'Arial Black',\n            color: '#000000'\n        });\n        text.setOrigin(0.5);\n        \n        badge.add([bg, text]);\n        return badge;\n    }\n    \n    private setupArsenalListeners(): void {\n        // Listen for power-up collection\n        this.scene.events.on('power-up-collected', (data: any) => {\n            const shouldAdd = this.isOpponent ? \n                (data.owner === 'opponent') : \n                (data.owner === 'player');\n            \n            if (shouldAdd) {\n                this.addPowerUpToArsenal(data.type);\n            }\n        });\n        \n        // Keyboard controls only for player (only on desktop)\n        if (!this.isOpponent && !this.scene.game.device.input.touch) {\n            this.scene.input.keyboard?.on('keydown-ONE', () => this.activateArsenalSlot(0));\n            this.scene.input.keyboard?.on('keydown-TWO', () => this.activateArsenalSlot(1));\n            this.scene.input.keyboard?.on('keydown-THREE', () => this.activateArsenalSlot(2));\n        }\n    }\n    \n    private addPowerUpToArsenal(type: PowerUpType): void {\n        // Check if we already have this power-up\n        let slot = this.arsenalSlots.find(s => s.powerUpType === type);\n        \n        if (slot) {\n            // Increment count\n            slot.count++;\n            slot.countText.setText(slot.count > 1 ? `x${slot.count}` : '');\n        } else {\n            // Find empty slot\n            slot = this.arsenalSlots.find(s => !s.powerUpType);\n            \n            if (slot) {\n                slot.powerUpType = type;\n                slot.count = 1;\n                slot.icon.setText(this.powerUpIcons[type]);\n                \n                // Collection animation\n                this.showPowerUpCollectionEffect(slot);\n            }\n        }\n    }\n    \n    private activateArsenalSlot(index: number): void {\n        const slot = this.arsenalSlots[index];\n        \n        if (!slot || !slot.powerUpType || slot.count <= 0) {\n            // Empty slot feedback\n            if (slot) {\n                this.showEmptySlotFeedback(slot);\n            }\n            return;\n        }\n        \n        // Activate power-up\n        this.activatePowerUp(slot);\n    }\n    \n    private activatePowerUp(slot: ArsenalSlot): void {\n        if (!slot.powerUpType) return;\n        \n        // Visual activation sequence\n        this.showPowerUpActivation(slot);\n        \n        // Set active power-up\n        this.activePowerUp = slot.powerUpType;\n        \n        // Emit activation event\n        this.scene.events.emit('activate-power-up', {\n            type: slot.powerUpType\n        });\n        \n        // Decrease count\n        slot.count--;\n        \n        if (slot.count <= 0) {\n            // Clear slot\n            slot.powerUpType = undefined;\n            slot.icon.setText('');\n            slot.countText.setText('');\n            slot.isActive = false;\n        } else {\n            slot.countText.setText(slot.count > 1 ? `x${slot.count}` : '');\n        }\n        \n        // Start cooldown\n        this.startSlotCooldown(slot, 2000);\n    }\n    \n    private showPowerUpActivation(slot: ArsenalSlot): void {\n        // Create energy beam from slot to launcher\n        this.renderEnergyConduit(slot);\n        \n        // Chamber enhancement effect - maintain orientation\n        if (this.bubbleChamber) {\n            const baseScale = this.isOpponent ? -1 : 1;\n            this.scene.tweens.add({\n                targets: this.bubbleChamber,\n                scaleX: { from: 1, to: 1.2, end: 1 },\n                scaleY: { from: baseScale, to: 1.2 * baseScale, end: baseScale },\n                duration: 300,\n                ease: 'Power2'\n            });\n        }\n        \n        // Slot activation burst\n        const burst = this.scene.add.graphics();\n        burst.fillStyle(0xFFD700, 0.6);\n        burst.fillCircle(slot.position.x, slot.position.y, this.SLOT_SIZE/2);\n        this.arsenalContainer?.add(burst);\n        \n        this.scene.tweens.add({\n            targets: burst,\n            scale: 2,\n            alpha: 0,\n            duration: 400,\n            ease: 'Power2',\n            onComplete: () => burst.destroy()\n        });\n    }\n    \n    private renderEnergyConduit(slot: ArsenalSlot): void {\n        if (!this.energyConduits) return;\n        \n        // Clear previous conduits\n        this.energyConduits.clear();\n        \n        // Draw energy beam\n        const startX = slot.position.x;\n        const startY = slot.position.y;\n        const endX = 0;\n        const endY = this.BUBBLE_POSITION_Y;\n        \n        // Animated energy beam\n        this.energyConduits.lineStyle(6 * HD_SCALE, 0xFFD700, 0.8);  // HD line width\n        this.energyConduits.lineBetween(startX, startY, endX, endY);\n        \n        // Create energy particles along the beam\n        for (let i = 0; i < 5; i++) {\n            const t = i / 4;\n            const px = startX + (endX - startX) * t;\n            const py = startY + (endY - startY) * t;\n            \n            const particle = this.scene.add.circle(px, py, 2 * HD_SCALE, 0xFFD700);\n            this.arsenalContainer?.add(particle);\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: endX,\n                y: endY,\n                scale: 0,\n                duration: 500,\n                delay: i * 50,\n                ease: 'Power2',\n                onComplete: () => particle.destroy()\n            });\n        }\n        \n        // Fade out conduit\n        this.scene.time.delayedCall(600, () => {\n            this.scene.tweens.add({\n                targets: this.energyConduits,\n                alpha: 0,\n                duration: 200,\n                onComplete: () => {\n                    this.energyConduits?.clear();\n                    this.energyConduits?.setAlpha(1);\n                }\n            });\n        });\n    }\n    \n    private showPowerUpCollectionEffect(slot: ArsenalSlot): void {\n        // Scale animation - maintain correct orientation for opponent\n        const baseScale = this.isOpponent ? -1 : 1;\n        this.scene.tweens.add({\n            targets: slot.container,\n            scaleX: { from: 1.3, to: 1 },\n            scaleY: { from: 1.3 * baseScale, to: baseScale },\n            duration: 300,\n            ease: 'Back.easeOut'\n        });\n        \n        // Glow effect\n        const collectFlash = this.scene.add.graphics();\n        collectFlash.fillStyle(0xFFD700, 0.5);\n        collectFlash.fillCircle(slot.position.x, slot.position.y, this.SLOT_SIZE);\n        this.arsenalContainer?.add(collectFlash);\n        \n        this.scene.tweens.add({\n            targets: collectFlash,\n            alpha: 0,\n            scale: 2,\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onComplete: () => collectFlash.destroy()\n        });\n    }\n    \n    private showEmptySlotFeedback(slot: ArsenalSlot): void {\n        // Red flash for empty slot\n        const flash = this.scene.add.graphics();\n        flash.fillStyle(0xFF0000, 0.3);\n        flash.fillCircle(0, 0, this.SLOT_SIZE/2);\n        slot.container.add(flash);\n        \n        this.scene.tweens.add({\n            targets: flash,\n            alpha: 0,\n            duration: 300,\n            onComplete: () => flash.destroy()\n        });\n    }\n    \n    private startSlotCooldown(slot: ArsenalSlot, duration: number): void {\n        // Create cooldown overlay\n        const overlay = this.scene.add.graphics();\n        overlay.fillStyle(0x000000, 0.7);\n        overlay.fillCircle(0, 0, this.SLOT_SIZE/2);\n        slot.container.add(overlay);\n        \n        // Progress arc\n        const progressArc = this.scene.add.graphics();\n        slot.container.add(progressArc);\n        \n        this.scene.tweens.add({\n            targets: { progress: 0 },\n            progress: 1,\n            duration: duration,\n            onUpdate: (tween) => {\n                const progress = tween.getValue();\n                progressArc.clear();\n                progressArc.lineStyle(6 * HD_SCALE, 0x4ECDC4, 0.8);  // HD line width\n                progressArc.beginPath();\n                progressArc.arc(0, 0, this.SLOT_SIZE/2 - (2 * HD_SCALE), -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * progress), false);\n                progressArc.strokePath();\n            },\n            onComplete: () => {\n                overlay.destroy();\n                progressArc.destroy();\n                this.drawArsenalSlotBackground(slot.background, false);\n            }\n        });\n    }\n    \n    /**\n     * Cleanup method\n     */\n    public override destroy(): void {\n        // Clean up arsenal\n        this.arsenalSlots.forEach(slot => {\n            this.scene.tweens.killTweensOf(slot.container);\n        });\n        \n        // Clean up animations\n        if (this.idleAnimation) {\n            this.idleAnimation.destroy();\n        }\n        if (this.chargingTween) {\n            this.chargingTween.destroy();\n        }\n        \n        // Remove event listeners\n        this.scene.events.off('power-up-collected');\n        this.scene.events.off('activate-power-up');\n        \n        super.destroy();\n    }\n}","import { IObjectiveConfig } from '@/types/ArenaTypes';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { AnimationBatcher } from '@/systems/visual/AnimationBatcher';\n\nexport class Objective extends Phaser.GameObjects.Container {\n    private chestBody: Phaser.GameObjects.Rectangle;\n    private chestLid: Phaser.GameObjects.Rectangle;\n    private chestLock: Phaser.GameObjects.Arc;\n    private shield: Phaser.GameObjects.Arc;\n    private glowEffect: Phaser.GameObjects.Arc;\n    private health: number;\n    private maxHealth: number;\n    private shielded: boolean = true;\n    // Store timer references for cleanup\n    private sparkleTimer?: Phaser.Time.TimerEvent;\n    private shimmerTimer?: Phaser.Time.TimerEvent;\n    private starBurstTimer?: Phaser.Time.TimerEvent;\n    private peekTimer?: Phaser.Time.TimerEvent;\n\n    constructor(scene: Phaser.Scene, config: IObjectiveConfig) {\n        super(scene, config.x, config.y);\n        \n        this.health = config.health;\n        this.maxHealth = config.health;\n        \n        // Multi-layered glow system (game industry standard)\n        // Outer glow - large and subtle\n        const outerGlow = scene.add.circle(0, 0, config.size / 2 + 15, 0xFFD700, 0.15);\n        this.add(outerGlow);\n        \n        // Middle glow - medium brightness\n        const middleGlow = scene.add.circle(0, 0, config.size / 2 + 8, 0xFFD700, 0.3);\n        this.add(middleGlow);\n        \n        // Inner glow - bright and focused\n        this.glowEffect = scene.add.circle(0, 0, config.size / 2 + 4, 0xFFD700, 0.5);\n        \n        // \"Breathing\" animation - industry standard for important objects\n        scene.tweens.add({\n            targets: [this.glowEffect, middleGlow, outerGlow],\n            scale: { from: 0.9, to: 1.15 },\n            alpha: { from: 0.4, to: 0.8 },\n            duration: 1500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Secondary pulse for extra attention\n        scene.tweens.add({\n            targets: outerGlow,\n            scale: { from: 1, to: 1.3 },\n            alpha: { from: 0.15, to: 0.05 },\n            duration: 2500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Quad.easeInOut'\n        });\n        \n        // Remove shield visual - chest is always the target!\n        this.shield = scene.add.circle(0, 0, config.size / 2 + 2, 0x00ffff, 0);\n        this.shield.setVisible(false);\n        this.shielded = false; // Chest is always a valid target\n        \n        // Create treasure chest\n        const chestSize = config.size * 0.7;\n        \n        // Chest body (main box) - no stroke\n        this.chestBody = scene.add.rectangle(0, 3, chestSize, chestSize * 0.8, 0x8B4513);\n        \n        // Chest lid (top part) - no stroke\n        this.chestLid = scene.add.rectangle(0, -5, chestSize * 1.1, chestSize * 0.4, 0xA0522D);\n        \n        // Chest lock (golden circle) - no stroke\n        this.chestLock = scene.add.circle(0, 3, chestSize * 0.15, 0xFFD700);\n        \n        // Add golden details\n        const detail1 = scene.add.rectangle(-chestSize * 0.3, 3, 2, chestSize * 0.6, 0xFFD700);\n        const detail2 = scene.add.rectangle(chestSize * 0.3, 3, 2, chestSize * 0.6, 0xFFD700);\n        const detail3 = scene.add.rectangle(0, 3, chestSize * 0.8, 2, 0xFFD700);\n        \n        this.add([this.glowEffect, this.shield, this.chestBody, detail1, detail2, detail3, this.chestLid, this.chestLock]);\n        \n        // Lock animation is now handled in the main animation section\n        \n        // Particle system - industry standard for objective highlighting\n        \n        // 1. OPTIMIZED: Batch sparkle creation (same visual, better performance)\n        this.sparkleTimer = scene.time.addEvent({\n            delay: 300, // Slightly less frequent but create more at once\n            repeat: -1,\n            callback: () => {\n                const sparkleCount = Phaser.Math.Between(2, 4); // More particles per batch\n                for (let i = 0; i < sparkleCount; i++) {\n                    const offsetX = Phaser.Math.Between(-config.size/2, config.size/2);\n                    const particle = scene.add.circle(\n                        offsetX,\n                        Phaser.Math.Between(-3, 3),\n                        Phaser.Math.Between(2, 4),\n                        Phaser.Utils.Array.GetRandom([0xFFD700, 0xFFA500, 0xFFFFAA, 0xFFE135]),\n                        1\n                    );\n                    this.add(particle);\n                    \n                    // Upward motion with slight drift\n                    scene.tweens.add({\n                        targets: particle,\n                        y: -config.size * 1.2,\n                        x: offsetX + Phaser.Math.Between(-8, 8),\n                        alpha: { from: 1, to: 0 },\n                        scale: { from: 1, to: 0.2 },\n                        duration: 1800,\n                        ease: 'Cubic.easeOut',\n                        delay: i * 100,\n                        onComplete: () => particle.destroy()\n                    });\n                }\n            }\n        });\n        \n        // 2. Orbital particles REMOVED - was causing floating particles issue\n        // Commented out to fix visual clutter\n        /*\n        for (let i = 0; i < 3; i++) {\n            const orbitRadius = config.size * 0.7;\n            const orbiter = scene.add.circle(\n                orbitRadius, 0, 3,\n                Phaser.Utils.Array.GetRandom([0xFFD700, 0xFFFFFF]),\n                0.8\n            );\n            this.add(orbiter);\n            \n            // Orbit animation\n            scene.tweens.add({\n                targets: orbiter,\n                angle: 360,\n                duration: 3000 + (i * 500),\n                repeat: -1,\n                ease: 'Linear'\n            });\n            \n            // Vertical bobbing\n            scene.tweens.add({\n                targets: orbiter,\n                y: Phaser.Math.Between(-5, 5),\n                duration: 1500 + (i * 200),\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut',\n                delay: i * 300\n            });\n        }\n        */\n        \n        // 3. Shimmer waves (used in Zelda, God of War, etc.) - Already optimized\n        this.shimmerTimer = scene.time.addEvent({\n            delay: 1500, // Already good frequency\n            repeat: -1,\n            callback: () => {\n                // Create expanding ring of light\n                const shimmer = scene.add.graphics();\n                shimmer.lineStyle(2, 0xFFFFFF, 0.8);\n                shimmer.strokeCircle(0, 0, config.size / 2);\n                this.add(shimmer);\n                \n                scene.tweens.add({\n                    targets: shimmer,\n                    scaleX: 2,\n                    scaleY: 2,\n                    alpha: 0,\n                    duration: 800,\n                    ease: 'Quad.easeOut',\n                    onComplete: () => shimmer.destroy()\n                });\n            }\n        });\n        \n        // 4. Screen-space particles for extra emphasis - Already optimized\n        this.starBurstTimer = scene.time.addEvent({\n            delay: 3000, // Already good frequency\n            repeat: -1,\n            callback: () => {\n                // Star burst every 3 seconds\n                for (let i = 0; i < 8; i++) {\n                    const angle = (i / 8) * Math.PI * 2;\n                    const distance = config.size * 0.4;\n                    const star = scene.add.star(\n                        Math.cos(angle) * distance,\n                        Math.sin(angle) * distance,\n                        4, 3, 6, 0xFFFFFF\n                    );\n                    star.setAlpha(0.9);\n                    this.add(star);\n                    \n                    scene.tweens.add({\n                        targets: star,\n                        x: Math.cos(angle) * config.size * 1.5,\n                        y: Math.sin(angle) * config.size * 1.5,\n                        alpha: 0,\n                        scale: 0,\n                        rotation: Math.PI * 2,\n                        duration: 1000,\n                        ease: 'Cubic.easeOut',\n                        delay: i * 50,\n                        onComplete: () => star.destroy()\n                    });\n                }\n            }\n        });\n        \n        // No ring - just particles for clean look\n        \n        this.setSize(config.size, config.size);\n        this.setDepth(Z_LAYERS.OBJECTIVE);\n        \n        // Enhanced chest animations (AAA game standards)\n        \n        // 1. \"Breathing\" animation - makes object feel alive\n        scene.tweens.add({\n            targets: this,\n            scaleX: { from: 0.98, to: 1.02 },\n            scaleY: { from: 0.98, to: 1.02 },\n            duration: 2000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // 2. Floating motion\n        scene.tweens.add({\n            targets: this,\n            y: config.y - 4,\n            duration: 2500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // 3. Subtle rocking for life\n        scene.tweens.add({\n            targets: this,\n            angle: { from: -1.5, to: 1.5 },\n            duration: 3200,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // 4. Lock highlight animation (focal point)\n        scene.tweens.add({\n            targets: this.chestLock,\n            scale: { from: 0.8, to: 1.3 },\n            alpha: { from: 0.7, to: 1 },\n            duration: 1200,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // 5. Chest lid occasional \"peek\" animation - Already optimized\n        this.peekTimer = scene.time.addEvent({\n            delay: 8000, // Already good frequency\n            repeat: -1,\n            callback: () => {\n                scene.tweens.add({\n                    targets: this.chestLid,\n                    y: this.chestLid.y - 3,\n                    angle: -5,\n                    duration: 300,\n                    yoyo: true,\n                    ease: 'Back.easeOut'\n                });\n            }\n        });\n        \n        // 6. Gold details shimmer\n        const details = [detail1, detail2, detail3];\n        details.forEach((detail, index) => {\n            scene.tweens.add({\n                targets: detail,\n                alpha: { from: 0.6, to: 1 },\n                duration: 800,\n                yoyo: true,\n                repeat: -1,\n                delay: index * 200,\n                ease: 'Quad.easeInOut'\n            });\n        });\n        \n        scene.add.existing(this);\n    }\n\n\n    public setShielded(shielded: boolean): void {\n        this.shielded = shielded;\n        \n        if (shielded) {\n            this.shield.setVisible(true);\n            this.scene.tweens.add({\n                targets: this.shield,\n                alpha: 0.5,\n                duration: 300,\n                ease: 'Power2'\n            });\n        } else {\n            // Shield broken animation\n            this.scene.tweens.add({\n                targets: this.shield,\n                alpha: 0,\n                scale: 1.5,\n                duration: 500,\n                ease: 'Power2',\n                onComplete: () => {\n                    this.shield.setVisible(false);\n                    this.showVulnerable();\n                }\n            });\n        }\n    }\n\n    private showVulnerable(): void {\n        // Glow brighter when vulnerable\n        this.scene.tweens.add({\n            targets: this.glowEffect,\n            scale: 1.3,\n            alpha: 0.8,\n            duration: 300,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Change chest color to indicate vulnerability\n        this.chestBody.setFillStyle(0xff6b6b);\n        this.chestLid.setFillStyle(0xff8888);\n    }\n\n    public hit(damage: number = 1): void {\n        this.health -= damage;\n        \n        // Play success objective sound when hit\n        this.scene.events.emit('objective-hit');\n        \n        // Impact animation\n        this.scene.tweens.add({\n            targets: this,\n            scaleX: 0.9,\n            scaleY: 0.9,\n            duration: 100,\n            yoyo: true,\n            ease: 'Power2'\n        });\n        \n        // Flash effect\n        const flash = this.scene.add.circle(this.x, this.y, 50, 0xffffff, 0.8);\n        this.scene.tweens.add({\n            targets: flash,\n            scale: 2,\n            alpha: 0,\n            duration: 300,\n            onComplete: () => flash.destroy()\n        });\n        \n        if (this.health <= 0) {\n            this.destroy();\n        }\n    }\n\n    public override destroy(): void {\n        // CRITICAL: Clean up all timers to prevent memory leak\n        if (this.sparkleTimer) {\n            this.sparkleTimer.destroy();\n            this.sparkleTimer = undefined;\n        }\n        if (this.shimmerTimer) {\n            this.shimmerTimer.destroy();\n            this.shimmerTimer = undefined;\n        }\n        if (this.starBurstTimer) {\n            this.starBurstTimer.destroy();\n            this.starBurstTimer = undefined;\n        }\n        if (this.peekTimer) {\n            this.peekTimer.destroy();\n            this.peekTimer = undefined;\n        }\n        \n        // Victory animation - chest opens\n        this.scene.tweens.add({\n            targets: this.chestLid,\n            y: -15,\n            rotation: -0.3,\n            duration: 500,\n            ease: 'Back.easeOut'\n        });\n        \n        // Chest disappears\n        this.scene.tweens.add({\n            targets: this,\n            scale: 1.5,\n            alpha: 0,\n            duration: 1000,\n            delay: 200,\n            ease: 'Power2',\n            onComplete: () => {\n                this.createVictoryParticles();\n                super.destroy();\n            }\n        });\n    }\n\n    private createVictoryParticles(): void {\n        // Create custom particles using circles instead of textures\n        for (let i = 0; i < 20; i++) {\n            const particle = this.scene.add.circle(\n                this.x, \n                this.y, \n                Phaser.Math.Between(3, 6),\n                Phaser.Utils.Array.GetRandom([0xffd700, 0xffa500, 0xff6347]),\n                1\n            );\n            \n            const angle = Math.random() * Math.PI * 2;\n            const speed = Phaser.Math.Between(100, 300);\n            const vx = Math.cos(angle) * speed;\n            const vy = Math.sin(angle) * speed;\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: particle.x + vx,\n                y: particle.y + vy,\n                alpha: 0,\n                scale: 0,\n                duration: 1000,\n                ease: 'Power2',\n                onComplete: () => particle.destroy()\n            });\n        }\n    }\n\n    public getHealth(): number {\n        return this.health;\n    }\n\n    public getMaxHealth(): number {\n        return this.maxHealth;\n    }\n\n    public isVulnerable(): boolean {\n        return !this.shielded;\n    }\n    \n    public isShielded(): boolean {\n        return this.shielded;\n    }\n    \n    public playVictoryAnimation(onComplete?: () => void): void {\n        // Stop any existing animations\n        this.scene.tweens.killTweensOf(this.chestLid);\n        this.scene.tweens.killTweensOf(this.glowEffect);\n        \n        // Hide shield immediately\n        this.shield.setVisible(false);\n        \n        // Glow bright gold (glowEffect is a circle, not graphics)\n        if (this.glowEffect instanceof Phaser.GameObjects.Arc) {\n            this.glowEffect.setFillStyle(0xFFD700, 1);\n        }\n        this.scene.tweens.add({\n            targets: this.glowEffect,\n            scale: 2,\n            alpha: 1,\n            duration: 300,\n            ease: 'Power2'\n        });\n        \n        // Open the chest lid\n        this.scene.tweens.add({\n            targets: this.chestLid,\n            y: -20,\n            angle: -45,\n            duration: 500,\n            ease: 'Back.easeOut',\n            delay: 200\n        });\n        \n        // Create treasure particles manually\n        const particleTimer = this.scene.time.addEvent({\n            delay: 50,\n            repeat: 20,\n            callback: () => {\n                for (let i = 0; i < 5; i++) {\n                    const particle = this.scene.add.circle(\n                        this.x + Phaser.Math.Between(-10, 10),\n                        this.y,\n                        Phaser.Math.Between(4, 8),\n                        Phaser.Utils.Array.GetRandom([0xFFD700, 0xFFA500, 0xFFFF00]),\n                        0.8\n                    );\n                    particle.setDepth(this.depth + 1);\n                    \n                    const angle = Phaser.Math.Between(-120, -60) * Math.PI / 180;\n                    const speed = Phaser.Math.Between(100, 300);\n                    const vx = Math.cos(angle) * speed;\n                    const vy = Math.sin(angle) * speed;\n                    \n                    this.scene.tweens.add({\n                        targets: particle,\n                        x: particle.x + vx,\n                        y: particle.y + vy - 200, // Simulate upward gravity\n                        alpha: 0,\n                        scale: 0,\n                        duration: 1500,\n                        ease: 'Power2',\n                        onComplete: () => particle.destroy()\n                    });\n                }\n            }\n        });\n        \n        // Shake effect\n        this.scene.cameras.main.shake(300, 0.01);\n        \n        // Scale pulse\n        this.scene.tweens.add({\n            targets: this,\n            scale: 1.2,\n            duration: 300,\n            yoyo: true,\n            ease: 'Power2',\n            onComplete: () => {\n                if (onComplete) onComplete();\n                \n                // Stop particle timer\n                this.scene.time.delayedCall(1000, () => {\n                    particleTimer.destroy();\n                });\n            }\n        });\n        \n        // Flash effect\n        this.scene.cameras.main.flash(500, 255, 215, 0);\n    }\n}","import Phaser from 'phaser';\n\nexport interface IInputPosition {\n    x: number;\n    y: number;\n    isActive: boolean;\n}\n\nexport class InputManager {\n    private scene: Phaser.Scene;\n    private pointer: Phaser.Input.Pointer;\n    private currentPosition: IInputPosition;\n    private sensitivity: number = 0.5; // Low sensitivity as per requirements\n    private isEnabled: boolean = true;\n    \n    constructor(scene: Phaser.Scene) {\n        this.scene = scene;\n        this.currentPosition = { x: 0, y: 0, isActive: false };\n        this.setupInput();\n    }\n    \n    private setupInput(): void {\n        // Get the main pointer (works for both mouse and touch)\n        this.pointer = this.scene.input.activePointer;\n        \n        // Enable input events\n        this.scene.input.on('pointermove', this.onPointerMove, this);\n        this.scene.input.on('pointerdown', this.onPointerDown, this);\n        this.scene.input.on('pointerup', this.onPointerUp, this);\n    }\n    \n    private onPointerMove(pointer: Phaser.Input.Pointer): void {\n        if (!this.isEnabled) return;\n        \n        // For initial setup, set position directly\n        if (this.currentPosition.x === 0 && this.currentPosition.y === 0) {\n            this.currentPosition.x = pointer.x;\n            this.currentPosition.y = pointer.y;\n        } else {\n            // Apply sensitivity to smooth out movement\n            const targetX = pointer.x;\n            const targetY = pointer.y;\n            \n            // Smooth interpolation with sensitivity\n            this.currentPosition.x += (targetX - this.currentPosition.x) * this.sensitivity;\n            this.currentPosition.y += (targetY - this.currentPosition.y) * this.sensitivity;\n        }\n    }\n    \n    private onPointerDown(_pointer: Phaser.Input.Pointer): void {\n        if (!this.isEnabled) return;\n        this.currentPosition.isActive = true;\n    }\n    \n    private onPointerUp(_pointer: Phaser.Input.Pointer): void {\n        this.currentPosition.isActive = false;\n    }\n    \n    public getPosition(): IInputPosition {\n        return this.currentPosition;\n    }\n    \n    public getPointerPosition(): { x: number; y: number } {\n        return {\n            x: this.currentPosition.x,\n            y: this.currentPosition.y\n        };\n    }\n    \n    public getAngleFrom(fromX: number, fromY: number): number {\n        const dx = this.currentPosition.x - fromX;\n        const dy = this.currentPosition.y - fromY;\n        \n        // Calculate angle in radians\n        let angle = Math.atan2(dy, dx);\n        \n        // Convert to degrees\n        let degrees = Phaser.Math.RadToDeg(angle);\n        \n        // Normalize to 0-360 range\n        if (degrees < 0) degrees += 360;\n        \n        return degrees;\n    }\n    \n    public getAngleFromWithConstraints(fromX: number, fromY: number, minAngle: number = 15, maxAngle: number = 165): number {\n        let angle = this.getAngleFrom(fromX, fromY);\n        \n        // Apply constraints (assuming 0° is right, 90° is down, 180° is left, 270° is up)\n        // For shooting upward, we want to constrain between 195° (15° from left) and 345° (15° from right)\n        // Adjusting for upward shooting from bottom\n        const constrainedMin = 180 + minAngle; // 195°\n        const constrainedMax = 360 - minAngle;  // 345°\n        \n        // Handle the constraint across the 0° boundary\n        if (angle >= 0 && angle <= 180) {\n            // Left side constraint\n            if (angle < 90) {\n                angle = constrainedMax;\n            } else {\n                angle = constrainedMin;\n            }\n        } else {\n            // Apply normal constraints\n            angle = Phaser.Math.Clamp(angle, constrainedMin, constrainedMax);\n        }\n        \n        return angle;\n    }\n    \n    public setEnabled(enabled: boolean): void {\n        this.isEnabled = enabled;\n    }\n    \n    public isPointerActive(): boolean {\n        return this.currentPosition.isActive;\n    }\n    \n    public setSensitivity(sensitivity: number): void {\n        this.sensitivity = Phaser.Math.Clamp(sensitivity, 0.1, 1.0);\n    }\n    \n    public update(): void {\n        // Update current position if pointer is not active (for mouse hover)\n        if (!this.currentPosition.isActive && this.pointer) {\n            this.currentPosition.x = this.pointer.x;\n            this.currentPosition.y = this.pointer.y;\n        }\n    }\n    \n    public destroy(): void {\n        this.scene.input.off('pointermove', this.onPointerMove, this);\n        this.scene.input.off('pointerdown', this.onPointerDown, this);\n        this.scene.input.off('pointerup', this.onPointerUp, this);\n    }\n}","import Phaser from 'phaser';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\nimport { BubbleColor } from '@/types/ArenaTypes';\n\ninterface ITrajectoryDot {\n    dot: Phaser.GameObjects.Arc;\n    targetAlpha: number;\n}\n\nexport class TrajectoryPreview {\n    private scene: Phaser.Scene;\n    private launcher: Launcher;\n    private dots: ITrajectoryDot[] = [];\n    private dotPool: Phaser.GameObjects.Arc[] = [];\n    private currentBubbleColor: number = 0xFFFFFF;\n    \n    // Preview settings\n    private readonly DOT_COUNT = 22; // More dots for longer preview\n    private readonly DOT_SIZE = 4 * HD_SCALE;\n    private readonly DOT_SPACING = 25 * HD_SCALE; // Slightly more spacing\n    private readonly PREVIEW_PERCENTAGE = 0.45; // Show more of the trajectory\n    private readonly MAX_PREVIEW_DISTANCE = 550 * HD_SCALE; // Much longer preview\n    private readonly SHOOT_SPEED = 600 * HD_SCALE;\n    \n    // Animation\n    private animationTime: number = 0;\n    private isVisible: boolean = false;\n    \n    // Bounds for wall collision\n    private bounds: Phaser.Geom.Rectangle;\n    \n    constructor(scene: Phaser.Scene, launcher: Launcher) {\n        this.scene = scene;\n        this.launcher = launcher;\n        \n        this.bounds = new Phaser.Geom.Rectangle(\n            0,\n            0,\n            scene.cameras.main.width,\n            scene.cameras.main.height\n        );\n        \n        this.createDotPool();\n    }\n    \n    private createDotPool(): void {\n        for (let i = 0; i < this.DOT_COUNT; i++) {\n            const dot = this.scene.add.circle(\n                0, 0,\n                this.DOT_SIZE,\n                0xffffff,\n                0\n            );\n            dot.setDepth(Z_LAYERS.UI - 1);\n            dot.setVisible(false);\n            this.dotPool.push(dot);\n        }\n    }\n    \n    public show(angle: number, bubbleColor?: number): void {\n        if (!this.isVisible) {\n            this.isVisible = true;\n            if (bubbleColor !== undefined) {\n                this.currentBubbleColor = bubbleColor;\n            }\n            this.calculateTrajectory(angle);\n        }\n    }\n    \n    public hide(): void {\n        this.isVisible = false;\n        this.dots.forEach(({ dot }) => {\n            dot.setVisible(false);\n            dot.setAlpha(0);\n        });\n        this.dots = [];\n    }\n    \n    private calculateTrajectory(angle: number): void {\n        // Clear previous dots\n        this.hide();\n        this.isVisible = true;\n        \n        // Starting position\n        let x = this.launcher.x;\n        let y = this.launcher.y - (35 * HD_SCALE); // Scaled bubble position\n        \n        // Calculate velocity from angle\n        // The launcher's getAimDirection uses the angle directly\n        // In world coordinates: 0° = right, 90° = down, 180° = left, 270° = up\n        const radians = Phaser.Math.DegToRad(angle);\n        let vx = Math.cos(radians) * this.SHOOT_SPEED;\n        let vy = Math.sin(radians) * this.SHOOT_SPEED;\n        \n        // Normalize to unit vector for stepping\n        const magnitude = Math.sqrt(vx * vx + vy * vy);\n        vx = (vx / magnitude) * this.DOT_SPACING;\n        vy = (vy / magnitude) * this.DOT_SPACING;\n        \n        // Calculate trajectory points\n        const maxDots = Math.floor(this.DOT_COUNT * this.PREVIEW_PERCENTAGE);\n        let dotIndex = 0;\n        let totalDistance = 0;\n        \n        while (dotIndex < maxDots && totalDistance < this.MAX_PREVIEW_DISTANCE) {\n            // Move to next position\n            x += vx;\n            y += vy;\n            totalDistance += this.DOT_SPACING;\n            \n            // Check for wall collisions\n            const radius = 16; // Bubble radius\n            \n            // Left wall bounce\n            if (x - radius <= this.bounds.left) {\n                x = this.bounds.left + radius;\n                vx = Math.abs(vx);\n            }\n            \n            // Right wall bounce\n            if (x + radius >= this.bounds.right) {\n                x = this.bounds.right - radius;\n                vx = -Math.abs(vx);\n            }\n            \n            // Top wall (stop preview here)\n            if (y - radius <= this.bounds.top) {\n                break;\n            }\n            \n            // Place dot\n            if (dotIndex < this.dotPool.length) {\n                const dot = this.dotPool[dotIndex];\n                dot.setPosition(x, y);\n                dot.setVisible(true);\n                // Calculate fade based on distance\n                const fadeStart = 0.3; // Start more visible\n                const fadeEnd = 0.8; // End still visible\n                const fadeProgress = dotIndex / maxDots;\n                const fadeFactor = fadeStart + (fadeEnd - fadeStart) * fadeProgress;\n                const targetAlpha = 0.95 * (1 - fadeFactor); // Slightly higher visibility\n                \n                this.dots.push({ dot, targetAlpha });\n                dotIndex++;\n            }\n        }\n    }\n    \n    public update(angle: number, delta: number, bubbleColor?: number): void {\n        if (!this.isVisible) return;\n        \n        if (bubbleColor !== undefined) {\n            this.currentBubbleColor = bubbleColor;\n        }\n        \n        // Recalculate trajectory\n        this.calculateTrajectory(angle);\n        \n        // Animate dots\n        this.animationTime += delta;\n        const animSpeed = 0.003;\n        \n        this.dots.forEach(({ dot, targetAlpha }, index) => {\n            // Create moving wave effect\n            const waveOffset = index * 0.15;\n            const wave = Math.sin(this.animationTime * animSpeed + waveOffset);\n            const animatedAlpha = targetAlpha * (0.75 + wave * 0.25); // Slightly more visible\n            \n            // Pulsing size effect - subtle for thinner dots\n            const sizeWave = 1 + wave * 0.2;\n            dot.setScale(sizeWave);\n            \n            // Apply alpha\n            dot.setAlpha(animatedAlpha);\n            \n            // Create gradient based on bubble color\n            const colorProgress = index / this.dots.length;\n            \n            // Get RGB components from bubble color\n            const baseColor = Phaser.Display.Color.IntegerToColor(this.currentBubbleColor);\n            \n            // Create gradient by darkening the color progressively\n            const red = Math.floor(baseColor.red * (1 - colorProgress * 0.4)); // Darken red\n            const green = Math.floor(baseColor.green * (1 - colorProgress * 0.4)); // Darken green  \n            const blue = Math.floor(baseColor.blue * (1 - colorProgress * 0.4)); // Darken blue\n            \n            const color = Phaser.Display.Color.GetColor(red, green, blue);\n            dot.setFillStyle(color);\n            \n            // Add stroke with bubble color for extra visibility\n            dot.setStrokeStyle(1, this.currentBubbleColor, 0.4); // Slightly more visible stroke\n        });\n    }\n    \n    public destroy(): void {\n        this.hide();\n        this.dotPool.forEach(dot => dot.destroy());\n        this.dotPool = [];\n    }\n}","import Phaser from 'phaser';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { BubbleColor } from '@/types/ArenaTypes';\nimport { InputManager } from '@/systems/input/InputManager';\nimport { TrajectoryPreview } from './TrajectoryPreview';\n// BubbleQueue removed - integrated into Launcher\nimport { GridAttachmentSystem } from './GridAttachmentSystem';\nimport { BubbleGrid } from './BubbleGrid';\nimport { ARENA_CONFIG, Z_LAYERS, BUBBLE_CONFIG } from '@/config/ArenaConfig';\nimport { HD_SCALE } from '@/config/GameConfig';\n\nexport interface IProjectile {\n    bubble: Bubble;\n    velocity: Phaser.Math.Vector2;\n    isActive: boolean;\n}\n\nexport class ShootingSystem {\n    private scene: Phaser.Scene;\n    private inputManager: InputManager;\n    private playerLauncher: Launcher;\n    private opponentLauncher?: Launcher;\n    \n    // Shooting mechanics\n    private projectiles: IProjectile[] = [];\n    private currentBubble: Bubble | null = null;\n    private nextBubbleColors: BubbleColor[] = []; // Store next 2-3 colors for launcher rings\n    private availableColors: BubbleColor[] = [\n        BubbleColor.RED,\n        BubbleColor.BLUE, \n        BubbleColor.GREEN,\n        BubbleColor.YELLOW,\n        BubbleColor.PURPLE\n    ];\n    private canShoot: boolean = true;\n    private cooldownTime: number = 1000; // 1 second in milliseconds\n    private shootSpeed: number = 600 * HD_SCALE; // Scaled speed\n    \n    // Arena boundaries for bouncing\n    private bounds: Phaser.Geom.Rectangle;\n    \n    // Cooldown indicator\n    private cooldownBar?: Phaser.GameObjects.Graphics;\n    private cooldownBarBg?: Phaser.GameObjects.Rectangle;\n    \n    // Trajectory preview\n    private trajectoryPreview: TrajectoryPreview;\n    \n    // Grid attachment\n    private gridAttachmentSystem?: GridAttachmentSystem;\n    private bubbleGrid?: BubbleGrid;\n    \n    constructor(\n        scene: Phaser.Scene,\n        inputManager: InputManager,\n        playerLauncher: Launcher,\n        gridAttachmentSystem?: GridAttachmentSystem,\n        bubbleGrid?: BubbleGrid\n    ) {\n        this.scene = scene;\n        this.inputManager = inputManager;\n        this.playerLauncher = playerLauncher;\n        this.gridAttachmentSystem = gridAttachmentSystem;\n        this.bubbleGrid = bubbleGrid;\n        \n        // Set arena bounds for wall bouncing\n        this.bounds = new Phaser.Geom.Rectangle(\n            0,\n            0,\n            scene.cameras.main.width,\n            scene.cameras.main.height\n        );\n        \n        // Initialize trajectory preview\n        this.trajectoryPreview = new TrajectoryPreview(scene, playerLauncher);\n        \n        // Initialize next bubble colors for integrated queue\n        this.generateNextBubbleColors();\n        \n        this.setupShooting();\n    }\n    \n    private setupShooting(): void {\n        // Listen for pointer events\n        this.scene.input.on('pointerdown', this.onPointerDown, this);\n        this.scene.input.on('pointerup', this.onShoot, this);\n        \n        // Listen for AI shoot events\n        this.scene.events.on('ai-shoot', this.onAIShoot, this);\n        \n        // Create cooldown indicator\n        this.createCooldownIndicator();\n        \n        // Initialize bubble queue\n        this.loadNextBubble();\n        \n        // Initialize launcher rings with queue colors\n        this.playerLauncher.updateQueueColors(this.nextBubbleColors);\n    }\n    \n    public setOpponentLauncher(launcher: Launcher): void {\n        this.opponentLauncher = launcher;\n    }\n    \n    private onPointerDown(): void {\n        // Always show trajectory preview when pressing\n        const angle = this.playerLauncher.getAimAngle();\n        \n        // Get bubble color - use current if available, otherwise use next\n        let bubbleColor = 0xFFFFFF; // Default white\n        if (this.currentBubble) {\n            bubbleColor = this.currentBubble.getColor();\n        } else if (this.nextBubbleColors.length > 0) {\n            bubbleColor = this.nextBubbleColors[0];\n        }\n        \n        this.trajectoryPreview.show(angle, bubbleColor);\n    }\n    \n    private createCooldownIndicator(): void {\n        const launcherY = this.playerLauncher.y + 40;\n        \n        // Background bar\n        this.cooldownBarBg = this.scene.add.rectangle(\n            this.playerLauncher.x,\n            launcherY,\n            80,\n            6,\n            0x2c3e50\n        );\n        this.cooldownBarBg.setStrokeStyle(1, 0x34495e);\n        this.cooldownBarBg.setDepth(Z_LAYERS.UI);\n        this.cooldownBarBg.setVisible(false);\n        \n        // Progress bar\n        this.cooldownBar = this.scene.add.graphics();\n        this.cooldownBar.setDepth(Z_LAYERS.UI);\n    }\n    \n    private startCooldownAnimation(): void {\n        this.cooldownBarBg?.setVisible(true);\n        \n        if (!this.cooldownBar) return;\n        \n        const barX = this.playerLauncher.x - 40;\n        const barY = this.playerLauncher.y + 37;\n        const barWidth = 80;\n        const barHeight = 6;\n        \n        // Animate cooldown bar\n        this.scene.tweens.add({\n            targets: { progress: 0 },\n            progress: 1,\n            duration: this.cooldownTime,\n            ease: 'Linear',\n            onUpdate: (tween) => {\n                const progress = tween.getValue();\n                this.cooldownBar?.clear();\n                this.cooldownBar?.fillStyle(0x27ae60, 1);\n                this.cooldownBar?.fillRect(\n                    barX,\n                    barY,\n                    barWidth * progress,\n                    barHeight\n                );\n            },\n            onComplete: () => {\n                this.cooldownBar?.clear();\n            }\n        });\n    }\n    \n    /**\n     * Generates next bubble colors for the integrated queue system\n     */\n    private generateNextBubbleColors(): void {\n        // Generate 3 colors: current + next 2\n        this.nextBubbleColors = [];\n        for (let i = 0; i < 3; i++) {\n            const randomColor = this.availableColors[Math.floor(Math.random() * this.availableColors.length)];\n            this.nextBubbleColors.push(randomColor);\n        }\n        \n        // console.log('ShootingSystem: Generated next bubble colors:', this.nextBubbleColors);\n    }\n    \n    /**\n     * Loads next bubble using integrated queue system\n     */\n    private loadNextBubble(): void {\n        // Get current color (first in queue)\n        const currentColor = this.nextBubbleColors[0] || BubbleColor.BLUE;\n        \n        // console.log('ShootingSystem: Loading bubble color:', currentColor);\n        \n        // Load bubble into launcher\n        this.playerLauncher.loadBubble(currentColor);\n        \n        // Get the loaded bubble from the launcher\n        this.currentBubble = this.playerLauncher.getLoadedBubble();\n        \n        // Shift queue and add new color\n        this.nextBubbleColors.shift(); // Remove current color\n        const newColor = this.availableColors[Math.floor(Math.random() * this.availableColors.length)];\n        this.nextBubbleColors.push(newColor); // Add new color at end\n        \n        // Update launcher queue rings with new colors\n        this.playerLauncher.updateQueueColors(this.nextBubbleColors);\n        \n        // console.log('ShootingSystem: Updated queue colors:', this.nextBubbleColors);\n    }\n    \n    private onShoot(): void {\n        // Hide trajectory preview\n        this.trajectoryPreview.hide();\n        \n        if (!this.canShoot || !this.currentBubble) return;\n        \n        // No turn checking - allow simultaneous shooting\n        \n        // Get launcher angle and direction\n        const angle = this.playerLauncher.getAimAngle();\n        const direction = this.playerLauncher.getAimDirection();\n        \n        // Create velocity vector\n        const velocity = new Phaser.Math.Vector2(\n            direction.x * this.shootSpeed,\n            direction.y * this.shootSpeed\n        );\n        \n        // Remove bubble from launcher before shooting\n        this.playerLauncher.clearLoadedBubble();\n        \n        // Position bubble at launcher's world position for shooting\n        this.currentBubble.setPosition(\n            this.playerLauncher.x,\n            this.playerLauncher.y - 35 // Match bubble position in launcher\n        );\n        \n        // Set bubble to normal size and mark as player shot\n        this.currentBubble.setScale(1);\n        this.currentBubble.setShooter('player');\n        // Return depth to projectile layer\n        this.currentBubble.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        \n        // Add to active projectiles\n        this.projectiles.push({\n            bubble: this.currentBubble,\n            velocity: velocity,\n            isActive: true\n        });\n        \n        // Emit shooting started event\n        this.scene.events.emit('shooting-started');\n        \n        // Emit bubble shoot event for sound system\n        this.scene.events.emit('bubble-shoot');\n        \n        // Play launcher animation with the color of the bubble being shot\n        const shotBubbleColor = this.currentBubble.getColor();\n        this.playerLauncher.animateShoot(shotBubbleColor);\n        \n        // Start cooldown with visual indicator\n        this.canShoot = false;\n        this.startCooldownAnimation();\n        \n        this.scene.time.delayedCall(this.cooldownTime, () => {\n            this.canShoot = true;\n            this.playerLauncher.setHighlight(false);\n            this.cooldownBarBg?.setVisible(false);\n            // Load next bubble after cooldown completes (like opponent)\n            this.loadNextBubble();\n        });\n        \n        // Visual feedback during cooldown\n        this.playerLauncher.setHighlight(true);\n        \n        // Clear current bubble immediately\n        this.currentBubble = null;\n    }\n    \n    private onAIShoot = (data: any): void => {\n        if (!this.opponentLauncher) return;\n        \n        // console.log('ShootingSystem: AI shooting angle=' + data.angle + ' color=0x' + data.color.toString(16));\n        \n        // Use the bubble that AI already has loaded (if provided)\n        let aiBubble: Bubble;\n        if (data.bubble) {\n            // Use the existing bubble from AI\n            aiBubble = data.bubble;\n            aiBubble.setShooter('ai');\n            aiBubble.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        } else {\n            // Fallback: create new bubble (shouldn't happen)\n            // console.warn('ShootingSystem: AI bubble not provided, creating new one');\n            aiBubble = new Bubble(\n                this.scene,\n                this.opponentLauncher.x,\n                this.opponentLauncher.y + 35, // Match bubble position (inverted for opponent)\n                data.color\n            );\n            aiBubble.setShooter('ai');\n            aiBubble.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        }\n        \n        // Calculate velocity based on angle\n        // AI uses standard math angles where:\n        // 0° = right, 90° = down, 180° = left, 270° = up\n        // No conversion needed!\n        const radians = Phaser.Math.DegToRad(data.angle);\n        const velocity = new Phaser.Math.Vector2(\n            Math.cos(radians) * this.shootSpeed,\n            Math.sin(radians) * this.shootSpeed\n        );\n        \n        // console.log(`ShootingSystem: Velocity x=${velocity.x.toFixed(1)} y=${velocity.y.toFixed(1)}`);\n        \n        // Create projectile\n        const projectile: IProjectile = {\n            bubble: aiBubble,\n            velocity: velocity,\n            isActive: true\n        };\n        \n        this.projectiles.push(projectile);\n        \n        // Emit shooting started event\n        this.scene.events.emit('shooting-started', { isAI: true });\n        \n        // Emit AI bubble shoot event for sound system\n        this.scene.events.emit('bubble-shoot', { isAI: true });\n        \n        // Visual feedback on opponent launcher\n        this.opponentLauncher.setHighlight(true);\n        this.scene.time.delayedCall(200, () => {\n            this.opponentLauncher.setHighlight(false);\n        });\n    }\n    \n    public update(delta: number): void {\n        // Update trajectory preview if aiming\n        if (this.inputManager.isPointerActive()) {\n            const angle = this.playerLauncher.getAimAngle();\n            \n            // Get bubble color - use current if available, otherwise use next\n            let bubbleColor = 0xFFFFFF; // Default white\n            if (this.currentBubble) {\n                bubbleColor = this.currentBubble.getColor();\n            } else if (this.nextBubbleColors.length > 0) {\n                bubbleColor = this.nextBubbleColors[0];\n            }\n            \n            this.trajectoryPreview.update(angle, delta, bubbleColor);\n        }\n        \n        // Check for projectile-to-projectile collisions\n        this.checkProjectileCollisions();\n        \n        // Update all active projectiles\n        for (let i = this.projectiles.length - 1; i >= 0; i--) {\n            const projectile = this.projectiles[i];\n            \n            if (!projectile.isActive) {\n                // Remove inactive projectiles\n                this.projectiles.splice(i, 1);\n                continue;\n            }\n            \n            // Update bubble position\n            projectile.bubble.x += projectile.velocity.x * (delta / 1000);\n            projectile.bubble.y += projectile.velocity.y * (delta / 1000);\n            \n            // Emit position update for chest collision detection\n            this.scene.events.emit('bubble-position-update', projectile.bubble);\n            \n            // Check if this bubble was marked as hit (chest collision)\n            if (!projectile.bubble.visible) {\n                projectile.isActive = false;\n                continue;\n            }\n            \n            // Check for grid collision if attachment system is available\n            if (this.gridAttachmentSystem) {\n                const hitBubble = this.gridAttachmentSystem.checkCollision(projectile.bubble);\n                if (hitBubble) {\n                    // Play attach sound immediately on collision detection\n                    this.scene.events.emit('bubble-attach-collision');\n                    \n                    // Find attachment position\n                    const attachPos = this.gridAttachmentSystem.findAttachmentPosition(\n                        projectile.bubble, \n                        hitBubble\n                    );\n                    \n                    if (attachPos) {\n                        // Validate that the position is reasonable (not too far from hit point)\n                        const pixelPos = this.bubbleGrid?.hexToPixel(attachPos);\n                        if (pixelPos) {\n                            const distance = Phaser.Math.Distance.Between(\n                                projectile.bubble.x, projectile.bubble.y,\n                                pixelPos.x, pixelPos.y\n                            );\n                            \n                            // Only attach if distance is reasonable (within 2 bubble diameters)\n                            if (distance < BUBBLE_CONFIG.SIZE * 2) {\n                                projectile.isActive = false;\n                                \n                                // Stop the bubble's movement immediately\n                                projectile.velocity.x = 0;\n                                projectile.velocity.y = 0;\n                                \n                                // Attach to grid with callback\n                                this.gridAttachmentSystem.attachToGrid(projectile.bubble, attachPos, () => {\n                                    // Emit shooting complete event after attachment\n                                    this.scene.events.emit('shooting-complete');\n                                });\n                                \n                                continue;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Check for wall collisions\n            this.checkWallCollision(projectile);\n            \n            // Check if bubble went out of bounds\n            if (projectile.bubble.y < -50 || projectile.bubble.y > this.bounds.height + 50) {\n                projectile.isActive = false;\n                projectile.bubble.destroy();\n            }\n        }\n    }\n    \n    private checkProjectileCollisions(): void {\n        const radius = BUBBLE_CONFIG.SIZE / 2;\n        \n        // Check each projectile against all others\n        for (let i = 0; i < this.projectiles.length; i++) {\n            const proj1 = this.projectiles[i];\n            if (!proj1.isActive) continue;\n            \n            for (let j = i + 1; j < this.projectiles.length; j++) {\n                const proj2 = this.projectiles[j];\n                if (!proj2.isActive) continue;\n                \n                // Calculate distance between projectiles\n                const distance = Phaser.Math.Distance.Between(\n                    proj1.bubble.x, proj1.bubble.y,\n                    proj2.bubble.x, proj2.bubble.y\n                );\n                \n                // Check if collision occurred\n                if (distance < radius * 2) {\n                    // Calculate collision normal\n                    const dx = proj2.bubble.x - proj1.bubble.x;\n                    const dy = proj2.bubble.y - proj1.bubble.y;\n                    const len = Math.sqrt(dx * dx + dy * dy);\n                    \n                    if (len > 0) {\n                        // Normalize\n                        const nx = dx / len;\n                        const ny = dy / len;\n                        \n                        // Separate bubbles\n                        const overlap = (radius * 2) - distance;\n                        proj1.bubble.x -= nx * overlap * 0.5;\n                        proj1.bubble.y -= ny * overlap * 0.5;\n                        proj2.bubble.x += nx * overlap * 0.5;\n                        proj2.bubble.y += ny * overlap * 0.5;\n                        \n                        // Calculate relative velocity\n                        const relVelX = proj2.velocity.x - proj1.velocity.x;\n                        const relVelY = proj2.velocity.y - proj1.velocity.y;\n                        const speed = relVelX * nx + relVelY * ny;\n                        \n                        // Don't resolve if velocities are separating\n                        if (speed < 0) continue;\n                        \n                        // Apply elastic collision with some damping\n                        const impulse = speed * 0.8; // 0.8 = restitution coefficient\n                        \n                        proj1.velocity.x += impulse * nx;\n                        proj1.velocity.y += impulse * ny;\n                        proj2.velocity.x -= impulse * nx;\n                        proj2.velocity.y -= impulse * ny;\n                        \n                        // Add small random deviation to prevent stuck bubbles\n                        proj1.velocity.x += (Math.random() - 0.5) * 20;\n                        proj1.velocity.y += (Math.random() - 0.5) * 20;\n                        proj2.velocity.x += (Math.random() - 0.5) * 20;\n                        proj2.velocity.y += (Math.random() - 0.5) * 20;\n                        \n                        // Emit projectile collision event for sound/haptics\n                        this.scene.events.emit('projectile-collision');\n                    }\n                }\n            }\n        }\n    }\n    \n    private checkWallCollision(projectile: IProjectile): void {\n        const bubble = projectile.bubble;\n        const radius = BUBBLE_CONFIG.SIZE / 2;\n        \n        // Left wall\n        if (bubble.x - radius <= this.bounds.left) {\n            bubble.x = this.bounds.left + radius;\n            projectile.velocity.x = Math.abs(projectile.velocity.x); // Bounce right\n            this.scene.events.emit('wall-bounce');\n        }\n        \n        // Right wall\n        if (bubble.x + radius >= this.bounds.right) {\n            bubble.x = this.bounds.right - radius;\n            projectile.velocity.x = -Math.abs(projectile.velocity.x); // Bounce left\n            this.scene.events.emit('wall-bounce');\n        }\n        \n        // Top wall - bubble explodes when reaching opponent side\n        if (bubble.y - radius <= this.bounds.top) {\n            // Bubble reached the top (opponent zone), explode it\n            projectile.isActive = false;\n            bubble.pop();\n            \n            // TODO: Future feature - if bubble passes near opponent launcher, apply slow debuff\n        }\n    }\n    \n    public isReady(): boolean {\n        return this.canShoot;\n    }\n    \n    public getProjectileCount(): number {\n        return this.projectiles.length;\n    }\n    \n    public destroy(): void {\n        this.scene.input.off('pointerdown', this.onPointerDown, this);\n        this.scene.input.off('pointerup', this.onShoot, this);\n        \n        // Clean up trajectory preview\n        this.trajectoryPreview?.destroy();\n        \n        // Clean up projectiles\n        this.projectiles.forEach(p => {\n            if (p.bubble) p.bubble.destroy();\n        });\n        this.projectiles = [];\n        \n        // Clean up current bubble\n        if (this.currentBubble) {\n            this.currentBubble.destroy();\n        }\n        \n        // Queue is now integrated into launcher - no separate cleanup needed\n        \n        // Clean up cooldown indicator\n        this.cooldownBar?.destroy();\n        this.cooldownBarBg?.destroy();\n    }\n}","import { Scene } from 'phaser';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { BubbleGrid } from './BubbleGrid';\nimport { IHexPosition, ArenaZone } from '@/types/ArenaTypes';\nimport { BUBBLE_CONFIG, Z_LAYERS } from '@/config/ArenaConfig';\nimport { MatchDetectionSystem } from './MatchDetectionSystem';\n\nexport class GridAttachmentSystem {\n    private scene: Scene;\n    private bubbleGrid: BubbleGrid;\n    private gridBubbles: Bubble[] = [];\n    private attachmentInProgress: boolean = false;\n    private attachmentQueue: Array<{ bubble: Bubble; hexPos: IHexPosition; onComplete?: () => void }> = [];\n    private matchDetectionSystem?: MatchDetectionSystem;\n    private spatialGrid: Map<string, Bubble[]> = new Map(); // Spatial partitioning for faster collision\n    private gridPositions: Map<string, Bubble> = new Map(); // Track positions\n    \n    constructor(scene: Scene, bubbleGrid: BubbleGrid) {\n        this.scene = scene;\n        this.bubbleGrid = bubbleGrid;\n    }\n    \n    public setMatchDetectionSystem(matchDetectionSystem: MatchDetectionSystem): void {\n        this.matchDetectionSystem = matchDetectionSystem;\n    }\n    \n    /**\n     * Register a bubble as part of the grid\n     */\n    public addGridBubble(bubble: Bubble): void {\n        if (!this.gridBubbles.includes(bubble)) {\n            this.gridBubbles.push(bubble);\n            this.updateSpatialGrid(); // Update spatial partitioning\n        }\n    }\n    \n    /**\n     * Remove a bubble from the grid\n     */\n    public removeGridBubble(bubble: Bubble): void {\n        const index = this.gridBubbles.indexOf(bubble);\n        if (index > -1) {\n            this.gridBubbles.splice(index, 1);\n            this.updateSpatialGrid(); // Update spatial partitioning\n        }\n    }\n    \n    /**\n     * Check collision between projectile and grid bubbles - OPTIMIZED\n     */\n    public checkCollision(projectile: Bubble): Bubble | null {\n        const projectilePos = { x: projectile.x, y: projectile.y };\n        // Use bubble diameter for collision detection\n        const collisionRadius = BUBBLE_CONFIG.SIZE - 2; // Slightly less than diameter for proper touching\n        \n        // Check objective collision first (if near center)\n        const centerPixel = this.bubbleGrid.hexToPixel({ q: 0, r: 0, s: 0 });\n        const centerDistance = Phaser.Math.Distance.Between(\n            projectilePos.x, projectilePos.y,\n            centerPixel.x, centerPixel.y\n        );\n        \n        // If very close to center and no bubble there, attach to center\n        if (centerDistance < BUBBLE_CONFIG.SIZE && !this.isPositionOccupied({ q: 0, r: 0, s: 0 })) {\n            // Create a virtual bubble at center for attachment reference\n            const virtualBubble = new Bubble(\n                this.scene,\n                centerPixel.x,\n                centerPixel.y,\n                0x000000\n            );\n            virtualBubble.setGridPosition({ q: 0, r: 0, s: 0 });\n            virtualBubble.setVisible(false);\n            return virtualBubble;\n        }\n        \n        // OPTIMIZED: Only check nearby bubbles using spatial partitioning\n        const nearbyBubbles = this.getNearbyBubbles(projectilePos.x, projectilePos.y);\n        \n        for (const gridBubble of nearbyBubbles) {\n            if (!gridBubble.visible) continue;\n            \n            const distance = Phaser.Math.Distance.Between(\n                projectilePos.x, projectilePos.y,\n                gridBubble.x, gridBubble.y\n            );\n            \n            // Check if bubbles are touching\n            if (distance < collisionRadius) {\n                return gridBubble;\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Get bubbles near a position using spatial partitioning\n     */\n    private getNearbyBubbles(x: number, y: number): Bubble[] {\n        // Use a simple grid-based spatial partitioning\n        const gridSize = BUBBLE_CONFIG.SIZE * 2; // Cell size\n        const cellX = Math.floor(x / gridSize);\n        const cellY = Math.floor(y / gridSize);\n        \n        const nearby: Bubble[] = [];\n        \n        // Check current cell and adjacent cells (3x3 grid)\n        for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n                const key = `${cellX + dx},${cellY + dy}`;\n                const cellBubbles = this.spatialGrid.get(key);\n                if (cellBubbles) {\n                    nearby.push(...cellBubbles);\n                }\n            }\n        }\n        \n        return nearby;\n    }\n    \n    /**\n     * Update spatial grid when bubbles are added/removed\n     */\n    private updateSpatialGrid(): void {\n        this.spatialGrid.clear();\n        const gridSize = BUBBLE_CONFIG.SIZE * 2;\n        \n        for (const bubble of this.gridBubbles) {\n            if (!bubble.visible) continue;\n            \n            const cellX = Math.floor(bubble.x / gridSize);\n            const cellY = Math.floor(bubble.y / gridSize);\n            const key = `${cellX},${cellY}`;\n            \n            if (!this.spatialGrid.has(key)) {\n                this.spatialGrid.set(key, []);\n            }\n            this.spatialGrid.get(key)!.push(bubble);\n        }\n    }\n    \n    /**\n     * Find best attachment position based on impact\n     */\n    public findAttachmentPosition(projectile: Bubble, hitBubble: Bubble): IHexPosition | null {\n        // Get hex position of hit bubble\n        const hitHexPos = hitBubble.getGridPosition();\n        if (!hitHexPos) {\n            console.warn('Hit bubble has no grid position');\n            return null;\n        }\n        \n        // console.log('Hit bubble at hex:', hitHexPos, 'pixel:', { x: hitBubble.x, y: hitBubble.y });\n        // console.log('Projectile at:', { x: projectile.x, y: projectile.y });\n        \n        // Calculate impact angle\n        const dx = projectile.x - hitBubble.x;\n        const dy = projectile.y - hitBubble.y;\n        const angle = Math.atan2(dy, dx);\n        const angleDeg = (angle * 180 / Math.PI + 360) % 360;\n        \n        // console.log('Impact angle:', angleDeg.toFixed(1), 'degrees');\n        \n        // For offset grid, we need to consider the row offset when getting neighbors\n        // In an offset grid, odd rows have different neighbor offsets\n        const isOddRow = Math.abs(hitHexPos.r) % 2 === 1;\n        \n        // Define neighbor offsets for offset grid\n        // Even rows and odd rows have different neighbor patterns\n        let neighborOffsets: Array<{q: number, r: number, angle: number}> = [];\n        \n        if (!isOddRow) {\n            // Even row neighbors\n            neighborOffsets = [\n                { q: 0, r: -1, angle: 270 },  // Top\n                { q: 1, r: 0, angle: 0 },     // Right  \n                { q: 0, r: 1, angle: 90 },    // Bottom\n                { q: -1, r: 1, angle: 135 },  // Bottom-left\n                { q: -1, r: 0, angle: 180 },  // Left\n                { q: -1, r: -1, angle: 225 }  // Top-left\n            ];\n        } else {\n            // Odd row neighbors (offset by half)\n            neighborOffsets = [\n                { q: 0, r: -1, angle: 270 },  // Top\n                { q: 1, r: -1, angle: 315 },  // Top-right\n                { q: 1, r: 0, angle: 0 },     // Right\n                { q: 1, r: 1, angle: 45 },    // Bottom-right\n                { q: 0, r: 1, angle: 90 },    // Bottom\n                { q: -1, r: 0, angle: 180 }   // Left\n            ];\n        }\n        \n        // Find the best neighbor based on impact angle\n        let bestNeighbor: IHexPosition | null = null;\n        let minAngleDiff = 360;\n        \n        for (const offset of neighborOffsets) {\n            const neighbor: IHexPosition = {\n                q: hitHexPos.q + offset.q,\n                r: hitHexPos.r + offset.r,\n                s: 0 // Not used in offset grid\n            };\n            \n            // Skip if position is occupied\n            if (this.isPositionOccupied(neighbor)) {\n                // console.log('Position occupied:', neighbor);\n                continue;\n            }\n            \n            // Calculate angle difference\n            let angleDiff = Math.abs(angleDeg - offset.angle);\n            if (angleDiff > 180) angleDiff = 360 - angleDiff;\n            \n            // console.log('Checking neighbor:', neighbor, 'angle:', offset.angle, 'diff:', angleDiff.toFixed(1));\n            \n            // Choose the neighbor with the closest angle match\n            if (angleDiff < minAngleDiff) {\n                minAngleDiff = angleDiff;\n                bestNeighbor = neighbor;\n            }\n        }\n        \n        if (bestNeighbor) {\n            const pixelPos = this.bubbleGrid.hexToPixel(bestNeighbor);\n            // console.log('Best attachment position - hex:', bestNeighbor, 'pixel:', pixelPos);\n        } else {\n            console.warn('No valid attachment position found');\n        }\n        \n        return bestNeighbor;\n    }\n    \n    /**\n     * Find best available position near target\n     */\n    private findBestAvailablePosition(targetHex: IHexPosition, bubble: Bubble): IHexPosition | null {\n        // First check if target is available\n        if (!this.isPositionOccupied(targetHex) && this.isValidPosition(targetHex)) {\n            return targetHex;\n        }\n        \n        // console.log('Target position occupied or invalid, searching alternatives');\n        \n        // Search in expanding rings for available position\n        for (let ring = 1; ring <= 3; ring++) {\n            const ringPositions = this.bubbleGrid.getRing(targetHex, ring);\n            \n            // Find closest available position in this ring\n            let bestPos: IHexPosition | null = null;\n            let minDistance = Infinity;\n            \n            for (const pos of ringPositions) {\n                if (!this.isPositionOccupied(pos) && this.isValidPosition(pos)) {\n                    const pixelPos = this.bubbleGrid.hexToPixel(pos);\n                    const distance = Phaser.Math.Distance.Between(\n                        bubble.x, bubble.y,\n                        pixelPos.x, pixelPos.y\n                    );\n                    \n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        bestPos = pos;\n                    }\n                }\n            }\n            \n            if (bestPos) {\n                // console.log(`Found available position at ring ${ring}:`, bestPos);\n                return bestPos;\n            }\n        }\n        \n        return null;\n    }\n    \n    /**\n     * Check if position is valid (has at least one neighbor)\n     */\n    private isValidPosition(hexPos: IHexPosition): boolean {\n        // Center position is always valid\n        if (hexPos.q === 0 && hexPos.r === 0) return true;\n        \n        // Check if position has at least one neighbor bubble\n        const neighbors = this.bubbleGrid.getNeighbors(hexPos);\n        return neighbors.some(neighbor => this.isPositionOccupied(neighbor));\n    }\n    \n    /**\n     * Check if a hex position is occupied - OPTIMIZED\n     */\n    private isPositionOccupied(hexPos: IHexPosition): boolean {\n        // OPTIMIZED: Use position map for O(1) lookup instead of O(n) iteration\n        const key = this.hexToKey(hexPos);\n        if (this.gridPositions.has(key)) {\n            const bubble = this.gridPositions.get(key);\n            return bubble ? bubble.visible : false;\n        }\n        \n        // Fallback: Check by pixel proximity only for nearby bubbles\n        const pixelPos = this.bubbleGrid.hexToPixel(hexPos);\n        const threshold = BUBBLE_CONFIG.SIZE * 0.8;\n        const nearbyBubbles = this.getNearbyBubbles(pixelPos.x, pixelPos.y);\n        \n        return nearbyBubbles.some(bubble => {\n            if (!bubble.visible) return false;\n            \n            const distance = Phaser.Math.Distance.Between(\n                bubble.x, bubble.y,\n                pixelPos.x, pixelPos.y\n            );\n            \n            return distance < threshold;\n        });\n    }\n    \n    /**\n     * Convert hex position to string key\n     */\n    private hexToKey(hexPos: IHexPosition): string {\n        return `${hexPos.q},${hexPos.r}`;\n    }\n    \n    /**\n     * Attach bubble to grid at specified position\n     */\n    public attachToGrid(bubble: Bubble, hexPos: IHexPosition, onComplete?: () => void): void {\n        if (this.attachmentInProgress) {\n            // console.warn('Attachment already in progress, queueing bubble');\n            // Queue this attachment for later\n            this.attachmentQueue.push({ bubble, hexPos, onComplete });\n            return;\n        }\n        \n        // Validate and find best position\n        hexPos = this.findBestAvailablePosition(hexPos, bubble);\n        \n        if (!hexPos) {\n            console.warn('No valid position found, destroying bubble');\n            bubble.destroy();\n            if (onComplete) onComplete();\n            return;\n        }\n        \n        this.attachmentInProgress = true;\n        \n        // Get exact pixel position for this hex coordinate\n        const pixelPos = this.bubbleGrid.hexToPixel(hexPos);\n        \n        // console.log('Attaching bubble to hex:', hexPos, 'pixel:', pixelPos);\n        \n        // Clean up any existing bubbles that might be misaligned at this position\n        this.cleanupMisalignedBubbles(hexPos, bubble);\n        \n        // Set grid position BEFORE moving\n        bubble.setGridPosition(hexPos);\n        \n        // Update position map for O(1) lookups\n        const key = this.hexToKey(hexPos);\n        this.gridPositions.set(key, bubble);\n        \n        // Add to grid bubbles immediately to prevent double-occupation\n        this.addGridBubble(bubble);\n        \n        // Animate to position\n        const distance = Phaser.Math.Distance.Between(\n            bubble.x, bubble.y,\n            pixelPos.x, pixelPos.y\n        );\n        \n        // Use shorter duration for closer distances\n        const duration = Math.min(200, Math.max(50, distance * 0.5));\n        \n        // Sound is now played earlier in ShootingSystem on collision detection\n        \n        this.scene.tweens.add({\n            targets: bubble,\n            x: pixelPos.x,\n            y: pixelPos.y,\n            duration: duration,\n            ease: 'Power2',\n            onComplete: () => {\n                // Enhanced attachment feedback\n                this.createAttachmentEffect(bubble);\n                \n                // Small bounce effect\n                this.scene.tweens.add({\n                    targets: bubble,\n                    scaleX: 1.15,\n                    scaleY: 1.15,\n                    duration: 80,\n                    ease: 'Back.easeOut',\n                    yoyo: true\n                });\n            }\n        });\n        \n        // Delay slightly before checking matches to ensure position is settled\n        this.scene.time.delayedCall(duration + 100, async () => {\n            // console.log('Attachment complete, checking for matches...');\n            \n            // Verify bubble is properly positioned\n            const finalPixelPos = this.bubbleGrid.hexToPixel(hexPos);\n            if (Phaser.Math.Distance.Between(bubble.x, bubble.y, finalPixelPos.x, finalPixelPos.y) > 5) {\n                // console.warn('Bubble not properly positioned, correcting...');\n                bubble.setPosition(finalPixelPos.x, finalPixelPos.y);\n            }\n            \n            // Check for matches FIRST\n            if (this.matchDetectionSystem) {\n                // console.log('MatchDetectionSystem available, checking bubble color:', bubble.getColor()?.toString(16));\n                await this.matchDetectionSystem.checkForMatches(bubble);\n            } else {\n                console.warn('MatchDetectionSystem not available!');\n            }\n            \n            // Then check for disconnected bubbles\n            this.checkDisconnectedBubbles();\n            \n            this.attachmentInProgress = false;\n            \n            // Emit bubble attached event with data\n            // Only emit if bubble is visible and has a valid position\n            if (bubble.visible && bubble.getGridPosition()) {\n                this.scene.events.emit('bubble-attached', { bubble, position: hexPos });\n            }\n            \n            // If no matches, emit matches-resolved\n            this.scene.time.delayedCall(100, () => {\n                this.scene.events.emit('matches-resolved');\n            });\n            \n            if (onComplete) {\n                onComplete();\n            }\n            \n            // Process queued attachments\n            if (this.attachmentQueue.length > 0) {\n                const next = this.attachmentQueue.shift();\n                if (next) {\n                    this.scene.time.delayedCall(50, () => {\n                        this.attachToGrid(next.bubble, next.hexPos, next.onComplete);\n                    });\n                }\n            }\n        });\n    }\n    \n    /**\n     * Create visual effect when bubble attaches\n     */\n    private createAttachmentEffect(bubble: Bubble): void {\n        const color = bubble.getColor();\n        \n        // Create a ring effect at attachment point\n        const ring = this.scene.add.circle(bubble.x, bubble.y, BUBBLE_CONFIG.SIZE / 2, color, 0);\n        ring.setStrokeStyle(2, color, 0.6);\n        ring.setDepth(bubble.depth - 1);\n        \n        // Animate ring expansion\n        this.scene.tweens.add({\n            targets: ring,\n            scale: 1.5,\n            alpha: 0,\n            duration: 300,\n            ease: 'Power2',\n            onComplete: () => {\n                ring.destroy();\n            }\n        });\n        \n        // Small particle burst\n        for (let i = 0; i < 4; i++) {\n            const particle = this.scene.add.circle(\n                bubble.x,\n                bubble.y,\n                2,\n                color,\n                0.8\n            );\n            \n            const angle = (Math.PI * 2 * i) / 4;\n            const distance = 20;\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: bubble.x + Math.cos(angle) * distance,\n                y: bubble.y + Math.sin(angle) * distance,\n                scale: 0,\n                alpha: 0,\n                duration: 250,\n                ease: 'Power2',\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n    }\n    \n    /**\n     * Clean up any misaligned bubbles at position\n     */\n    private cleanupMisalignedBubbles(hexPos: IHexPosition, newBubble: Bubble): void {\n        const pixelPos = this.bubbleGrid.hexToPixel(hexPos);\n        const threshold = BUBBLE_CONFIG.SIZE * 0.9;\n        \n        // Find and remove any bubbles too close to this position\n        const toRemove: Bubble[] = [];\n        \n        this.gridBubbles.forEach(bubble => {\n            if (bubble === newBubble || !bubble.visible) return;\n            \n            const distance = Phaser.Math.Distance.Between(\n                bubble.x, bubble.y,\n                pixelPos.x, pixelPos.y\n            );\n            \n            if (distance < threshold) {\n                // console.warn('Found overlapping bubble, removing it:', bubble.getGridPosition());\n                toRemove.push(bubble);\n            }\n        });\n        \n        // Remove overlapping bubbles\n        toRemove.forEach(bubble => {\n            this.removeGridBubble(bubble);\n            bubble.destroy();\n        });\n    }\n    \n    /**\n     * Check for disconnected bubbles after attachment\n     */\n    private checkDisconnectedBubbles(): void {\n        const disconnected = this.findDisconnectedGroups();\n        \n        // Apply bidirectional gravity based on Y position, not zone\n        const allDisconnected: Bubble[] = [];\n        disconnected.forEach((bubbles) => {\n            allDisconnected.push(...bubbles);\n        });\n        \n        if (allDisconnected.length > 0) {\n            this.applyBidirectionalGravity(allDisconnected);\n        }\n    }\n    \n    /**\n     * Find all disconnected bubble groups by zone\n     */\n    public findDisconnectedGroups(): Map<ArenaZone, Bubble[]> {\n        const disconnected = new Map<ArenaZone, Bubble[]>();\n        disconnected.set(ArenaZone.PLAYER, []);\n        disconnected.set(ArenaZone.OPPONENT, []);\n        disconnected.set(ArenaZone.OBJECTIVE, []);\n        \n        // Mark all bubbles as unvisited\n        const visited = new Set<Bubble>();\n        const connected = new Set<Bubble>();\n        \n        // Find bubbles adjacent to the objective (center position)\n        const centerHex: IHexPosition = { q: 0, r: 0, s: 0 };\n        const anchors: Bubble[] = [];\n        \n        // Get bubbles at center and immediate neighbors as anchors\n        const centerBubble = this.getBubbleAtPosition(centerHex);\n        if (centerBubble) {\n            anchors.push(centerBubble);\n        }\n        \n        // Get neighbors of center as additional anchors\n        const centerNeighbors = this.bubbleGrid.getNeighbors(centerHex);\n        centerNeighbors.forEach(neighborHex => {\n            const bubble = this.getBubbleAtPosition(neighborHex);\n            if (bubble) {\n                anchors.push(bubble);\n            }\n        });\n        \n        // If no anchors (no bubbles near objective), all bubbles are disconnected\n        if (anchors.length === 0) {\n            // console.log('No anchors found - all bubbles are floating!');\n            this.gridBubbles.forEach(bubble => {\n                if (bubble.visible) {\n                    const zone = this.getZoneForBubble(bubble);\n                    disconnected.get(zone)?.push(bubble);\n                }\n            });\n            return disconnected;\n        }\n        \n        // console.log(`Found ${anchors.length} anchor bubbles near objective`);\n        \n        // Flood fill from each anchor to find connected bubbles\n        anchors.forEach(anchor => {\n            this.floodFill(anchor, visited, connected);\n        });\n        \n        // console.log(`${connected.size} bubbles are connected to objective`);\n        \n        // Any unvisited bubbles are disconnected and should fall\n        this.gridBubbles.forEach(bubble => {\n            if (!connected.has(bubble) && bubble.visible) {\n                const zone = this.getZoneForBubble(bubble);\n                disconnected.get(zone)?.push(bubble);\n            }\n        });\n        \n        // Log disconnected counts\n        disconnected.forEach((bubbles, zone) => {\n            if (bubbles.length > 0) {\n                // console.log(`${bubbles.length} disconnected bubbles in ${zone} zone`);\n            }\n        });\n        \n        return disconnected;\n    }\n    \n    /**\n     * Flood fill to find connected bubbles\n     */\n    private floodFill(bubble: Bubble, visited: Set<Bubble>, connected: Set<Bubble>): void {\n        if (visited.has(bubble)) return;\n        visited.add(bubble);\n        connected.add(bubble);\n        \n        const hexPos = bubble.getGridPosition();\n        if (!hexPos) return;\n        \n        // Get neighbors\n        const neighbors = this.bubbleGrid.getNeighbors(hexPos);\n        \n        // Check each neighbor\n        neighbors.forEach(neighborHex => {\n            const neighborBubble = this.getBubbleAtPosition(neighborHex);\n            if (neighborBubble && !visited.has(neighborBubble)) {\n                this.floodFill(neighborBubble, visited, connected);\n            }\n        });\n    }\n    \n    /**\n     * Get bubble at specific hex position\n     */\n    private getBubbleAtPosition(hexPos: IHexPosition): Bubble | null {\n        return this.gridBubbles.find(bubble => {\n            const pos = bubble.getGridPosition();\n            return pos && pos.q === hexPos.q && pos.r === hexPos.r;\n        }) || null;\n    }\n    \n    /**\n     * Determine which zone a bubble is in based on Y position\n     */\n    private getZoneForBubble(bubble: Bubble): ArenaZone {\n        const screenHeight = this.scene.cameras.main.height;\n        const objectiveTop = screenHeight * 0.4; // 40% from top\n        const objectiveBottom = screenHeight * 0.6; // 60% from top\n        \n        if (bubble.y < objectiveTop) {\n            return ArenaZone.OPPONENT;\n        } else if (bubble.y > objectiveBottom) {\n            return ArenaZone.PLAYER;\n        } else {\n            return ArenaZone.OBJECTIVE;\n        }\n    }\n    \n    /**\n     * Apply bidirectional gravity to disconnected bubbles\n     */\n    public applyBidirectionalGravity(bubbles: Bubble[]): void {\n        const centerY = this.scene.cameras.main.centerY;\n        \n        // Group bubbles by their fall direction\n        const fallingUp: Bubble[] = [];\n        const fallingDown: Bubble[] = [];\n        \n        bubbles.forEach(bubble => {\n            if (bubble.y < centerY) {\n                // Bubbles above center fall up\n                fallingUp.push(bubble);\n            } else {\n                // Bubbles below center fall down\n                fallingDown.push(bubble);\n            }\n        });\n        \n        // Animate each group with appropriate direction\n        if (fallingUp.length > 0) {\n            // console.log(`${fallingUp.length} bubbles falling UP (above center)`);\n            this.animateFallingBubbles(fallingUp, 'up');\n        }\n        \n        if (fallingDown.length > 0) {\n            // console.log(`${fallingDown.length} bubbles falling DOWN (below center)`);\n            this.animateFallingBubbles(fallingDown, 'down');\n        }\n    }\n    \n    /**\n     * Animate bubbles falling in specified direction\n     */\n    private animateFallingBubbles(bubbles: Bubble[], direction: 'up' | 'down'): void {\n        const outOfBounds = direction === 'down' \n            ? this.scene.cameras.main.height + 100\n            : -100;\n        \n        // Sort bubbles by distance from center for cascade effect\n        const centerX = this.scene.cameras.main.centerX;\n        bubbles.sort((a, b) => {\n            const distA = Math.abs(a.x - centerX);\n            const distB = Math.abs(b.x - centerX);\n            return distA - distB;\n        });\n        \n        bubbles.forEach((bubble, index) => {\n            // Remove from grid immediately\n            this.removeGridBubble(bubble);\n            const oldPos = bubble.getGridPosition();\n            if (oldPos) {\n                const key = this.hexToKey(oldPos);\n                this.gridPositions.delete(key);\n            }\n            bubble.setGridPosition(null);\n            \n            // Add slight random horizontal movement for natural falling\n            const horizontalDrift = Phaser.Math.Between(-30, 30);\n            const rotationSpeed = Phaser.Math.Between(-Math.PI * 2, Math.PI * 2);\n            \n            // Flash before falling\n            bubble.setTint(0xFFFFFF);\n            this.scene.time.delayedCall(100, () => {\n                bubble.clearTint();\n            });\n            \n            // Animate falling with physics-like acceleration\n            this.scene.tweens.add({\n                targets: bubble,\n                y: outOfBounds,\n                x: bubble.x + horizontalDrift,\n                rotation: rotationSpeed,\n                scale: 0.8,\n                alpha: 0.3,\n                duration: 800 + index * 20, // Vary duration for natural effect\n                ease: 'Quad.easeIn',\n                delay: index * 30, // Stagger the falls for cascade effect\n                onComplete: () => {\n                    // Award points based on position\n                    // Bubbles falling from opponent side (up direction) give more points\n                    const points = direction === 'up' ? 15 : 10;\n                    \n                    this.scene.events.emit('bubble-dropped', { \n                        direction: direction, \n                        points: points,\n                        color: bubble.getColor()\n                    });\n                    \n                    // Return to pool\n                    bubble.returnToPool();\n                }\n            });\n        });\n        \n        // Add screen shake for large groups\n        if (bubbles.length >= 5) {\n            this.scene.cameras.main.shake(150, 0.002);\n        }\n    }\n    \n    /**\n     * Get all grid bubbles\n     */\n    public getGridBubbles(): Bubble[] {\n        return this.gridBubbles;\n    }\n    \n    /**\n     * Clear all grid bubbles\n     */\n    public clearGrid(): void {\n        this.gridBubbles = [];\n    }\n    \n    /**\n     * Debug: Visualize connections\n     */\n    public debugDrawConnections(graphics: Phaser.GameObjects.Graphics): void {\n        graphics.lineStyle(1, 0x00ff00, 0.5);\n        \n        this.gridBubbles.forEach(bubble => {\n            const hexPos = bubble.getGridPosition();\n            if (!hexPos) return;\n            \n            const neighbors = this.bubbleGrid.getNeighbors(hexPos);\n            neighbors.forEach(neighborHex => {\n                const neighborBubble = this.getBubbleAtPosition(neighborHex);\n                if (neighborBubble) {\n                    graphics.lineBetween(\n                        bubble.x, bubble.y,\n                        neighborBubble.x, neighborBubble.y\n                    );\n                }\n            });\n        });\n    }\n    \n    /**\n     * Fast O(1) check if a grid position has a bubble\n     * Used for performance optimization in updateObjectiveShield\n     */\n    public hasGridPosition(gridKey: string): boolean {\n        return this.gridPositions.has(gridKey);\n    }\n}","import { Scene } from 'phaser';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { BubbleGrid } from './BubbleGrid';\nimport { GridAttachmentSystem } from './GridAttachmentSystem';\nimport { BubbleColor, IHexPosition, ArenaZone } from '@/types/ArenaTypes';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { MysteryBubble } from '@/gameObjects/MysteryBubble';\n\nexport class MatchDetectionSystem {\n    private scene: Scene;\n    private bubbleGrid: BubbleGrid;\n    private gridAttachmentSystem: GridAttachmentSystem;\n    \n    // Match settings\n    private minimumMatchSize: number = 3;\n    private isProcessing: boolean = false;\n    \n    // Scoring\n    private totalScore: number = 0;\n    private combo: number = 0;\n    private lastMatchTime: number = 0;\n    private comboTimeout: number = 2000; // 2 seconds\n    \n    constructor(\n        scene: Scene,\n        bubbleGrid: BubbleGrid,\n        gridAttachmentSystem: GridAttachmentSystem\n    ) {\n        this.scene = scene;\n        this.bubbleGrid = bubbleGrid;\n        this.gridAttachmentSystem = gridAttachmentSystem;\n    }\n    \n    /**\n     * Check for matches after a bubble attaches\n     */\n    public async checkForMatches(attachedBubble: Bubble): Promise<void> {\n        if (this.isProcessing || !attachedBubble.visible) return;\n        \n        const color = attachedBubble.getColor();\n        if (color === undefined || color === null) {\n            // Only log critical errors\n            console.error('Bubble has no color, skipping match detection');\n            return;\n        }\n        \n        this.isProcessing = true;\n        \n        // Find connected bubbles of same color\n        const matches = this.findColorMatches(attachedBubble, color);\n        \n        if (matches.size >= this.minimumMatchSize) {\n            \n            // Calculate center position BEFORE any animations or removal\n            // Use world positions to account for any container transformations\n            let avgX = 0, avgY = 0;\n            let bubbleColor: BubbleColor | undefined;\n            matches.forEach(bubble => {\n                // Get world position of each bubble\n                const worldPos = bubble.getWorldTransformMatrix();\n                avgX += worldPos.tx;\n                avgY += worldPos.ty;\n                if (!bubbleColor) {\n                    bubbleColor = bubble.getColor();\n                }\n            });\n            avgX /= matches.size;\n            avgY /= matches.size;\n            \n            // Determine if this was an AI or player match based on the attached bubble\n            const isAIMatch = attachedBubble.getShooter() === 'ai';\n            \n            // Highlight matches briefly before removing\n            this.highlightMatches(Array.from(matches));\n            \n            // Wait a moment to show the highlight\n            await new Promise(resolve => setTimeout(resolve, 200));\n            \n            // Update combo\n            this.updateCombo();\n            \n            // Calculate score\n            const score = this.calculateScore(matches);\n            this.totalScore += score;\n            \n            // Emit match found event for sound system\n            this.scene.events.emit('match-found', {\n                matchSize: matches.size,\n                combo: this.combo,\n                isAI: isAIMatch,\n                x: avgX,\n                y: avgY,\n                bubbleColor: bubbleColor\n            });\n            \n            // Emit score update event BEFORE removal animations\n            this.scene.events.emit('score-update', {\n                score: this.totalScore,\n                delta: score,\n                combo: this.combo,\n                isAI: isAIMatch,\n                matchSize: matches.size,\n                x: avgX,\n                y: avgY,\n                bubbleColor: bubbleColor\n            });\n            \n            // Emit bubble explosion event for visual effects\n            // Create splatters at each bubble position for more realistic effect\n            if (bubbleColor !== undefined) {\n                // Collect all bubble positions\n                const positions: { x: number, y: number }[] = [];\n                matches.forEach(bubble => {\n                    const worldPos = bubble.getWorldTransformMatrix();\n                    positions.push({ x: worldPos.tx, y: worldPos.ty });\n                });\n                \n                // Emit event with all positions\n                this.scene.events.emit('bubble-exploded', {\n                    x: avgX,  // Keep center for compatibility\n                    y: avgY,\n                    positions: positions,  // All individual positions\n                    color: bubbleColor,\n                    comboMultiplier: matches.size\n                });\n                \n                // Emit audio event for pleasant pop sounds\n                this.scene.events.emit('bubbles-popped', {\n                    color: bubbleColor,\n                    count: matches.size\n                });\n            }\n            \n            // Remove matched bubbles (Mystery bubbles will activate their power-ups when destroyed)\n            // Pass !isAIMatch to indicate if it was a player shot\n            await this.removeMatches(Array.from(matches), !isAIMatch);\n            \n            // Check for floating bubbles after removal\n            this.checkFloatingBubbles();\n            \n            // Emit match event\n            this.scene.events.emit('match-completed', {\n                count: matches.size,\n                score: score,\n                totalScore: this.totalScore,\n                combo: this.combo\n            });\n        }\n        \n        this.isProcessing = false;\n    }\n    \n    /**\n     * Find all connected bubbles of the same color (Mystery bubbles match any color)\n     */\n    private findColorMatches(startBubble: Bubble, targetColor: BubbleColor): Set<Bubble> {\n        const matches = new Set<Bubble>();\n        const visited = new Set<Bubble>();\n        const queue: Bubble[] = [startBubble];\n        \n        while (queue.length > 0) {\n            const current = queue.shift()!;\n            \n            // Skip if already visited\n            if (visited.has(current)) continue;\n            visited.add(current);\n            \n            // Check if bubble color matches target color\n            const colorMatches = current.getColor() === targetColor;\n            \n            // Skip if wrong color or not visible\n            // Mystery Bubbles must ALSO match the color, they're not wildcards\n            if (!current.visible || !colorMatches) {\n                continue;\n            }\n            \n            // Add to matches\n            matches.add(current);\n            \n            // Get neighbors\n            const neighbors = this.getNeighborBubbles(current);\n            for (const neighbor of neighbors) {\n                if (!visited.has(neighbor)) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        return matches;\n    }\n    \n    /**\n     * Get neighboring bubbles\n     */\n    private getNeighborBubbles(bubble: Bubble): Bubble[] {\n        const neighbors: Bubble[] = [];\n        const hexPos = bubble.getGridPosition();\n        if (!hexPos) return neighbors;\n        \n        // Get hex neighbors\n        const hexNeighbors = this.bubbleGrid.getNeighbors(hexPos);\n        const gridBubbles = this.gridAttachmentSystem.getGridBubbles();\n        \n        for (const neighborHex of hexNeighbors) {\n            const neighborBubble = gridBubbles.find(b => {\n                const pos = b.getGridPosition();\n                return pos && \n                       pos.q === neighborHex.q && \n                       pos.r === neighborHex.r &&\n                       b.visible;\n            });\n            \n            if (neighborBubble) {\n                neighbors.push(neighborBubble);\n            }\n        }\n        \n        return neighbors;\n    }\n    \n    /**\n     * Highlight bubbles that are about to be matched\n     */\n    private highlightMatches(bubbles: Bubble[]): void {\n        bubbles.forEach(bubble => {\n            // Kill any existing tweens on this bubble to prevent conflicts\n            this.scene.tweens.killTweensOf(bubble);\n            \n            // Create a pulsing effect\n            this.scene.tweens.add({\n                targets: bubble,\n                scaleX: 1.2,\n                scaleY: 1.2,\n                duration: 100,\n                yoyo: true,\n                repeat: 1,\n                ease: 'Sine.easeInOut'\n            });\n            \n            // Add a glow effect\n            bubble.setTint(0xFFFFFF);\n        });\n    }\n    \n    /**\n     * Remove matched bubbles with animation\n     */\n    private async removeMatches(bubbles: Bubble[], isPlayerShot: boolean): Promise<void> {\n        // First, check for and handle Mystery Bubbles BEFORE removal\n        bubbles.forEach(bubble => {\n            if (bubble instanceof MysteryBubble) {\n                // console.log('Found MysteryBubble in matches, collecting power-up for', isPlayerShot ? 'player' : 'opponent');\n                (bubble as MysteryBubble).collectPowerUp(isPlayerShot);\n            }\n        });\n        \n        // Sort bubbles by distance from center for staggered animation\n        const centerX = bubbles.reduce((sum, b) => sum + b.x, 0) / bubbles.length;\n        const centerY = bubbles.reduce((sum, b) => sum + b.y, 0) / bubbles.length;\n        \n        bubbles.sort((a, b) => {\n            const distA = Phaser.Math.Distance.Between(a.x, a.y, centerX, centerY);\n            const distB = Phaser.Math.Distance.Between(b.x, b.y, centerX, centerY);\n            return distA - distB;\n        });\n        \n        // Score popup is handled by ComboManager now\n        \n        // Determine animation style based on match size\n        const matchSize = bubbles.length;\n        const animationStyle = this.getPopAnimationStyle(matchSize);\n        \n        // Animate removal\n        const promises: Promise<void>[] = [];\n        \n        bubbles.forEach((bubble, index) => {\n            const promise = new Promise<void>((resolve) => {\n                // Kill any existing tweens to prevent conflicts\n                this.scene.tweens.killTweensOf(bubble);\n                \n                // Clear tint and ensure bubble is in correct state\n                bubble.clearTint();\n                bubble.setVisible(true);\n                bubble.setAlpha(1);\n                bubble.setScale(1);\n                \n                // Particle effect only for 4+ matches\n                if (matchSize >= 4) {\n                    const bubbleColor = bubble.getColor();\n                    if (bubbleColor !== undefined && bubbleColor !== null) {\n                        this.createParticles(bubble.x, bubble.y, bubbleColor);\n                    }\n                }\n                \n                // Different animations based on combo size\n                if (matchSize === 3) {\n                    // Simple fade for 3-match\n                    this.scene.tweens.add({\n                        targets: bubble,\n                        scale: 0.8,\n                        alpha: 0,\n                        duration: 150,\n                        ease: 'Power2',\n                        delay: index * 15,\n                        onComplete: () => {\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                } else if (matchSize === 4) {\n                    // Gentle pop for 4-match\n                    this.scene.tweens.add({\n                        targets: bubble,\n                        scale: 1.2,\n                        alpha: 0,\n                        duration: 200,\n                        ease: 'Back.easeOut',\n                        delay: index * 20,\n                        onComplete: () => {\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                } else if (matchSize === 5) {\n                    // Bouncy pop for 5-match\n                    this.scene.tweens.add({\n                        targets: bubble,\n                        scale: { from: 1, to: 1.4 },\n                        alpha: 0,\n                        y: bubble.y - 10,\n                        duration: 250,\n                        ease: 'Bounce.easeOut',\n                        delay: index * 25,\n                        onComplete: () => {\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                } else if (matchSize === 6) {\n                    // Spiral out for 6-match\n                    const angle = (index / bubbles.length) * Math.PI * 2;\n                    this.scene.tweens.add({\n                        targets: bubble,\n                        x: bubble.x + Math.cos(angle) * 30,\n                        y: bubble.y + Math.sin(angle) * 30,\n                        scale: 1.5,\n                        alpha: 0,\n                        angle: 180,\n                        duration: 300,\n                        ease: 'Cubic.easeOut',\n                        delay: index * 20,\n                        onComplete: () => {\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                } else {\n                    // Explosive scatter for 7+ match\n                    const explosionAngle = Math.random() * Math.PI * 2;\n                    const explosionDistance = Phaser.Math.Between(50, 100);\n                    \n                    // Ensure bubble is properly set up before animation\n                    bubble.clearTint();\n                    bubble.setVisible(true);\n                    bubble.setAlpha(1);\n                    \n                    this.scene.tweens.add({\n                        targets: bubble,\n                        x: bubble.x + Math.cos(explosionAngle) * explosionDistance,\n                        y: bubble.y + Math.sin(explosionAngle) * explosionDistance,\n                        scale: 0,  // Simplified to just scale to 0\n                        alpha: 0,\n                        angle: 360,\n                        duration: 400,\n                        ease: 'Power3.easeOut',\n                        delay: index * 10,\n                        onComplete: () => {\n                            // Make sure bubble is properly cleaned up\n                            bubble.setVisible(false);\n                            bubble.clearTint();\n                            bubble.setScale(1);\n                            bubble.setAlpha(1);\n                            bubble.setAngle(0);\n                            this.gridAttachmentSystem.removeGridBubble(bubble);\n                            bubble.setGridPosition(null);\n                            bubble.returnToPool();\n                            resolve();\n                        }\n                    });\n                }\n            });\n            promises.push(promise);\n        });\n        \n        // Screen shake only for large matches\n        if (bubbles.length >= 6) {\n            this.scene.cameras.main.shake(150, 0.002);\n        }\n        \n        await Promise.all(promises);\n    }\n    \n    private getPopAnimationStyle(matchSize: number): string {\n        if (matchSize === 3) return 'fade';\n        if (matchSize === 4) return 'pop';\n        if (matchSize === 5) return 'bounce';\n        if (matchSize === 6) return 'spiral';\n        return 'explode';\n    }\n    \n    /**\n     * Check for floating bubbles after removal\n     */\n    private checkFloatingBubbles(): void {\n        const disconnected = this.gridAttachmentSystem.findDisconnectedGroups();\n        \n        // Collect all disconnected bubbles\n        const allDisconnected: Bubble[] = [];\n        disconnected.forEach((bubbles) => {\n            allDisconnected.push(...bubbles);\n        });\n        \n        if (allDisconnected.length > 0) {\n            // Calculate center position for bonus display\n            let avgX = 0, avgY = 0;\n            allDisconnected.forEach(bubble => {\n                avgX += bubble.x;\n                avgY += bubble.y;\n            });\n            avgX /= allDisconnected.length;\n            avgY /= allDisconnected.length;\n            \n            // Count bubbles by direction\n            const centerY = this.scene.cameras.main.centerY;\n            const upwardBubbles = allDisconnected.filter(b => b.y < centerY).length;\n            const downwardBubbles = allDisconnected.filter(b => b.y >= centerY).length;\n            \n            // Calculate bonus score (10 points per orphan bubble)\n            const bonusPerBubble = 10;\n            const totalOrphanBonus = allDisconnected.length * bonusPerBubble;\n            \n            if (totalOrphanBonus > 0) {\n                this.totalScore += totalOrphanBonus;\n                \n                // DISABLED: Visual feedback now handled by UnifiedFeedbackSystem\n                // this.showOrphanBonus(avgX, avgY, allDisconnected.length, totalOrphanBonus);\n                \n                // Emit floating bubbles drop event for sound system\n                this.scene.events.emit('floating-bubbles-drop', {\n                    count: allDisconnected.length,\n                    x: avgX,\n                    y: avgY\n                });\n                \n                // Emit score update for orphan bonus with adjusted Y position\n                // Determine shooter based on which side had more bubbles\n                const isAIBonus = upwardBubbles > downwardBubbles;\n                \n                this.scene.events.emit('score-update', {\n                    score: this.totalScore,\n                    delta: totalOrphanBonus,\n                    combo: 0,\n                    isAI: isAIBonus,\n                    matchSize: 0, // 0 indicates orphan bonus\n                    x: avgX,\n                    y: avgY + 40, // Offset down to avoid overlap with match score\n                    isOrphanBonus: true,\n                    metadata: {\n                        dropCount: allDisconnected.length\n                    }\n                });\n            }\n            \n            // Apply bidirectional gravity\n            this.gridAttachmentSystem.applyBidirectionalGravity(allDisconnected);\n        }\n    }\n    \n    /**\n     * Show orphan bonus visual feedback\n     */\n    private showOrphanBonus(x: number, y: number, count: number, bonus: number): void {\n        // Offset y position to avoid overlapping with combo displays\n        const adjustedY = y + 30; // Move down to avoid overlap\n        \n        // Create container for bonus display\n        const bonusContainer = this.scene.add.container(x, adjustedY);\n        bonusContainer.setDepth(Z_LAYERS.UI + 15); // Higher depth to ensure visibility\n        \n        // Create comic-style drop bonus text\n        const dropText = this.scene.add.text(0, -8, 'DROP BONUS', {\n            fontSize: '18px',\n            color: '#00FFFF',\n            fontFamily: 'Impact, Arial Black', // Comic style\n            fontStyle: 'bold',\n            stroke: '#000000',\n            strokeThickness: 3\n        });\n        dropText.setOrigin(0.5);\n        dropText.setShadow(1, 1, '#0066CC', 2, true, true);\n        \n        // Create points text with comic style\n        const pointsText = this.scene.add.text(0, 12, `+${bonus}`, {\n            fontSize: '22px',\n            color: '#FFD700',\n            fontFamily: 'Impact, Arial Black', // Comic style\n            fontStyle: 'bold',\n            stroke: '#000000',\n            strokeThickness: 3\n        });\n        pointsText.setOrigin(0.5);\n        \n        bonusContainer.add([dropText, pointsText]);\n        bonusContainer.setScale(0);\n        \n        // Elegant entrance animation\n        this.scene.tweens.add({\n            targets: bonusContainer,\n            scale: { from: 0, to: 1.1 },\n            duration: 250,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                // Subtle settle\n                this.scene.tweens.add({\n                    targets: bonusContainer,\n                    scale: 1,\n                    duration: 100,\n                    ease: 'Sine.easeInOut'\n                });\n            }\n        });\n        \n        // Float down instead of up to differentiate from combo text\n        this.scene.time.delayedCall(700, () => {\n            this.scene.tweens.add({\n                targets: bonusContainer,\n                y: adjustedY + 40, // Float down\n                alpha: 0,\n                scale: 0.9,\n                duration: 600,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    bonusContainer.destroy(true);\n                }\n            });\n        });\n        \n        // Create sparkle particles at adjusted position\n        this.createDropParticles(x, adjustedY, count);\n    }\n    \n    private createDropParticles(x: number, y: number, count: number): void {\n        const particleCount = Math.min(count * 3, 15);\n        \n        for (let i = 0; i < particleCount; i++) {\n            const particle = this.scene.add.circle(\n                x + Phaser.Math.Between(-20, 20),\n                y + Phaser.Math.Between(-20, 20),\n                3,\n                0x00FFFF,\n                0.8\n            );\n            particle.setDepth(Z_LAYERS.UI + 5);\n            \n            // Sparkle animation\n            this.scene.tweens.add({\n                targets: particle,\n                y: particle.y - Phaser.Math.Between(30, 60),\n                alpha: 0,\n                scale: 0,\n                duration: Phaser.Math.Between(500, 800),\n                delay: i * 20,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n    }\n    \n    /**\n     * Calculate score for matches\n     */\n    private calculateScore(matches: Set<Bubble>): number {\n        let score = 0;\n        \n        // Base score (10 per bubble)\n        score = matches.size * 10;\n        \n        // Size bonus\n        if (matches.size > 3) {\n            score += (matches.size - 3) * 5;\n        }\n        \n        // Combo multiplier\n        if (this.combo > 0) {\n            score = Math.floor(score * (1 + this.combo * 0.2));\n        }\n        \n        // Zone bonus\n        let zoneMultiplier = 1;\n        matches.forEach(bubble => {\n            const zone = this.getZone(bubble);\n            if (zone === ArenaZone.OPPONENT) {\n                zoneMultiplier = Math.max(zoneMultiplier, 2);\n            } else if (zone === ArenaZone.OBJECTIVE) {\n                zoneMultiplier = Math.max(zoneMultiplier, 1.5);\n            }\n        });\n        \n        score = Math.floor(score * zoneMultiplier);\n        \n        return score;\n    }\n    \n    /**\n     * Update combo counter\n     */\n    private updateCombo(): void {\n        const now = Date.now();\n        \n        if (now - this.lastMatchTime < this.comboTimeout) {\n            this.combo++;\n        } else {\n            this.combo = 0;\n        }\n        \n        this.lastMatchTime = now;\n    }\n    \n    /**\n     * Get zone for bubble\n     */\n    private getZone(bubble: Bubble): ArenaZone {\n        const screenHeight = this.scene.cameras.main.height;\n        const objectiveTop = screenHeight * 0.4;\n        const objectiveBottom = screenHeight * 0.6;\n        \n        if (bubble.y < objectiveTop) {\n            return ArenaZone.OPPONENT;\n        } else if (bubble.y > objectiveBottom) {\n            return ArenaZone.PLAYER;\n        } else {\n            return ArenaZone.OBJECTIVE;\n        }\n    }\n    \n    /**\n     * Create particle effects\n     */\n    private createParticles(x: number, y: number, color: BubbleColor): void {\n        const particleCount = 6;\n        \n        for (let i = 0; i < particleCount; i++) {\n            const particle = this.scene.add.circle(\n                x, y, 4,\n                color,\n                1\n            );\n            particle.setDepth(Z_LAYERS.BUBBLES);\n            \n            const angle = (i / particleCount) * Math.PI * 2;\n            const speed = Phaser.Math.Between(50, 150);\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: x + Math.cos(angle) * speed,\n                y: y + Math.sin(angle) * speed,\n                alpha: 0,\n                scale: 0,\n                duration: 400,\n                ease: 'Power2',\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n    }\n    \n    // Score popup removed - handled by ComboManager\n    \n    /**\n     * Get current score\n     */\n    public getScore(): number {\n        return this.totalScore;\n    }\n    \n    /**\n     * Reset system\n     */\n    public reset(): void {\n        this.totalScore = 0;\n        this.combo = 0;\n        this.lastMatchTime = 0;\n        this.isProcessing = false;\n    }\n}","import Phaser from 'phaser';\nimport { Launcher } from '@/gameObjects/Launcher';\n// BubbleQueue removed - integrated into Launcher\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { BubbleColor } from '@/types/ArenaTypes';\nimport { BUBBLE_CONFIG, ARENA_CONFIG, Z_LAYERS } from '@/config/ArenaConfig';\n\nexport enum AIDifficulty {\n    EASY = 'EASY',\n    MEDIUM = 'MEDIUM',\n    HARD = 'HARD'\n}\n\ninterface IShootTarget {\n    angle: number;\n    useWallBounce: 'none' | 'left' | 'right';\n    targetBubble?: Bubble;\n    score: number;\n    reasoning: string;\n    potentialFalls?: number; // Number of bubbles that would fall\n    totalValue?: number; // Total value including falls\n}\n\nexport class AIOpponentSystem {\n    private scene: Phaser.Scene;\n    private launcher: Launcher;\n    private currentBubble: Bubble | null = null; // Track loaded bubble\n    private nextBubbleColors: BubbleColor[] = []; // Store next 2-3 colors for launcher rings\n    private availableColors: BubbleColor[] = [\n        BubbleColor.RED,\n        BubbleColor.BLUE, \n        BubbleColor.GREEN,\n        BubbleColor.YELLOW,\n        BubbleColor.PURPLE\n    ];\n    private isActive: boolean = false;\n    private shootTimer?: Phaser.Time.TimerEvent;\n    private difficulty: AIDifficulty = AIDifficulty.HARD;\n    private isOnCooldown: boolean = false;\n    private readonly COOLDOWN_TIME: number = 1000; // Same as player - 1 second\n    private readonly SHOOT_SPEED: number = 600; // Same as player\n    \n    constructor(scene: Phaser.Scene, launcher: Launcher) {\n        this.scene = scene;\n        this.launcher = launcher;\n        \n        // Initialize next bubble colors for integrated queue\n        this.generateNextBubbleColors();\n        \n        // Listen for shooting complete to know when we can shoot again\n        this.scene.events.on('shooting-complete', this.onShootingComplete, this);\n    }\n    \n    public setDifficulty(difficulty: AIDifficulty): void {\n        this.difficulty = difficulty;\n    }\n    \n    public start(): void {\n        this.isActive = true;\n        // console.log('AI: Starting with difficulty', this.difficulty);\n        \n        // Set initial downward angle for opponent\n        this.launcher.setAimAngle(90); // 90 degrees = straight down for opponent\n        \n        // Load first bubble\n        this.loadNextBubble();\n        // Start thinking about first shot\n        this.scheduleNextShot();\n    }\n    \n    public stop(): void {\n        this.isActive = false;\n        if (this.shootTimer) {\n            this.shootTimer.destroy();\n            this.shootTimer = undefined;\n        }\n        \n        // Clean up current bubble when stopping\n        if (this.currentBubble) {\n            this.currentBubble.destroy();\n            this.currentBubble = null;\n        }\n    }\n    \n    /**\n     * Generates next bubble colors for the integrated queue system\n     */\n    private generateNextBubbleColors(): void {\n        // Generate 3 colors: current + next 2\n        this.nextBubbleColors = [];\n        for (let i = 0; i < 3; i++) {\n            const randomColor = this.availableColors[Math.floor(Math.random() * this.availableColors.length)];\n            this.nextBubbleColors.push(randomColor);\n        }\n        \n        // console.log('AI: Generated next bubble colors:', this.nextBubbleColors);\n    }\n    \n    /**\n     * Loads next bubble using integrated queue system\n     */\n    private loadNextBubble(): void {\n        // Get current color (first in queue)\n        const currentColor = this.nextBubbleColors[0] || BubbleColor.BLUE;\n        \n        // console.log(`AI loadNextBubble: Loading bubble color ${currentColor} hex=0x${currentColor.toString(16)}`);\n        \n        // Load bubble into launcher\n        this.launcher.loadBubble(currentColor);\n        \n        // Get the loaded bubble from the launcher\n        this.currentBubble = this.launcher.getLoadedBubble();\n        \n        // Shift queue and add new color\n        this.nextBubbleColors.shift(); // Remove current color\n        const newColor = this.availableColors[Math.floor(Math.random() * this.availableColors.length)];\n        this.nextBubbleColors.push(newColor); // Add new color at end\n        \n        // Update launcher queue rings with new colors\n        this.launcher.updateQueueColors(this.nextBubbleColors);\n        \n        // console.log('AI: Updated queue colors:', this.nextBubbleColors);\n    }\n    \n    private scheduleNextShot(): void {\n        if (!this.isActive || this.isOnCooldown) return;\n        \n        // Decision time based on difficulty (thinking time, not shooting speed)\n        let thinkingTime: number;\n        switch (this.difficulty) {\n            case AIDifficulty.EASY:\n                thinkingTime = 3000 + Math.random() * 2000; // 3-5 seconds to think\n                break;\n            case AIDifficulty.MEDIUM:\n                thinkingTime = 2000 + Math.random() * 1000; // 2-3 seconds to think\n                break;\n            case AIDifficulty.HARD:\n                thinkingTime = 1000 + Math.random() * 500; // 1-1.5 seconds (still quick but more thoughtful)\n                break;\n        }\n        \n        this.shootTimer = this.scene.time.delayedCall(thinkingTime, () => {\n            if (this.isActive && !this.isOnCooldown) {\n                this.performShot();\n            }\n        });\n    }\n    \n    private performShot(): void {\n        if (this.isOnCooldown || !this.currentBubble) return;\n        \n        const color = this.currentBubble.getColor();\n        const bubbleId = this.currentBubble.getData('bubbleId');\n        \n        // Find best shot based on difficulty\n        const target = this.calculateBestShot(color);\n        \n        // console.log(`🎯 AI shooting: ID=${bubbleId} ${this.getColorName(color)} at ${target.angle.toFixed(1)}° (${target.reasoning}) score=${target.score}`);\n        \n        // Update launcher aim\n        this.launcher.setAimAngle(target.angle);\n        \n        // Store the bubble for shooting (don't destroy it yet!)\n        const bubbleToShoot = this.currentBubble;\n        this.currentBubble = null;\n        \n        // Remove bubble from launcher before shooting\n        this.launcher.clearLoadedBubble();\n        \n        // Animate the launcher shooting with the bubble color\n        this.launcher.animateShoot(color);\n        \n        // Position bubble at launcher's world position for shooting\n        bubbleToShoot.setPosition(\n            this.launcher.x,\n            this.launcher.y + 30  // Opponent shoots from below\n        );\n        \n        // Reset bubble for shooting\n        bubbleToShoot.setScale(1);\n        bubbleToShoot.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        \n        // Emit shoot event WITH THE BUBBLE\n        this.scene.events.emit('ai-shoot', {\n            angle: target.angle,\n            color: color,\n            bubble: bubbleToShoot  // Pass the actual bubble!\n        });\n        \n        // Start cooldown (same as player!)\n        this.isOnCooldown = true;\n        this.scene.time.delayedCall(this.COOLDOWN_TIME, () => {\n            this.isOnCooldown = false;\n            // Load next bubble after cooldown\n            this.loadNextBubble();\n            // Schedule next shot after cooldown\n            this.scheduleNextShot();\n        });\n    }\n    \n    private calculateBestShot(color: BubbleColor): IShootTarget {\n        const gridBubbles = this.getGridBubbles();\n        const sameColorBubbles = gridBubbles.filter(b => b.getColor() === color);\n        \n        // BALANCED: Use all same color bubbles for smart AI\n        const closestBubbles = sameColorBubbles; // Use all for now to keep AI smart\n        \n        let bestTarget: IShootTarget | null = null;\n        \n        if (this.difficulty === AIDifficulty.HARD) {\n            // PRIORITY 1: Check if we can hit the objective directly!\n            const objectiveShot = this.checkObjectiveShot();\n            if (objectiveShot) {\n                // console.log(`  🎯 WINNING SHOT AVAILABLE! Direct path to objective!`);\n                return objectiveShot;\n            }\n            // PRIORITY 2: Smart targeting for strategic eliminations\n            let allTargets: IShootTarget[] = [];\n            \n            // First, check if we should prioritize clearing path to objective\n            const objectiveExposed = this.isObjectiveExposed();\n            if (!objectiveExposed) {\n                // console.log(`  🏯 Objective is protected - need to clear path`);\n                // Prioritize bubbles near the objective\n                const centerX = this.scene.cameras.main.centerX;\n                const centerY = this.scene.cameras.main.centerY;\n                \n                // Find bubbles blocking the objective\n                const blockingBubbles = sameColorBubbles.filter(b => {\n                    const dist = Phaser.Math.Distance.Between(b.x, b.y, centerX, centerY);\n                    return dist < BUBBLE_CONFIG.SIZE * 4; // Near objective\n                });\n                \n                if (blockingBubbles.length > 0) {\n                    // console.log(`  🎯 Found ${blockingBubbles.length} same-color bubbles near objective`);\n                    sameColorBubbles.unshift(...blockingBubbles); // Prioritize these\n                }\n            }\n            \n            if (closestBubbles.length > 0) {\n                // OPTIMIZED: Only analyze closest bubbles, not ALL\n                for (const targetBubble of closestBubbles) {\n                    // OPTIMIZED: Try 3 key angles for good coverage\n                    const angles = [\n                        this.calculateAngleToTarget(targetBubble.x, targetBubble.y),\n                        this.calculateAngleToTarget(targetBubble.x, targetBubble.y - BUBBLE_CONFIG.SIZE),\n                        this.calculateAngleToTarget(targetBubble.x - BUBBLE_CONFIG.SIZE * 0.5, targetBubble.y)\n                    ];\n                    \n                    for (const angle of angles) {\n                        if (angle >= 15 && angle <= 165) {\n                            const targetPos = { x: targetBubble.x, y: targetBubble.y };\n                            // OPTIMIZED: Better trajectory check\n                            if (this.isTrajectoryLikelyClear(angle, targetPos)) {\n                                // OPTIMIZED: Use smarter match counting\n                                const matchSize = this.countPotentialMatch(targetBubble, color);\n                                const potentialFalls = matchSize >= 3 ? 2 : 0; // Simple fall estimation\n                                \n                                // Check distance to objective for priority\n                                const centerX = this.scene.cameras.main.centerX;\n                                const centerY = this.scene.cameras.main.centerY;\n                                const distToObjective = Phaser.Math.Distance.Between(targetBubble.x, targetBubble.y, centerX, centerY);\n                                const nearObjective = distToObjective < BUBBLE_CONFIG.SIZE * 4;\n                                \n                                // Higher base score if near objective\n                                const baseScore = nearObjective ? 200 + (matchSize * 30) : 100 + (matchSize * 20);\n                                const fallBonus = potentialFalls * 300;\n                                \n                                allTargets.push({\n                                    angle: angle,\n                                    useWallBounce: 'none',\n                                    targetBubble: targetBubble,\n                                    score: baseScore + fallBonus,\n                                    totalValue: baseScore + fallBonus,\n                                    potentialFalls: potentialFalls,\n                                    reasoning: `match-${matchSize}${potentialFalls > 0 ? ` causing ${potentialFalls} falls` : ''}${nearObjective ? ' NEAR OBJECTIVE' : ''}`\n                                });\n                                \n                                // Found a good shot, but keep looking for better ones\n                                break; // But still check other bubbles\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // OPTIMIZED: Include basic wall bounce for smart plays\n            if (closestBubbles.length > 0 && closestBubbles.length < 5) {\n                // Only check wall bounces when there are few targets\n                const bounceTargets = this.findWallBounceTargets(color, closestBubbles.slice(0, 3));\n                allTargets.push(...bounceTargets);\n            }\n            \n            // Pick the best target from all analyzed\n            if (allTargets.length > 0) {\n                allTargets.sort((a, b) => (b.totalValue || b.score) - (a.totalValue || a.score));\n                bestTarget = allTargets[0];\n                // console.log(`  📊 Analyzed ${allTargets.length} possible shots`);\n                // console.log(`  🎯 Best shot: ${bestTarget.reasoning} (score: ${bestTarget.totalValue || bestTarget.score})`);\n            }\n        }\n        \n        // If no strategic shot found (or easier difficulty), find ANY valid shot\n        if (!bestTarget) {\n            bestTarget = this.findStraightShotTarget(sameColorBubbles);\n        }\n        \n        // If still no direct shot, try ANY bubble we can hit\n        if (!bestTarget) {\n            const allBubbles = this.getGridBubbles();\n            for (const bubble of allBubbles) {\n                const angle = this.calculateAngleToTarget(bubble.x, bubble.y);\n                if (angle >= 15 && angle <= 165) {\n                    const targetPos = { x: bubble.x, y: bubble.y };\n                    if (this.isTrajectoryLikelyClear(angle, targetPos)) {\n                        bestTarget = {\n                            angle: angle,\n                            useWallBounce: 'none',\n                            score: 10,\n                            reasoning: 'any available target'\n                        };\n                        break;\n                    }\n                }\n            }\n        }\n        \n        // Absolutely last resort - shoot at safe angles\n        if (!bestTarget) {\n            const safeAngles = [85, 90, 95, 75, 105];\n            const randomAngle = safeAngles[Math.floor(Math.random() * safeAngles.length)];\n            bestTarget = {\n                angle: randomAngle,\n                useWallBounce: 'none',\n                score: 0,\n                reasoning: 'safe fallback'\n            };\n        }\n        \n        return bestTarget;\n    }\n    \n    private findStraightShotTarget(sameColorBubbles: Bubble[]): IShootTarget | null {\n        // Find any bubble we can hit directly\n        const gridBubbles = this.getGridBubbles();\n        const allTargets = sameColorBubbles.length > 0 ? sameColorBubbles : gridBubbles;\n        \n        for (const bubble of allTargets) {\n            const angle = this.calculateAngleToTarget(bubble.x, bubble.y);\n            \n            // Check if angle is within launcher constraints\n            if (angle >= 15 && angle <= 165) {\n                const targetPos = { x: bubble.x, y: bubble.y };\n                if (this.isTrajectoryLikelyClear(angle, targetPos)) {\n                    return {\n                        angle: angle,\n                        useWallBounce: 'none',\n                        targetBubble: bubble,\n                        score: 50,\n                        reasoning: `direct shot to ${this.getColorName(bubble.getColor())}`\n                    };\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n    private findTargetsViaWallBounce(color: BubbleColor): IShootTarget[] {\n        const targets: IShootTarget[] = [];\n        const gridBubbles = this.getGridBubbles();\n        const sameColorBubbles = gridBubbles.filter(b => b.getColor() === color);\n        \n        // Check each same-color bubble for possible wall bounces\n        for (const bubble of sameColorBubbles) {\n            // Check possible attachment points around the bubble\n            const attachPoints = this.getAttachmentPoints(bubble);\n            \n            for (const point of attachPoints) {\n                // Check how many same-color bubbles would be connected from this point\n                const wouldConnect = this.countConnectedBubbles(point, color, sameColorBubbles);\n                \n                if (wouldConnect >= 2) { // Would make at least match-3\n                    const angle = this.calculateAngleToTarget(point.x, point.y);\n                    \n                    // Check if angle is valid and trajectory is clear\n                    if (angle >= 15 && angle <= 165 && this.isTrajectoryLikelyClear(angle, point)) {\n                        targets.push({\n                            angle: angle,\n                            useWallBounce: 'none',\n                            targetBubble: bubble,\n                            score: 100 + wouldConnect * 50,\n                            reasoning: `match-${wouldConnect + 1}`\n                        });\n                    }\n                }\n            }\n        }\n        \n        // Sort by score (best first)\n        return targets.sort((a, b) => b.score - a.score);\n    }\n    \n    private findWallBounceTargets(color: BubbleColor, sameColorBubbles: Bubble[]): IShootTarget[] {\n        const targets: IShootTarget[] = [];\n        const screenWidth = this.scene.cameras.main.width;\n        \n        for (const bubble of sameColorBubbles) {\n            // Left wall bounce\n            const mirrorX = -bubble.x; // Mirror across left wall\n            const leftBounceAngle = this.calculateAngleToTarget(mirrorX, bubble.y);\n            if (leftBounceAngle >= 100 && leftBounceAngle <= 165) { // Must aim left\n                targets.push({\n                    angle: leftBounceAngle,\n                    useWallBounce: 'left',\n                    targetBubble: bubble,\n                    score: 80,\n                    reasoning: 'left wall bounce'\n                });\n            }\n            \n            // Right wall bounce\n            const mirrorX2 = screenWidth + (screenWidth - bubble.x); // Mirror across right wall\n            const rightBounceAngle = this.calculateAngleToTarget(mirrorX2, bubble.y);\n            if (rightBounceAngle >= 15 && rightBounceAngle <= 80) { // Must aim right\n                targets.push({\n                    angle: rightBounceAngle,\n                    useWallBounce: 'right',\n                    targetBubble: bubble,\n                    score: 80,\n                    reasoning: 'right wall bounce'\n                });\n            }\n        }\n        \n        return targets.sort((a, b) => b.score - a.score);\n    }\n    \n    private findBestWallBounce(color: BubbleColor, targets: Bubble[]): IShootTarget | null {\n        for (const bubble of targets) {\n            // Try left wall bounce\n            const leftMirrorX = -bubble.x;\n            const leftAngle = this.calculateAngleToTarget(leftMirrorX, bubble.y);\n            if (leftAngle >= 100 && leftAngle <= 165) {\n                // Verify the bounce path is clear\n                const bouncePoint = { x: 0, y: this.launcher.y + Math.tan(leftAngle * Math.PI / 180) * this.launcher.x };\n                if (this.isTrajectoryLikelyClear(leftAngle, bouncePoint)) {\n                    return {\n                        angle: leftAngle,\n                        useWallBounce: 'left',\n                        score: 100,\n                        reasoning: `left bounce to ${this.getColorName(color)}`\n                    };\n                }\n            }\n            \n            // Try right wall bounce\n            const screenWidth = this.scene.cameras.main.width;\n            const rightMirrorX = screenWidth + (screenWidth - bubble.x);\n            const rightAngle = this.calculateAngleToTarget(rightMirrorX, bubble.y);\n            if (rightAngle >= 15 && rightAngle <= 80) {\n                // Verify the bounce path is clear\n                const bouncePoint = { x: screenWidth, y: this.launcher.y + Math.tan(rightAngle * Math.PI / 180) * (screenWidth - this.launcher.x) };\n                if (this.isTrajectoryLikelyClear(rightAngle, bouncePoint)) {\n                    return {\n                        angle: rightAngle,\n                        useWallBounce: 'right',\n                        score: 100,\n                        reasoning: `right bounce to ${this.getColorName(color)}`\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    \n    private getAttachmentPoints(bubble: Bubble): { x: number, y: number }[] {\n        const points: { x: number, y: number }[] = [];\n        const size = BUBBLE_CONFIG.SIZE;\n        \n        // Six hexagonal neighbor positions\n        const offsets = [\n            { x: size, y: 0 },        // Right\n            { x: -size, y: 0 },       // Left\n            { x: size/2, y: -size * 0.866 },   // Top-right\n            { x: -size/2, y: -size * 0.866 },  // Top-left\n            { x: size/2, y: size * 0.866 },    // Bottom-right\n            { x: -size/2, y: size * 0.866 }    // Bottom-left\n        ];\n        \n        for (const offset of offsets) {\n            points.push({\n                x: bubble.x + offset.x,\n                y: bubble.y + offset.y\n            });\n        }\n        \n        return points;\n    }\n    \n    private countConnectedBubbles(point: { x: number, y: number }, color: BubbleColor, bubbles: Bubble[]): number {\n        let count = 0;\n        const threshold = BUBBLE_CONFIG.SIZE * 1.1;\n        \n        for (const bubble of bubbles) {\n            const dist = Phaser.Math.Distance.Between(point.x, point.y, bubble.x, bubble.y);\n            if (dist < threshold) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    private calculateAngleToTarget(targetX: number, targetY: number): number {\n        const dx = targetX - this.launcher.x;\n        const dy = targetY - this.launcher.y;\n        \n        // Calculate angle in radians, then convert to degrees\n        // Using Math.atan2 which gives angle from -PI to PI\n        let angle = Math.atan2(dy, dx);\n        \n        // Convert to degrees\n        angle = angle * (180 / Math.PI);\n        \n        // Normalize to 0-360 range\n        if (angle < 0) angle += 360;\n        \n        return angle;\n    }\n    \n    private isTrajectoryClear(angle: number, target: { x: number, y: number }): boolean {\n        // OPTIMIZED: Reduced trajectory simulation\n        const radians = angle * (Math.PI / 180);\n        const velocity = {\n            x: Math.cos(radians) * this.SHOOT_SPEED,\n            y: Math.sin(radians) * this.SHOOT_SPEED\n        };\n        \n        let testX = this.launcher.x;\n        let testY = this.launcher.y;\n        const targetDist = Phaser.Math.Distance.Between(this.launcher.x, this.launcher.y, target.x, target.y);\n        \n        // OPTIMIZED: Check reasonable points (10 instead of 20)\n        const steps = 10;\n        const stepDist = targetDist / steps;\n        \n        for (let i = 1; i < steps; i++) {\n            const t = (stepDist * i) / this.SHOOT_SPEED;\n            testX = this.launcher.x + velocity.x * t;\n            testY = this.launcher.y + velocity.y * t;\n            \n            // Check if we hit any bubble before reaching target\n            const gridBubbles = this.getGridBubbles();\n            for (const bubble of gridBubbles) {\n                const dist = Phaser.Math.Distance.Between(testX, testY, bubble.x, bubble.y);\n                if (dist < BUBBLE_CONFIG.SIZE * 0.8) {\n                    // Check if this is our target\n                    const targetDist = Phaser.Math.Distance.Between(bubble.x, bubble.y, target.x, target.y);\n                    if (targetDist > BUBBLE_CONFIG.SIZE) {\n                        return false; // Hit something else first\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    private getGridBubbles(): Bubble[] {\n        // Get all bubbles from the grid\n        const bubbles: Bubble[] = [];\n        this.scene.children.list.forEach(child => {\n            if (child instanceof Bubble && child.visible && child.getGridPosition()) {\n                bubbles.push(child);\n            }\n        });\n        return bubbles;\n    }\n    \n    private getColorName(color: BubbleColor): string {\n        switch(color) {\n            case BubbleColor.RED: return 'RED';\n            case BubbleColor.BLUE: return 'BLUE';\n            case BubbleColor.GREEN: return 'GREEN';\n            case BubbleColor.YELLOW: return 'YELLOW';\n            case BubbleColor.PURPLE: return 'PURPLE';\n            case BubbleColor.MYSTERY: return 'MYSTERY';\n            default: return 'UNKNOWN';\n        }\n    }\n    \n    /**\n     * OPTIMIZED: Get strategic bubbles for analysis (not just closest)\n     */\n    private getClosestBubbles(bubbles: Bubble[], limit: number): Bubble[] {\n        // Sort by strategic value: closer to objective and easier to hit\n        const centerX = this.scene.cameras.main.centerX;\n        const centerY = this.scene.cameras.main.centerY;\n        \n        const sorted = bubbles.sort((a, b) => {\n            // Consider both distance to launcher AND distance to objective\n            const distA = Phaser.Math.Distance.Between(this.launcher.x, this.launcher.y, a.x, a.y);\n            const distB = Phaser.Math.Distance.Between(this.launcher.x, this.launcher.y, b.x, b.y);\n            \n            const objDistA = Phaser.Math.Distance.Between(a.x, a.y, centerX, centerY);\n            const objDistB = Phaser.Math.Distance.Between(b.x, b.y, centerX, centerY);\n            \n            // Prioritize bubbles near objective but also reachable\n            const scoreA = distA * 0.3 + objDistA * 0.7;\n            const scoreB = distB * 0.3 + objDistB * 0.7;\n            \n            return scoreA - scoreB;\n        });\n        return sorted.slice(0, limit);\n    }\n    \n    /**\n     * OPTIMIZED: Quick trajectory check without full simulation\n     */\n    private isTrajectoryLikelyClear(angle: number, target: { x: number, y: number }): boolean {\n        // More lenient path checking for better AI performance\n        const gridBubbles = this.getGridBubbles();\n        const radians = angle * Math.PI / 180;\n        const direction = {\n            x: Math.cos(radians),\n            y: Math.sin(radians)\n        };\n        \n        const targetDist = Phaser.Math.Distance.Between(this.launcher.x, this.launcher.y, target.x, target.y);\n        \n        // Check only a few key points along the path\n        for (let t = 0.3; t < 0.9; t += 0.3) {\n            const checkX = this.launcher.x + direction.x * targetDist * t;\n            const checkY = this.launcher.y + direction.y * targetDist * t;\n            \n            // Check if any bubble blocks this point\n            for (const bubble of gridBubbles) {\n                if (!bubble.visible) continue;\n                const dist = Phaser.Math.Distance.Between(checkX, checkY, bubble.x, bubble.y);\n                if (dist < BUBBLE_CONFIG.SIZE * 0.7) { // More lenient collision\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * OPTIMIZED: Quick match count without recursion\n     */\n    private quickCountPotentialMatch(targetBubble: Bubble, shootColor: BubbleColor): number {\n        // Just count immediate neighbors of same color\n        const neighbors = this.getNeighborBubbles(targetBubble);\n        let count = 1; // Include the shot itself\n        for (const neighbor of neighbors) {\n            if (neighbor.getColor() === shootColor) {\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    private countPotentialMatch(targetBubble: Bubble, shootColor: BubbleColor): number {\n        const visited = new Set<Bubble>();\n        const toCheck = [targetBubble];\n        let matchCount = 1; // Count the shot bubble itself\n        \n        // Find all connected same-color bubbles\n        while (toCheck.length > 0) {\n            const current = toCheck.pop()!;\n            if (visited.has(current)) continue;\n            visited.add(current);\n            \n            // Only count if same color as what we're shooting\n            if (current.getColor() === shootColor) {\n                if (current !== targetBubble) matchCount++;\n                \n                // Check neighbors\n                const neighbors = this.getNeighborBubbles(current);\n                for (const neighbor of neighbors) {\n                    if (!visited.has(neighbor) && neighbor.getColor() === shootColor) {\n                        toCheck.push(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return matchCount;\n    }\n    \n    private predictFallsFromShot(targetBubble: Bubble, shootColor: BubbleColor): number {\n        // Simulate what would happen if we made this match\n        const matchSize = this.countPotentialMatch(targetBubble, shootColor);\n        \n        if (matchSize < 3) return 0; // No match, no falls\n        \n        // This is a simplified prediction - in reality we'd need to simulate the full match and fall\n        // For now, estimate based on position\n        const neighbors = this.getNeighborBubbles(targetBubble);\n        let potentialFalls = 0;\n        \n        for (const neighbor of neighbors) {\n            if (neighbor.getColor() !== shootColor) {\n                // Check if this bubble would be disconnected\n                const supportingNeighbors = this.getNeighborBubbles(neighbor);\n                const wouldLoseSupport = supportingNeighbors.filter(n => \n                    n === targetBubble || n.getColor() === shootColor\n                ).length >= supportingNeighbors.length - 1;\n                \n                if (wouldLoseSupport) {\n                    potentialFalls++;\n                }\n            }\n        }\n        \n        return potentialFalls;\n    }\n    \n    private getNeighborBubbles(bubble: Bubble): Bubble[] {\n        const neighbors: Bubble[] = [];\n        const gridBubbles = this.getGridBubbles();\n        const threshold = BUBBLE_CONFIG.SIZE * 1.1;\n        \n        for (const other of gridBubbles) {\n            if (other === bubble) continue;\n            const dist = Phaser.Math.Distance.Between(bubble.x, bubble.y, other.x, other.y);\n            if (dist < threshold) {\n                neighbors.push(other);\n            }\n        }\n        \n        return neighbors;\n    }\n    \n    private checkObjectiveShot(): IShootTarget | null {\n        const centerX = this.scene.cameras.main.centerX;\n        const centerY = this.scene.cameras.main.centerY;\n        \n        // Calculate angle to objective\n        const angle = this.calculateAngleToTarget(centerX, centerY);\n        \n        // Check if angle is valid\n        if (angle >= 15 && angle <= 165) {\n            // Check if path is clear\n            const target = { x: centerX, y: centerY };\n            if (this.isTrajectoryLikelyClear(angle, target)) {\n                return {\n                    angle: angle,\n                    useWallBounce: 'none',\n                    score: 10000, // Winning shot!\n                    reasoning: '🏆 DIRECT HIT ON OBJECTIVE!'\n                };\n            }\n        }\n        \n        return null;\n    }\n    \n    private isObjectiveExposed(): boolean {\n        const centerX = this.scene.cameras.main.centerX;\n        const centerY = this.scene.cameras.main.centerY;\n        const gridBubbles = this.getGridBubbles();\n        \n        // Check if any bubbles are very close to objective\n        for (const bubble of gridBubbles) {\n            const dist = Phaser.Math.Distance.Between(bubble.x, bubble.y, centerX, centerY);\n            if (dist < BUBBLE_CONFIG.SIZE * 1.5) {\n                return false; // Objective is protected\n            }\n        }\n        \n        return true; // Objective is exposed\n    }\n    \n    private onShootingComplete = (): void => {\n        // AI doesn't need to do anything special here\n        // The cooldown is already handled in performShot\n    }\n    \n    public destroy(): void {\n        this.stop();\n        // Queue is now integrated into launcher - no separate cleanup needed\n        this.scene.events.off('shooting-complete', this.onShootingComplete);\n    }\n}","import Phaser from 'phaser';\nimport { HD_SCALE } from '@/config/GameConfig';\n\nexport interface ScoreDisplayConfig {\n    player: {\n        position: 'bottom-left';\n        color: number;\n    };\n    opponent: {\n        position: 'top-right';\n        color: number;\n    };\n}\n\nexport class EnhancedScoreDisplay extends Phaser.GameObjects.Container {\n    private playerScore: number = 0;\n    private opponentScore: number = 0;\n    private playerScoreText: Phaser.GameObjects.Text;\n    private opponentScoreText: Phaser.GameObjects.Text;\n    private playerNameText: Phaser.GameObjects.Text;\n    private opponentNameText: Phaser.GameObjects.Text;\n    \n    // Score animation tracking\n    private playerDisplayScore: number = 0;\n    private opponentDisplayScore: number = 0;\n    private playerTargetScore: number = 0;\n    private opponentTargetScore: number = 0;\n    \n    // Winning indicators\n    private playerLeadIndicator: Phaser.GameObjects.Text;\n    private opponentLeadIndicator: Phaser.GameObjects.Text;\n    private currentLeader: 'player' | 'opponent' | 'tie' = 'tie';\n    \n    // Container backgrounds\n    private playerContainer: Phaser.GameObjects.Container;\n    private opponentContainer: Phaser.GameObjects.Container;\n    \n    constructor(scene: Phaser.Scene) {\n        super(scene, 0, 0);\n        \n        // Create player score display (bottom-left)\n        this.createPlayerDisplay();\n        \n        // Create opponent score display (top-right)\n        this.createOpponentDisplay();\n        \n        this.setDepth(1000);\n        scene.add.existing(this);\n    }\n    \n    private createPlayerDisplay(): void {\n        // Clean positioning with HD scaling\n        const padding = 15 * HD_SCALE;\n        const bottomOffset = 30 * HD_SCALE;\n        const containerWidth = 70 * HD_SCALE;  // Reduced from 90\n        const containerHeight = 40 * HD_SCALE;  // Reduced from 50\n        \n        const x = padding;\n        const y = this.scene.cameras.main.height - bottomOffset - containerHeight;\n        \n        this.playerContainer = this.scene.add.container(x, y);\n        \n        // Clean modern background\n        const bg = this.scene.add.graphics();\n        bg.fillStyle(0x1A1A2E, 0.9); // Dark blue-gray\n        bg.fillRoundedRect(0, 0, containerWidth, containerHeight, 8 * HD_SCALE);\n        bg.lineStyle(2 * HD_SCALE, 0x16C79A, 1); // Clean teal border\n        bg.strokeRoundedRect(0, 0, containerWidth, containerHeight, 8 * HD_SCALE);\n        \n        // Player label\n        this.playerNameText = this.scene.add.text(8 * HD_SCALE, 6 * HD_SCALE, 'PLAYER', {\n            fontSize: `${7 * HD_SCALE}px`,  // Reduced from 9\n            color: '#16C79A',\n            fontFamily: 'Arial',\n            fontStyle: 'bold'\n        });\n        \n        // Score text\n        this.playerScoreText = this.scene.add.text(8 * HD_SCALE, 18 * HD_SCALE, '0', {\n            fontSize: `${12 * HD_SCALE}px`,  // Reduced from 16\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        });\n        \n        // Lead indicator (simple crown emoji)\n        this.playerLeadIndicator = this.scene.add.text(containerWidth - 15 * HD_SCALE, containerHeight / 2, '👑', {\n            fontSize: `${9 * HD_SCALE}px`,  // Reduced from 12\n            fontFamily: 'Arial'\n        });\n        this.playerLeadIndicator.setOrigin(0.5);\n        this.playerLeadIndicator.setVisible(false);\n        \n        this.playerContainer.add([bg, this.playerNameText, this.playerScoreText, this.playerLeadIndicator]);\n        this.add(this.playerContainer);\n    }\n    \n    private createOpponentDisplay(): void {\n        // Clean positioning with HD scaling\n        const padding = 15 * HD_SCALE;\n        const topOffset = 35 * HD_SCALE;\n        const containerWidth = 70 * HD_SCALE;  // Reduced from 90\n        const containerHeight = 40 * HD_SCALE;  // Reduced from 50\n        \n        const x = this.scene.cameras.main.width - padding - containerWidth;\n        const y = topOffset;\n        \n        this.opponentContainer = this.scene.add.container(x, y);\n        \n        // Clean modern background\n        const bg = this.scene.add.graphics();\n        bg.fillStyle(0x1A1A2E, 0.9); // Dark blue-gray\n        bg.fillRoundedRect(0, 0, containerWidth, containerHeight, 8 * HD_SCALE);\n        bg.lineStyle(2 * HD_SCALE, 0xF45866, 1); // Clean red border\n        bg.strokeRoundedRect(0, 0, containerWidth, containerHeight, 8 * HD_SCALE);\n        \n        // Opponent label\n        this.opponentNameText = this.scene.add.text(containerWidth - 8 * HD_SCALE, 6 * HD_SCALE, 'OPPONENT', {\n            fontSize: `${7 * HD_SCALE}px`,  // Reduced from 9\n            color: '#F45866',\n            fontFamily: 'Arial',\n            fontStyle: 'bold'\n        });\n        this.opponentNameText.setOrigin(1, 0);\n        \n        // Score text\n        this.opponentScoreText = this.scene.add.text(containerWidth - 8 * HD_SCALE, 18 * HD_SCALE, '0', {\n            fontSize: `${12 * HD_SCALE}px`,  // Reduced from 16\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        });\n        this.opponentScoreText.setOrigin(1, 0);\n        \n        // Lead indicator (simple crown emoji)\n        this.opponentLeadIndicator = this.scene.add.text(15 * HD_SCALE, containerHeight / 2, '👑', {\n            fontSize: `${9 * HD_SCALE}px`,  // Reduced from 12\n            fontFamily: 'Arial'\n        });\n        this.opponentLeadIndicator.setOrigin(0.5);\n        this.opponentLeadIndicator.setVisible(false);\n        \n        this.opponentContainer.add([bg, this.opponentNameText, this.opponentScoreText, this.opponentLeadIndicator]);\n        this.add(this.opponentContainer);\n    }\n    \n    public updatePlayerScore(newScore: number, instant: boolean = false): void {\n        this.playerTargetScore = newScore;\n        \n        if (instant) {\n            this.playerDisplayScore = newScore;\n            this.playerScoreText.setText(this.formatScore(newScore));\n            return;\n        }\n        \n        // Animate score with rolling effect\n        this.scene.tweens.add({\n            targets: this,\n            playerDisplayScore: newScore,\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onUpdate: () => {\n                this.playerScoreText.setText(this.formatScore(Math.floor(this.playerDisplayScore)));\n            },\n            onComplete: () => {\n                // Pulse effect on completion\n                this.pulseScore(this.playerScoreText);\n                // Check who's winning\n                this.updateLeaderIndicator();\n            }\n        });\n    }\n    \n    public updateOpponentScore(newScore: number, instant: boolean = false): void {\n        this.opponentTargetScore = newScore;\n        \n        if (instant) {\n            this.opponentDisplayScore = newScore;\n            this.opponentScoreText.setText(this.formatScore(newScore));\n            return;\n        }\n        \n        // Animate score with rolling effect\n        this.scene.tweens.add({\n            targets: this,\n            opponentDisplayScore: newScore,\n            duration: 500,\n            ease: 'Cubic.easeOut',\n            onUpdate: () => {\n                this.opponentScoreText.setText(this.formatScore(Math.floor(this.opponentDisplayScore)));\n            },\n            onComplete: () => {\n                // Pulse effect on completion\n                this.pulseScore(this.opponentScoreText);\n                // Check who's winning\n                this.updateLeaderIndicator();\n            }\n        });\n    }\n    \n    private pulseScore(scoreText: Phaser.GameObjects.Text): void {\n        this.scene.tweens.add({\n            targets: scoreText,\n            scale: 1.1,\n            duration: 150,\n            yoyo: true,\n            ease: 'Power2'\n        });\n    }\n    \n    private formatScore(score: number): string {\n        // Add thousand separators\n        return score.toLocaleString();\n    }\n    \n    public getPlayerScore(): number {\n        return this.playerTargetScore;\n    }\n    \n    public getOpponentScore(): number {\n        return this.opponentTargetScore;\n    }\n    \n    public reset(): void {\n        this.playerScore = 0;\n        this.opponentScore = 0;\n        this.playerDisplayScore = 0;\n        this.opponentDisplayScore = 0;\n        this.playerTargetScore = 0;\n        this.opponentTargetScore = 0;\n        this.playerScoreText.setText('0');\n        this.opponentScoreText.setText('0');\n    }\n    \n    \n    private updateLeaderIndicator(): void {\n        const playerScore = this.playerTargetScore;\n        const opponentScore = this.opponentTargetScore;\n        \n        let newLeader: 'player' | 'opponent' | 'tie' = 'tie';\n        \n        if (playerScore > opponentScore) {\n            newLeader = 'player';\n        } else if (opponentScore > playerScore) {\n            newLeader = 'opponent';\n        }\n        \n        if (newLeader !== this.currentLeader) {\n            // Update leader indicators\n            this.playerLeadIndicator.setVisible(newLeader === 'player');\n            this.opponentLeadIndicator.setVisible(newLeader === 'opponent');\n            \n            // Simple glow effect for winner\n            if (newLeader === 'player') {\n                this.animateLeader(this.playerLeadIndicator);\n                this.playerContainer.setScale(1.02);\n                this.opponentContainer.setScale(1);\n            } else if (newLeader === 'opponent') {\n                this.animateLeader(this.opponentLeadIndicator);\n                this.opponentContainer.setScale(1.02);\n                this.playerContainer.setScale(1);\n            } else {\n                this.playerContainer.setScale(1);\n                this.opponentContainer.setScale(1);\n            }\n            \n            this.currentLeader = newLeader;\n        }\n    }\n    \n    private animateLeader(indicator: Phaser.GameObjects.Text): void {\n        // Simple bounce animation for crown\n        this.scene.tweens.add({\n            targets: indicator,\n            scale: { from: 0, to: 1 },\n            duration: 300,\n            ease: 'Back.easeOut'\n        });\n        \n        // Subtle rotation\n        this.scene.tweens.add({\n            targets: indicator,\n            angle: { from: -10, to: 10 },\n            duration: 2000,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.InOut'\n        });\n    }\n    \n    public destroy(): void {\n        // Kill any active tweens\n        if (this.scene && this.scene.tweens) {\n            this.scene.tweens.killTweensOf(this);\n            this.scene.tweens.killTweensOf(this.playerScoreText);\n            this.scene.tweens.killTweensOf(this.opponentScoreText);\n            this.scene.tweens.killTweensOf(this.playerLeadIndicator);\n            this.scene.tweens.killTweensOf(this.opponentLeadIndicator);\n            this.scene.tweens.killTweensOf(this.playerContainer);\n            this.scene.tweens.killTweensOf(this.opponentContainer);\n        }\n        super.destroy();\n    }\n}","import { Scene } from 'phaser';\n\nexport enum ComboTier {\n    NORMAL = '',         // 3 matches - no text\n    COMBO_2 = 'COMBO x2', // 4 matches\n    COMBO_3 = 'COMBO x3', // 5 matches\n    COMBO_4 = 'COMBO x4', // 6 matches\n    COMBO_5 = 'COMBO x5'  // 7+ matches\n}\n\nexport interface ComboConfig {\n    tier: ComboTier;\n    multiplier: number;\n    color: number;\n    minBubbles: number;\n}\n\nexport class ComboManager {\n    private scene: Scene;\n    private currentCombo: number = 0;\n    private comboMultiplier: number = 1.0;\n    private lastMatchTime: number = 0;\n    private comboTimeout: number = 2000; // 2 seconds\n    private comboContainers: Phaser.GameObjects.Container[] = [];\n    \n    // Scoring configuration - linear and balanced\n    private readonly BASE_POINTS: { [key: number]: number } = {\n        3: 10,    // Standard match\n        4: 20,    // Good match  \n        5: 30,    // Great match\n        6: 40,    // Excellent match\n        7: 50     // Perfect match\n    };\n    \n    private readonly COMBO_CONFIGS: ComboConfig[] = [\n        { tier: ComboTier.NORMAL, multiplier: 1.0, color: 0xFFD700, minBubbles: 3 },\n        { tier: ComboTier.COMBO_2, multiplier: 1.2, color: 0x00FF00, minBubbles: 4 },\n        { tier: ComboTier.COMBO_3, multiplier: 1.5, color: 0x00BFFF, minBubbles: 5 },\n        { tier: ComboTier.COMBO_4, multiplier: 1.8, color: 0xFF4500, minBubbles: 6 },\n        { tier: ComboTier.COMBO_5, multiplier: 2.0, color: 0xFF1493, minBubbles: 7 }\n    ];\n    \n    private readonly CHAIN_BONUS: { [key: number]: number } = {\n        2: 1.1,   // +10%\n        3: 1.2,   // +20%\n        4: 1.3    // +30%\n    };\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n    }\n    \n    private createComboDisplay(x: number, y: number): Phaser.GameObjects.Container {\n        const comboContainer = this.scene.add.container(x, y);\n        comboContainer.setDepth(1200); // Higher depth for combo visibility\n        \n        // Create comic-style combo text for mobile\n        const comboText = this.scene.add.text(0, 0, '', {\n            fontSize: '24px',\n            color: '#FFFFFF',\n            fontFamily: 'Impact, Arial Black', // Comic style font\n            fontStyle: 'bold',\n            stroke: '#000000',\n            strokeThickness: 4\n        });\n        comboText.setOrigin(0.5);\n        comboText.setShadow(3, 3, '#000000', 5, true, true);\n        \n        comboContainer.add(comboText);\n        this.comboContainers.push(comboContainer);\n        \n        return comboContainer;\n    }\n    \n    public calculateScore(matchSize: number, x?: number, y?: number, bubbleColor?: number): number {\n        // Get base points\n        const basePoints = this.BASE_POINTS[Math.min(matchSize, 7)] || this.BASE_POINTS[7];\n        \n        // Check if this is a chain combo\n        const now = Date.now();\n        const isChain = (now - this.lastMatchTime) < this.comboTimeout;\n        \n        if (isChain) {\n            this.currentCombo++;\n        } else {\n            this.currentCombo = 1;\n        }\n        \n        this.lastMatchTime = now;\n        \n        // Get combo configuration\n        const comboConfig = this.getComboConfig(matchSize);\n        this.comboMultiplier = comboConfig.multiplier;\n        \n        // Get chain bonus\n        const chainBonus = this.CHAIN_BONUS[Math.min(this.currentCombo, 4)] || this.CHAIN_BONUS[4];\n        \n        // Calculate final score\n        const finalScore = Math.floor(basePoints * this.comboMultiplier * chainBonus);\n        \n        // DISABLED: Visual effects now handled by UnifiedFeedbackSystem\n        // if (x !== undefined && y !== undefined) {\n        //     this.showCombo(comboConfig, finalScore, x, y, matchSize, bubbleColor);\n        // }\n        \n        return finalScore;\n    }\n    \n    public getComboConfig(matchSize: number): ComboConfig {\n        // Find the appropriate combo tier based on match size\n        for (let i = this.COMBO_CONFIGS.length - 1; i >= 0; i--) {\n            if (matchSize >= this.COMBO_CONFIGS[i].minBubbles) {\n                return this.COMBO_CONFIGS[i];\n            }\n        }\n        return this.COMBO_CONFIGS[0];\n    }\n    \n    private showCombo(config: ComboConfig, points: number, x: number, y: number, matchSize: number, bubbleColor?: number): void {\n        // Create combo display at the match location\n        const comboContainer = this.createComboDisplay(x, y);\n        \n        // Get the text object before adding background\n        const comboText = comboContainer.list[0] as Phaser.GameObjects.Text;\n        \n        // Add background effect based on combo size\n        if (matchSize >= 4) {\n            this.addComboBackground(comboContainer, matchSize, bubbleColor || config.color);\n        }\n        \n        // Use bubble color if provided, otherwise use config color\n        const displayColor = bubbleColor || config.color;\n        \n        // For normal matches (3), just show points\n        // For combos (4+), show combo text and points\n        if (matchSize === 3) {\n            // Just show points for basic matches\n            comboText.setText(`+${points}`);\n            comboText.setTint(displayColor);\n            comboText.setFontSize(20);\n        } else {\n            // Show combo text with comic styling and bubble color\n            comboText.setText(config.tier);\n            comboText.setTint(displayColor);\n            comboText.setFontSize(28);\n            comboText.setStyle({\n                fontSize: '28px',\n                fontFamily: 'Impact, Arial Black',\n                fontStyle: 'bold',\n                stroke: '#000000',\n                strokeThickness: 5\n            });\n            \n            // Add points below combo text with comic style\n            const pointsText = this.scene.add.text(0, 26, `+${points}`, {\n                fontSize: '20px',\n                color: '#FFD700',\n                fontFamily: 'Impact, Arial Black',\n                fontStyle: 'bold',\n                stroke: '#000000',\n                strokeThickness: 3\n            });\n            pointsText.setOrigin(0.5);\n            pointsText.setShadow(2, 2, '#FF6600', 3, true, true);\n            comboContainer.add(pointsText);\n        }\n        \n        // Show and animate (smaller scale for mobile)\n        comboContainer.setVisible(true);\n        comboContainer.setScale(0);\n        comboContainer.setAlpha(1);\n        \n        // Elegant entrance animation\n        this.scene.tweens.add({\n            targets: comboContainer,\n            scale: { from: 0, to: 1.1 },\n            duration: 200,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                // Subtle settle\n                this.scene.tweens.add({\n                    targets: comboContainer,\n                    scale: 1,\n                    duration: 100,\n                    ease: 'Sine.easeInOut'\n                });\n            }\n        });\n        \n        // Float up animation - more pronounced to separate from drop bonus\n        this.scene.tweens.add({\n            targets: comboContainer,\n            y: comboContainer.y - 60, // Float higher from current position\n            duration: 1000,\n            ease: 'Cubic.easeOut'\n        });\n        \n        // Fade out after delay\n        this.scene.time.delayedCall(800, () => {\n            this.scene.tweens.add({\n                targets: comboContainer,\n                alpha: 0,\n                y: comboContainer.y - 20, // Continue floating up from current position\n                scale: 0.9,\n                duration: 400,\n                ease: 'Cubic.easeIn',\n                onComplete: () => {\n                    // Clean up\n                    const index = this.comboContainers.indexOf(comboContainer);\n                    if (index > -1) {\n                        this.comboContainers.splice(index, 1);\n                    }\n                    comboContainer.destroy(true);\n                }\n            });\n        });\n        \n        // Delay particle effects to appear after combo text\n        this.scene.time.delayedCall(300, () => {\n            // Create particles with bubble color\n            this.createParticleEffect(x, y, config, bubbleColor);\n            \n            // Add impact flash for big combos\n            if (matchSize >= 6) {\n                this.createImpactFlash(x, y, config);\n            }\n        });\n        \n        // Add effects based on combo tier\n        if (matchSize >= 5) {\n            this.addComboStars(config, comboContainer, matchSize, bubbleColor);\n        }\n        \n        // Screen shake intensity based on combo\n        if (matchSize >= 7) {\n            this.scene.cameras.main.shake(200, 0.008);\n            this.scene.cameras.main.flash(100, 255, 255, 255, false);\n        } else if (matchSize >= 6) {\n            this.scene.cameras.main.shake(150, 0.005);\n            this.scene.cameras.main.flash(50, 255, 200, 100, false);\n        } else if (matchSize >= 5) {\n            this.scene.cameras.main.shake(100, 0.003);\n        }\n    }\n    \n    private addComboStars(config: ComboConfig, container: Phaser.GameObjects.Container, matchSize: number, bubbleColor?: number): void {\n        const starCount = Math.min(matchSize - 4, 3); // 1-3 stars based on combo size\n        const starY = -20; // Closer to text\n        \n        for (let i = 0; i < starCount; i++) {\n            const starX = (i - (starCount - 1) / 2) * 20; // Smaller spacing\n            const star = this.scene.add.star(starX, starY, 5, 4, 8, bubbleColor || config.color); // Smaller stars\n            star.setAlpha(0.8);\n            \n            container.add(star);\n            \n            // Rotate stars\n            this.scene.tweens.add({\n                targets: star,\n                angle: 360,\n                duration: 1000,\n                ease: 'Linear'\n            });\n            \n            // Pulse stars\n            this.scene.tweens.add({\n                targets: star,\n                scale: { from: 0.5, to: 0.8 },\n                alpha: { from: 0.8, to: 1 },\n                duration: 300,\n                yoyo: true,\n                repeat: 1,\n                ease: 'Sine.easeInOut'\n            });\n        }\n    }\n    \n    public createParticleEffect(x: number, y: number, config: ComboConfig, bubbleColor?: number): void {\n        // Progressive particle count based on combo size\n        let particleCount;\n        if (config.minBubbles === 3) {\n            particleCount = 8; // Very subtle for 3\n        } else if (config.minBubbles === 4) {\n            particleCount = 16; // Small burst for 4\n        } else if (config.minBubbles === 5) {\n            particleCount = 30; // Medium burst for 5\n        } else if (config.minBubbles === 6) {\n            particleCount = 50; // Large burst for 6\n        } else {\n            particleCount = 80; // Massive for 7+\n        }\n        \n        // Create different effects based on combo tier\n        if (config.minBubbles >= 7) {\n            // MEGA COMBO - Fire explosion!\n            this.createFireExplosion(x, y, config, bubbleColor);\n        } else if (config.minBubbles >= 6) {\n            // Big combos get special effects\n            this.createExplosionEffect(x, y, config, bubbleColor);\n        } else if (config.minBubbles >= 5) {\n            // Medium combos get burst\n            this.createColorBurst(x, y, config, bubbleColor);\n        }\n        \n        // Particle size and speed based on combo\n        const particleSize = config.minBubbles === 3 ? [1, 2] : \n                           config.minBubbles === 4 ? [2, 3] :\n                           config.minBubbles === 5 ? [2, 4] :\n                           [3, 6];\n        \n        const speedRange = config.minBubbles === 3 ? [30, 60] :\n                          config.minBubbles === 4 ? [40, 100] :\n                          config.minBubbles === 5 ? [60, 150] :\n                          [80, 250];\n        \n        // Standard particle burst with bubble colors\n        for (let i = 0; i < particleCount; i++) {\n            // Always use bubble color as primary\n            const baseColor = bubbleColor || config.color;\n            // Mix with lighter/darker shades for variety\n            const shadeVariation = Phaser.Math.Between(-0.2, 0.2);\n            const particleColor = Phaser.Display.Color.Interpolate.ColorWithColor(\n                Phaser.Display.Color.ValueToColor(baseColor),\n                Phaser.Display.Color.ValueToColor(0xFFFFFF),\n                100,\n                Math.abs(shadeVariation) * 100\n            );\n            const finalColor = Phaser.Display.Color.GetColor(particleColor.r, particleColor.g, particleColor.b);\n            \n            const particle = this.scene.add.circle(\n                x, y, \n                Phaser.Math.Between(particleSize[0], particleSize[1]),\n                finalColor,\n                config.minBubbles === 3 ? 0.6 : 1\n            );\n            particle.setDepth(1150); // Higher depth for particles\n            \n            const angle = (Math.PI * 2 * i) / particleCount;\n            const speed = Phaser.Math.Between(speedRange[0], speedRange[1]);\n            \n            this.scene.tweens.add({\n                targets: particle,\n                x: x + Math.cos(angle) * speed,\n                y: y + Math.sin(angle) * speed,\n                alpha: 0,\n                scale: { from: 1, to: 0 },\n                duration: config.minBubbles === 3 ? 400 : Phaser.Math.Between(600, 1000),\n                ease: 'Power2.easeOut',\n                delay: i * (config.minBubbles === 3 ? 2 : 5),\n                onComplete: () => {\n                    particle.destroy();\n                }\n            });\n        }\n        \n        // Add glow effect only for combos 5+\n        if (config.minBubbles >= 5) {\n            this.createGlowEffect(x, y, config);\n        }\n    }\n    \n    private createExplosionEffect(x: number, y: number, config: ComboConfig, bubbleColor?: number): void {\n        const explosionColor = bubbleColor || config.color;\n        \n        // Create expanding ring with bubble color\n        const ring = this.scene.add.graphics();\n        ring.lineStyle(3, explosionColor, 1);\n        ring.strokeCircle(0, 0, 20);\n        ring.setPosition(x, y);\n        ring.setDepth(1049);\n        ring.setScale(0);\n        \n        // Animate ring expansion\n        this.scene.tweens.add({\n            targets: ring,\n            scale: 3,\n            alpha: 0,\n            duration: 600,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                ring.destroy();\n            }\n        });\n        \n        // Create star burst for perfect combos\n        if (config.minBubbles >= 7) {\n            for (let i = 0; i < 8; i++) {\n                const angle = (Math.PI * 2 * i) / 8;\n                const star = this.scene.add.star(\n                    x + Math.cos(angle) * 20,\n                    y + Math.sin(angle) * 20,\n                    5, 3, 6,\n                    bubbleColor || config.color\n                );\n                star.setDepth(1051);\n                star.setScale(0);\n                \n                this.scene.tweens.add({\n                    targets: star,\n                    x: x + Math.cos(angle) * 100,\n                    y: y + Math.sin(angle) * 100,\n                    scale: { from: 0, to: 1 },\n                    alpha: { from: 1, to: 0 },\n                    angle: 360,\n                    duration: 800,\n                    delay: i * 50,\n                    ease: 'Cubic.easeOut',\n                    onComplete: () => {\n                        star.destroy();\n                    }\n                });\n            }\n        }\n    }\n    \n    private createGlowEffect(x: number, y: number, config: ComboConfig): void {\n        // Create multiple glow layers for depth\n        for (let i = 0; i < 3; i++) {\n            const glow = this.scene.add.circle(x, y, 20 + i * 10, config.color, 0.4 - i * 0.1);\n            glow.setDepth(1048 - i);\n            glow.setScale(0);\n            \n            // Pulse and fade with delay\n            this.scene.tweens.add({\n                targets: glow,\n                scale: 2 + i * 0.5,\n                alpha: 0,\n                duration: 600 + i * 100,\n                delay: i * 50,\n                ease: 'Sine.easeOut',\n                onComplete: () => {\n                    glow.destroy();\n                }\n            });\n        }\n    }\n    \n    private createColorBurst(x: number, y: number, config: ComboConfig): void {\n        // Create rainbow burst for medium combos\n        const colors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x9400D3];\n        const burstCount = 12;\n        \n        for (let i = 0; i < burstCount; i++) {\n            const angle = (Math.PI * 2 * i) / burstCount;\n            const color = colors[i % colors.length];\n            \n            // Create streak\n            const streak = this.scene.add.rectangle(\n                x, y, 40, 4, color\n            );\n            streak.setOrigin(0, 0.5);\n            streak.setRotation(angle);\n            streak.setDepth(1049);\n            streak.setScale(0, 1);\n            \n            // Animate streak\n            this.scene.tweens.add({\n                targets: streak,\n                scaleX: 2,\n                alpha: { from: 1, to: 0 },\n                duration: 500,\n                ease: 'Power2.easeOut',\n                onComplete: () => {\n                    streak.destroy();\n                }\n            });\n        }\n    }\n    \n    private addComboBackground(container: Phaser.GameObjects.Container, matchSize: number, color: number): void {\n        if (matchSize >= 7) {\n            // Fire/explosion background for mega combos\n            const fireGradient = this.scene.add.graphics();\n            fireGradient.fillStyle(0xFF6B00, 0.3);\n            fireGradient.fillCircle(0, 0, 40);\n            fireGradient.fillStyle(0xFF0000, 0.2);\n            fireGradient.fillCircle(0, 0, 50);\n            fireGradient.setDepth(-1);\n            \n            // Pulsing animation\n            this.scene.tweens.add({\n                targets: fireGradient,\n                scale: { from: 0.8, to: 1.2 },\n                alpha: { from: 0.3, to: 0.6 },\n                duration: 300,\n                yoyo: true,\n                repeat: 2,\n                ease: 'Sine.easeInOut'\n            });\n            \n            container.addAt(fireGradient, 0);\n            \n            // Add fire particles around text\n            for (let i = 0; i < 6; i++) {\n                const angle = (Math.PI * 2 * i) / 6;\n                const dist = 25;\n                const fireParticle = this.scene.add.circle(\n                    Math.cos(angle) * dist,\n                    Math.sin(angle) * dist,\n                    3,\n                    0xFF4500,\n                    0.8\n                );\n                container.add(fireParticle);\n                \n                this.scene.tweens.add({\n                    targets: fireParticle,\n                    scale: { from: 0.5, to: 1.5 },\n                    alpha: { from: 0.8, to: 0 },\n                    duration: 600,\n                    delay: i * 50,\n                    ease: 'Power2.easeOut'\n                });\n            }\n        } else if (matchSize >= 6) {\n            // Electric burst background\n            const burst = this.scene.add.graphics();\n            burst.fillStyle(color, 0.2);\n            burst.fillCircle(0, 0, 35);\n            burst.lineStyle(2, color, 0.5);\n            burst.strokeCircle(0, 0, 35);\n            burst.setDepth(-1);\n            \n            this.scene.tweens.add({\n                targets: burst,\n                scale: { from: 0, to: 1.1 },\n                alpha: { from: 0.5, to: 0.2 },\n                duration: 400,\n                ease: 'Back.easeOut'\n            });\n            \n            container.addAt(burst, 0);\n        } else if (matchSize >= 5) {\n            // Star burst background\n            const starBurst = this.scene.add.star(0, 0, 8, 15, 30, color);\n            starBurst.setAlpha(0.25);\n            starBurst.setDepth(-1);\n            \n            this.scene.tweens.add({\n                targets: starBurst,\n                angle: 360,\n                scale: { from: 0, to: 1.2 },\n                alpha: { from: 0.4, to: 0.1 },\n                duration: 800,\n                ease: 'Power2.easeOut'\n            });\n            \n            container.addAt(starBurst, 0);\n        } else {\n            // Simple glow for 4-match\n            const glow = this.scene.add.circle(0, 0, 25, color, 0.15);\n            glow.setDepth(-1);\n            \n            this.scene.tweens.add({\n                targets: glow,\n                scale: { from: 0, to: 1 },\n                alpha: { from: 0.3, to: 0.1 },\n                duration: 500,\n                ease: 'Sine.easeOut'\n            });\n            \n            container.addAt(glow, 0);\n        }\n    }\n    \n    \n    private createFireExplosion(x: number, y: number, config: ComboConfig, bubbleColor?: number): void {\n        // Create epic fire effect for mega combos\n        const baseColor = bubbleColor || config.color;\n        // Create fire-tinted variations of the bubble color\n        const fireColors = [\n            baseColor,\n            Phaser.Display.Color.Interpolate.ColorWithColor(\n                Phaser.Display.Color.ValueToColor(baseColor),\n                Phaser.Display.Color.ValueToColor(0xFF0000),\n                100, 30\n            ),\n            Phaser.Display.Color.Interpolate.ColorWithColor(\n                Phaser.Display.Color.ValueToColor(baseColor),\n                Phaser.Display.Color.ValueToColor(0xFFD700),\n                100, 50\n            )\n        ].map(c => c.color !== undefined ? c.color : Phaser.Display.Color.GetColor(c.r, c.g, c.b));\n        const particleCount = 50;\n        \n        // Create fire shockwave with bubble color\n        const shockwave = this.scene.add.graphics();\n        shockwave.lineStyle(5, baseColor, 1);\n        shockwave.strokeCircle(0, 0, 30);\n        shockwave.setPosition(x, y);\n        shockwave.setDepth(1048);\n        shockwave.setScale(0);\n        \n        // Animate shockwave\n        this.scene.tweens.add({\n            targets: shockwave,\n            scale: 4,\n            alpha: 0,\n            duration: 400,\n            ease: 'Power2.easeOut',\n            onComplete: () => {\n                shockwave.destroy();\n            }\n        });\n        \n        // Create fire particles\n        for (let i = 0; i < particleCount; i++) {\n            const fireColor = fireColors[Math.floor(Math.random() * fireColors.length)];\n            const size = Phaser.Math.Between(3, 8);\n            \n            const flame = this.scene.add.circle(\n                x + Phaser.Math.Between(-20, 20),\n                y + Phaser.Math.Between(-20, 20),\n                size,\n                fireColor\n            );\n            flame.setDepth(1051);\n            \n            const angle = Math.random() * Math.PI * 2;\n            const speed = Phaser.Math.Between(100, 300);\n            const targetX = x + Math.cos(angle) * speed;\n            const targetY = y + Math.sin(angle) * speed - Phaser.Math.Between(50, 150); // Fire rises\n            \n            // Animate flame\n            this.scene.tweens.add({\n                targets: flame,\n                x: targetX,\n                y: targetY,\n                alpha: { from: 1, to: 0 },\n                scale: { from: 1.5, to: 0 },\n                duration: Phaser.Math.Between(600, 1000),\n                delay: i * 10,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    flame.destroy();\n                }\n            });\n            \n            // Add glow to each flame\n            const glow = this.scene.add.circle(flame.x, flame.y, size * 2, fireColor, 0.3);\n            glow.setDepth(1050);\n            \n            this.scene.tweens.add({\n                targets: glow,\n                x: targetX,\n                y: targetY,\n                alpha: 0,\n                scale: 2,\n                duration: Phaser.Math.Between(600, 1000),\n                delay: i * 10,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    glow.destroy();\n                }\n            });\n        }\n        \n        // Add fire text effect\n        if (config.minBubbles >= 7) {\n            const fireText = this.scene.add.text(x, y - 50, '🔥', {\n                fontSize: '48px'\n            });\n            fireText.setOrigin(0.5);\n            fireText.setDepth(1052);\n            fireText.setScale(0);\n            \n            this.scene.tweens.add({\n                targets: fireText,\n                scale: { from: 0, to: 2 },\n                alpha: { from: 1, to: 0 },\n                y: y - 100,\n                duration: 800,\n                ease: 'Back.easeOut',\n                onComplete: () => {\n                    fireText.destroy();\n                }\n            });\n        }\n    }\n    \n    private createImpactFlash(x: number, y: number, config: ComboConfig): void {\n        // Create a bright white flash at impact point\n        const flash = this.scene.add.graphics();\n        flash.fillStyle(0xFFFFFF, 0.8);\n        flash.fillCircle(0, 0, 50);\n        flash.setPosition(x, y);\n        flash.setDepth(1047);\n        flash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        // Quick flash animation\n        this.scene.tweens.add({\n            targets: flash,\n            alpha: 0,\n            scale: 3,\n            duration: 200,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                flash.destroy();\n            }\n        });\n        \n        // Create secondary colored flash\n        const colorFlash = this.scene.add.graphics();\n        colorFlash.fillStyle(config.color, 0.5);\n        colorFlash.fillCircle(0, 0, 80);\n        colorFlash.setPosition(x, y);\n        colorFlash.setDepth(1046);\n        colorFlash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        this.scene.tweens.add({\n            targets: colorFlash,\n            alpha: 0,\n            scale: 2,\n            duration: 400,\n            ease: 'Sine.easeOut',\n            onComplete: () => {\n                colorFlash.destroy();\n            }\n        });\n    }\n    \n    public reset(): void {\n        this.currentCombo = 0;\n        this.comboMultiplier = 1.0;\n        this.lastMatchTime = 0;\n        // Clean up all combo containers\n        this.comboContainers.forEach(container => container.destroy(true));\n        this.comboContainers = [];\n    }\n    \n    public getCurrentCombo(): number {\n        return this.currentCombo;\n    }\n    \n    public getMultiplier(): number {\n        return this.comboMultiplier;\n    }\n}","import Phaser from 'phaser';\n\nexport class VictoryScreen extends Phaser.GameObjects.Container {\n    private particles?: Phaser.GameObjects.Particles.ParticleEmitter;\n    \n    constructor(\n        scene: Phaser.Scene, \n        finalScore: number, \n        onReplay: () => void, \n        onMenu: () => void\n    ) {\n        super(scene, scene.cameras.main.centerX, scene.cameras.main.centerY);\n        \n        // Semi-transparent backdrop\n        const backdrop = scene.add.rectangle(\n            0, 0,\n            scene.cameras.main.width * 2,\n            scene.cameras.main.height * 2,\n            0x000000, 0.75\n        );\n        backdrop.setInteractive(); // Block clicks\n        \n        // Victory panel background\n        const panelBg = scene.add.rectangle(0, 0, 400, 500, 0x1a1a2e, 0.95);\n        panelBg.setStrokeStyle(4, 0xFFD700);\n        \n        // Victory banner\n        const banner = scene.add.rectangle(0, -150, 350, 100, 0xFFD700);\n        banner.setStrokeStyle(3, 0xFFA500);\n        \n        // Victory text with glow effect\n        const victoryGlow = scene.add.text(0, -150, 'VICTORY!', {\n            fontSize: '52px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        victoryGlow.setShadow(0, 0, '#FFD700', 10);\n        \n        const victoryText = scene.add.text(0, -150, 'VICTORY!', {\n            fontSize: '48px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold',\n            stroke: '#FF6600',\n            strokeThickness: 6\n        }).setOrigin(0.5);\n        \n        // Stars decoration\n        const star1 = this.createStar(scene, -120, -150, 20, 0xFFD700);\n        const star2 = this.createStar(scene, 120, -150, 20, 0xFFD700);\n        const star3 = this.createStar(scene, 0, -200, 15, 0xFFA500);\n        \n        // Score section\n        const scoreBg = scene.add.rectangle(0, -20, 300, 80, 0x2c3e50, 0.8);\n        scoreBg.setStrokeStyle(2, 0xFFD700);\n        \n        const scoreLabel = scene.add.text(0, -40, 'FINAL SCORE', {\n            fontSize: '20px',\n            color: '#FFD700',\n            fontFamily: 'Arial',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        const scoreValue = scene.add.text(0, -5, '0', {\n            fontSize: '42px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        // Stats\n        const statsText = scene.add.text(0, 50, 'Great job!', {\n            fontSize: '18px',\n            color: '#FFD700',\n            fontFamily: 'Arial'\n        }).setOrigin(0.5);\n        \n        // Buttons\n        const playAgainBtn = this.createButton(scene, 0, 130, 'PLAY AGAIN', 0x00AA00, 0x00FF00, onReplay);\n        const menuBtn = this.createButton(scene, 0, 200, 'MAIN MENU', 0x0066CC, 0x0099FF, onMenu);\n        \n        // Add all elements\n        this.add([\n            backdrop, panelBg, banner, \n            star1, star2, star3,\n            victoryGlow, victoryText,\n            scoreBg, scoreLabel, scoreValue,\n            statsText, playAgainBtn, menuBtn\n        ]);\n        \n        // Initial state for animations\n        this.setAlpha(0);\n        panelBg.setScale(0);\n        banner.setScale(0);\n        victoryText.setScale(0);\n        victoryGlow.setScale(0);\n        \n        // Entrance animations\n        scene.tweens.add({\n            targets: this,\n            alpha: 1,\n            duration: 300,\n            ease: 'Power2'\n        });\n        \n        scene.tweens.add({\n            targets: panelBg,\n            scaleX: 1,\n            scaleY: 1,\n            duration: 400,\n            ease: 'Back.easeOut',\n            delay: 100\n        });\n        \n        scene.tweens.add({\n            targets: [banner, victoryText, victoryGlow],\n            scaleX: 1,\n            scaleY: 1,\n            duration: 500,\n            ease: 'Back.easeOut',\n            delay: 300\n        });\n        \n        // Star rotation\n        scene.tweens.add({\n            targets: [star1, star2, star3],\n            angle: 360,\n            duration: 3000,\n            repeat: -1,\n            ease: 'Linear'\n        });\n        \n        // Score count up\n        const scoreCounter = { value: 0 };\n        scene.tweens.add({\n            targets: scoreCounter,\n            value: finalScore,\n            duration: 1500,\n            ease: 'Cubic.easeOut',\n            delay: 800,\n            onUpdate: () => {\n                scoreValue.setText(Math.floor(scoreCounter.value).toString());\n            },\n            onComplete: () => {\n                // Pulse the score\n                scene.tweens.add({\n                    targets: scoreValue,\n                    scale: 1.1,\n                    duration: 300,\n                    yoyo: true,\n                    ease: 'Power2'\n                });\n            }\n        });\n        \n        // Create particle effects\n        this.createConfetti(scene);\n        \n        // Camera shake for impact\n        scene.cameras.main.shake(300, 0.005);\n        \n        this.setDepth(2000);\n        scene.add.existing(this);\n    }\n    \n    private createStar(scene: Phaser.Scene, x: number, y: number, size: number, color: number): Phaser.GameObjects.Star {\n        const star = scene.add.star(x, y, 5, size * 0.5, size, color);\n        star.setStrokeStyle(2, 0xFFFFFF);\n        return star;\n    }\n    \n    private createButton(\n        scene: Phaser.Scene, \n        x: number, \n        y: number, \n        text: string, \n        bgColor: number,\n        hoverColor: number,\n        callback: () => void\n    ): Phaser.GameObjects.Container {\n        const button = scene.add.container(x, y);\n        \n        const bg = scene.add.rectangle(0, 0, 220, 55, bgColor);\n        bg.setInteractive({ useHandCursor: true });\n        bg.setStrokeStyle(3, 0xFFFFFF);\n        \n        const shadow = scene.add.rectangle(0, 3, 220, 55, 0x000000, 0.3);\n        shadow.setDepth(-1);\n        \n        const label = scene.add.text(0, 0, text, {\n            fontSize: '22px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        button.add([shadow, bg, label]);\n        \n        // Button interactions\n        bg.on('pointerover', () => {\n            bg.setFillStyle(hoverColor);\n            scene.tweens.add({\n                targets: [bg, label],\n                scale: 1.05,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n        \n        bg.on('pointerout', () => {\n            bg.setFillStyle(bgColor);\n            scene.tweens.add({\n                targets: [bg, label],\n                scale: 1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n        \n        bg.on('pointerdown', () => {\n            console.log(`💆 VictoryScreen button clicked: ${text}`);\n            \n            // Emit UI click event for sound system\n            scene.events.emit('ui-click');\n            \n            // Execute callback IMMEDIATELY without waiting for tween\n            console.log(`🚀 Executing callback for: ${text}`);\n            \n            try {\n                if (callback && typeof callback === 'function') {\n                    console.log(`💫 Callback type check passed, executing...`);\n                    callback();\n                    console.log(`✅ Callback executed successfully!`);\n                } else {\n                    console.error('❌ Callback is not a function:', callback, 'Type:', typeof callback);\n                }\n            } catch (error) {\n                console.error('❌ Error executing callback:', error);\n            }\n            \n            // Visual feedback AFTER callback\n            scene.tweens.add({\n                targets: button,\n                scale: 0.9,\n                duration: 100,\n                yoyo: true,\n                ease: 'Power2'\n            });\n        });\n        \n        // Initial animation\n        button.setScale(0);\n        scene.tweens.add({\n            targets: button,\n            scale: 1,\n            duration: 400,\n            ease: 'Back.easeOut',\n            delay: 1000 + (y > 150 ? 200 : 0)\n        });\n        \n        return button;\n    }\n    \n    private createConfetti(scene: Phaser.Scene): void {\n        const colors = [0xFFD700, 0xFFA500, 0xFF69B4, 0x00CED1, 0x98FB98, 0xFF6347];\n        \n        // Create confetti manually using shapes\n        const confettiTimer = scene.time.addEvent({\n            delay: 100,\n            repeat: 30,\n            callback: () => {\n                for (let i = 0; i < 6; i++) {\n                    const x = Phaser.Math.Between(-100, 100);\n                    const y = -250;\n                    \n                    // Random shape (circle or rectangle)\n                    const shape = Math.random() > 0.5 ?\n                        scene.add.circle(x, y, Phaser.Math.Between(3, 6), Phaser.Utils.Array.GetRandom(colors), 0.9) :\n                        scene.add.rectangle(x, y, Phaser.Math.Between(8, 12), Phaser.Math.Between(4, 6), Phaser.Utils.Array.GetRandom(colors), 0.9);\n                    \n                    shape.setRotation(Math.random() * Math.PI * 2);\n                    this.add(shape);\n                    \n                    const angle = Phaser.Math.Between(-110, -70) * Math.PI / 180;\n                    const speed = Phaser.Math.Between(100, 350);\n                    const vx = Math.cos(angle) * speed;\n                    const vy = Math.sin(angle) * speed;\n                    \n                    scene.tweens.add({\n                        targets: shape,\n                        x: shape.x + vx,\n                        y: shape.y + vy + 600, // Gravity effect\n                        rotation: shape.rotation + Phaser.Math.Between(-6, 6),\n                        alpha: 0,\n                        scale: 0,\n                        duration: 3000,\n                        ease: 'Power2',\n                        onComplete: () => shape.destroy()\n                    });\n                }\n            }\n        });\n        \n        // Stop confetti after 3 seconds\n        scene.time.delayedCall(3000, () => {\n            confettiTimer.destroy();\n        });\n    }\n    \n    public destroy(): void {\n        this.scene.tweens.killTweensOf(this);\n        super.destroy();\n    }\n}","import Phaser from 'phaser';\n\nexport class DefeatScreen extends Phaser.GameObjects.Container {\n    constructor(\n        scene: Phaser.Scene, \n        finalScore: number, \n        onRetry: () => void, \n        onMenu: () => void\n    ) {\n        super(scene, scene.cameras.main.centerX, scene.cameras.main.centerY);\n        \n        // Semi-transparent backdrop\n        const backdrop = scene.add.rectangle(\n            0, 0,\n            scene.cameras.main.width * 2,\n            scene.cameras.main.height * 2,\n            0x000000, 0.85\n        );\n        backdrop.setInteractive(); // Block clicks\n        \n        // Defeat panel background with softer colors\n        const panelBg = scene.add.rectangle(0, 0, 400, 450, 0x2c2c3e, 0.95);\n        panelBg.setStrokeStyle(3, 0x7B68EE);\n        \n        // Defeat banner\n        const banner = scene.add.rectangle(0, -140, 350, 90, 0x4B0082, 0.9);\n        banner.setStrokeStyle(2, 0x7B68EE);\n        \n        // Defeat text\n        const defeatText = scene.add.text(0, -140, 'GAME OVER', {\n            fontSize: '42px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        defeatText.setShadow(2, 2, '#000000', 5);\n        \n        // Encouraging message\n        const encourageText = scene.add.text(0, -80, \"Don't give up!\", {\n            fontSize: '20px',\n            color: '#FFD700',\n            fontFamily: 'Arial',\n            fontStyle: 'italic'\n        }).setOrigin(0.5);\n        \n        // Score section\n        const scoreBg = scene.add.rectangle(0, -10, 280, 70, 0x1a1a2e, 0.8);\n        scoreBg.setStrokeStyle(2, 0x7B68EE);\n        \n        const scoreLabel = scene.add.text(0, -28, 'YOUR SCORE', {\n            fontSize: '18px',\n            color: '#B8B8B8',\n            fontFamily: 'Arial'\n        }).setOrigin(0.5);\n        \n        const scoreValue = scene.add.text(0, 2, finalScore.toString(), {\n            fontSize: '36px',\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        // Motivational text\n        let motivationalMsg = \"You can do better!\";\n        if (finalScore > 1000) motivationalMsg = \"Great effort!\";\n        if (finalScore > 5000) motivationalMsg = \"So close! Try again!\";\n        if (finalScore > 10000) motivationalMsg = \"Amazing score! Almost there!\";\n        \n        const motivationText = scene.add.text(0, 50, motivationalMsg, {\n            fontSize: '18px',\n            color: '#FFA500',\n            fontFamily: 'Arial'\n        }).setOrigin(0.5);\n        \n        // Buttons - Retry is more prominent\n        const retryBtn = this.createButton(\n            scene, 0, 120, 'TRY AGAIN', \n            0xFF6B6B, 0xFF8E8E, true, onRetry\n        );\n        \n        const menuBtn = this.createButton(\n            scene, 0, 185, 'Main Menu', \n            0x5C5C8A, 0x7C7CAA, false, onMenu\n        );\n        \n        // Add all elements\n        this.add([\n            backdrop, panelBg, banner,\n            defeatText, encourageText,\n            scoreBg, scoreLabel, scoreValue,\n            motivationText, retryBtn, menuBtn\n        ]);\n        \n        // Initial state for animations\n        this.setAlpha(0);\n        panelBg.setScale(0.8);\n        defeatText.setScale(0);\n        \n        // Gentle entrance animations\n        scene.tweens.add({\n            targets: this,\n            alpha: 1,\n            duration: 500,\n            ease: 'Power2'\n        });\n        \n        scene.tweens.add({\n            targets: panelBg,\n            scaleX: 1,\n            scaleY: 1,\n            duration: 600,\n            ease: 'Quad.easeOut',\n            delay: 100\n        });\n        \n        scene.tweens.add({\n            targets: defeatText,\n            scaleX: 1,\n            scaleY: 1,\n            duration: 400,\n            ease: 'Quad.easeOut',\n            delay: 300\n        });\n        \n        // Gentle pulsing on encourage text\n        scene.tweens.add({\n            targets: encourageText,\n            scale: 1.05,\n            duration: 1500,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Score display (immediate, no count up for defeat)\n        scoreValue.setScale(0);\n        scene.tweens.add({\n            targets: scoreValue,\n            scale: 1,\n            duration: 400,\n            ease: 'Back.easeOut',\n            delay: 500\n        });\n        \n        // Add some floating bubbles for visual interest\n        this.createFloatingBubbles(scene);\n        \n        this.setDepth(2000);\n        scene.add.existing(this);\n    }\n    \n    private createButton(\n        scene: Phaser.Scene, \n        x: number, \n        y: number, \n        text: string, \n        bgColor: number,\n        hoverColor: number,\n        isPrimary: boolean,\n        callback: () => void\n    ): Phaser.GameObjects.Container {\n        const button = scene.add.container(x, y);\n        \n        const width = isPrimary ? 240 : 200;\n        const height = isPrimary ? 60 : 50;\n        const fontSize = isPrimary ? '24px' : '20px';\n        \n        const bg = scene.add.rectangle(0, 0, width, height, bgColor);\n        bg.setInteractive({ useHandCursor: true });\n        bg.setStrokeStyle(isPrimary ? 3 : 2, 0xFFFFFF);\n        \n        const shadow = scene.add.rectangle(0, 3, width, height, 0x000000, 0.3);\n        shadow.setDepth(-1);\n        \n        const label = scene.add.text(0, 0, text, {\n            fontSize: fontSize,\n            color: '#FFFFFF',\n            fontFamily: isPrimary ? 'Arial Black' : 'Arial',\n            fontStyle: 'bold'\n        }).setOrigin(0.5);\n        \n        button.add([shadow, bg, label]);\n        \n        // Primary button pulses\n        if (isPrimary) {\n            scene.tweens.add({\n                targets: bg,\n                scale: 1.05,\n                duration: 1000,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut'\n            });\n        }\n        \n        // Button interactions\n        bg.on('pointerover', () => {\n            bg.setFillStyle(hoverColor);\n            scene.tweens.add({\n                targets: [bg, label],\n                scale: 1.1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n        \n        bg.on('pointerout', () => {\n            bg.setFillStyle(bgColor);\n            scene.tweens.add({\n                targets: [bg, label],\n                scale: 1,\n                duration: 100,\n                ease: 'Power2'\n            });\n        });\n        \n        bg.on('pointerdown', () => {\n            console.log(`💆 DefeatScreen button clicked: ${text}`);\n            \n            // Emit UI click event for sound system\n            scene.events.emit('ui-click');\n            \n            // Execute callback IMMEDIATELY without waiting for tween\n            console.log(`🚀 Executing callback for: ${text}`);\n            \n            try {\n                if (callback && typeof callback === 'function') {\n                    console.log(`💫 Callback type check passed, executing...`);\n                    callback();\n                    console.log(`✅ Callback executed successfully!`);\n                } else {\n                    console.error('❌ Callback is not a function:', callback, 'Type:', typeof callback);\n                }\n            } catch (error) {\n                console.error('❌ Error executing callback:', error);\n            }\n            \n            // Visual feedback AFTER callback\n            scene.tweens.add({\n                targets: button,\n                scale: 0.9,\n                duration: 100,\n                yoyo: true,\n                ease: 'Power2'\n            });\n        });\n        \n        // Initial animation\n        button.setAlpha(0);\n        scene.tweens.add({\n            targets: button,\n            alpha: 1,\n            duration: 500,\n            ease: 'Power2',\n            delay: 800 + (isPrimary ? 0 : 200)\n        });\n        \n        return button;\n    }\n    \n    private createFloatingBubbles(scene: Phaser.Scene): void {\n        const colors = [0x7B68EE, 0x4B0082, 0x6A5ACD];\n        \n        for (let i = 0; i < 5; i++) {\n            const x = Phaser.Math.Between(-150, 150);\n            const y = Phaser.Math.Between(-200, 200);\n            \n            const bubble = scene.add.circle(x, y, 15, colors[i % colors.length], 0.2);\n            this.add(bubble);\n            \n            // Floating animation\n            scene.tweens.add({\n                targets: bubble,\n                y: y - 30,\n                duration: 3000 + i * 500,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut',\n                delay: i * 200\n            });\n            \n            scene.tweens.add({\n                targets: bubble,\n                x: x + Phaser.Math.Between(-20, 20),\n                duration: 2000 + i * 300,\n                yoyo: true,\n                repeat: -1,\n                ease: 'Sine.easeInOut',\n                delay: i * 150\n            });\n        }\n    }\n    \n    public destroy(): void {\n        this.scene.tweens.killTweensOf(this);\n        super.destroy();\n    }\n}","import { Scene } from 'phaser';\nimport { HD_SCALE } from '@/config/GameConfig';\n\n// Types of poolable effects\nexport enum EffectType {\n    FLOATING_TEXT = 'floating_text',\n    PARTICLE_BURST = 'particle_burst',\n    RING_EXPLOSION = 'ring_explosion',\n    STAR_BURST = 'star_burst',\n    COMBO_DISPLAY = 'combo_display'\n}\n\n// Base interface for poolable effects\ninterface IPoolableEffect {\n    type: EffectType;\n    active: boolean;\n    gameObject: Phaser.GameObjects.GameObject;\n    reset(): void;\n    activate(x: number, y: number, ...args: any[]): void;\n    deactivate(): void;\n    update?(delta: number): void;\n}\n\n// Floating text effect\nclass FloatingTextEffect implements IPoolableEffect {\n    type = EffectType.FLOATING_TEXT;\n    active = false;\n    gameObject: Phaser.GameObjects.Container;\n    private scene: Scene;\n    private text: Phaser.GameObjects.Text;\n    private tween?: Phaser.Tweens.Tween;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        \n        // Create container\n        this.gameObject = scene.add.container(0, 0);\n        this.gameObject.setDepth(1200);\n        \n        // Create text - optimized for mobile\n        this.text = scene.add.text(0, 0, '', {\n            fontSize: `${10 * HD_SCALE}px`,  // Balanced size for mobile HD\n            color: '#FFFFFF',\n            fontFamily: 'Arial Black',\n            fontStyle: 'bold',\n            stroke: '#000000',\n            strokeThickness: 2 * HD_SCALE  // Clean stroke width HD\n        });\n        this.text.setOrigin(0.5);\n        this.text.setShadow(1 * HD_SCALE, 1 * HD_SCALE, '#000000', 2 * HD_SCALE, true, true);\n        \n        this.gameObject.add(this.text);\n        this.deactivate();\n    }\n    \n    reset(): void {\n        if (this.tween) {\n            this.tween.stop();\n            this.tween = undefined;\n        }\n        this.gameObject.setScale(1);\n        this.gameObject.setAlpha(1);\n        this.gameObject.setPosition(0, 0);\n    }\n    \n    activate(x: number, y: number, text: string, color: number, duration: number = 1000): void {\n        this.reset();\n        this.active = true;\n        this.gameObject.setVisible(true);\n        this.gameObject.setPosition(x, y);\n        this.text.setText(text);\n        this.text.setTint(color);\n        \n        // Adjust font size based on text content - balanced for HD visibility\n        if (text.includes('PERFECT')) {\n            this.text.setFontSize(`${18 * HD_SCALE}px`);  // Largest combo\n        } else if (text.includes('AMAZING')) {\n            this.text.setFontSize(`${17 * HD_SCALE}px`);  // Large combo\n        } else if (text.includes('GREAT')) {\n            this.text.setFontSize(`${17 * HD_SCALE}px`);  // Large combo\n        } else if (text.includes('GOOD')) {\n            this.text.setFontSize(`${16 * HD_SCALE}px`);  // Medium combo\n        } else if (text.includes('CHAIN')) {\n            this.text.setFontSize(`${17 * HD_SCALE}px`);  // Large combo\n        } else if (text.includes('DROP')) {\n            this.text.setFontSize(`${16 * HD_SCALE}px`);  // Medium size\n        } else {\n            this.text.setFontSize(`${16 * HD_SCALE}px`); // Same as medium - visible for points\n        }\n        \n        // Animate\n        this.gameObject.setScale(0);\n        \n        // Pop in - balanced impact\n        const isCombo = text.includes('PERFECT') || text.includes('AMAZING') || \n                        text.includes('GREAT') || text.includes('GOOD') || \n                        text.includes('CHAIN');\n        const targetScale = isCombo ? 1.1 : 1.0;\n        \n        this.scene.tweens.add({\n            targets: this.gameObject,\n            scale: { from: 0, to: targetScale },\n            duration: 250,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                // Settle to final size\n                this.scene.tweens.add({\n                    targets: this.gameObject,\n                    scale: 1.0,\n                    duration: 100,\n                    ease: 'Sine.easeInOut'\n                });\n            }\n        });\n        \n        // Float up and fade\n        this.tween = this.scene.tweens.add({\n            targets: this.gameObject,\n            y: y - 60,\n            alpha: 0,\n            duration: duration,\n            delay: 300,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                this.deactivate();\n            }\n        });\n    }\n    \n    deactivate(): void {\n        this.active = false;\n        this.gameObject.setVisible(false);\n        this.reset();\n    }\n}\n\n// Particle burst effect\nclass ParticleBurstEffect implements IPoolableEffect {\n    type = EffectType.PARTICLE_BURST;\n    active = false;\n    gameObject: Phaser.GameObjects.Container;\n    private scene: Scene;\n    private particles: Phaser.GameObjects.Arc[] = [];\n    private tweens: Phaser.Tweens.Tween[] = [];\n    private readonly MAX_PARTICLES = 30;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.gameObject = scene.add.container(0, 0);\n        this.gameObject.setDepth(1150);\n        \n        // Pre-create particles\n        for (let i = 0; i < this.MAX_PARTICLES; i++) {\n            const particle = scene.add.circle(0, 0, 3, 0xFFFFFF);\n            particle.setVisible(false);\n            this.particles.push(particle);\n            this.gameObject.add(particle);\n        }\n        \n        this.deactivate();\n    }\n    \n    reset(): void {\n        this.tweens.forEach(tween => tween.stop());\n        this.tweens = [];\n        this.particles.forEach(p => {\n            p.setVisible(false);\n            p.setPosition(0, 0);\n            p.setScale(1);\n            p.setAlpha(1);\n        });\n    }\n    \n    activate(x: number, y: number, color: number, particleCount: number = 20, intensity: number = 1): void {\n        this.reset();\n        this.active = true;\n        this.gameObject.setVisible(true);\n        this.gameObject.setPosition(x, y);\n        \n        const count = Math.min(particleCount, this.MAX_PARTICLES);\n        const speedBase = 100 * intensity;\n        \n        for (let i = 0; i < count; i++) {\n            const particle = this.particles[i];\n            particle.setVisible(true);\n            particle.setFillStyle(color);\n            particle.setRadius(Phaser.Math.Between(2, 4));\n            \n            const angle = (Math.PI * 2 * i) / count;\n            const speed = Phaser.Math.Between(speedBase * 0.5, speedBase * 1.5);\n            \n            const tween = this.scene.tweens.add({\n                targets: particle,\n                x: Math.cos(angle) * speed,\n                y: Math.sin(angle) * speed,\n                alpha: 0,\n                scale: 0,\n                duration: Phaser.Math.Between(400, 800),\n                ease: 'Power2.easeOut',\n                delay: i * 5,\n                onComplete: () => {\n                    particle.setVisible(false);\n                    if (i === count - 1) {\n                        this.deactivate();\n                    }\n                }\n            });\n            \n            this.tweens.push(tween);\n        }\n    }\n    \n    deactivate(): void {\n        this.active = false;\n        this.gameObject.setVisible(false);\n        this.reset();\n    }\n}\n\n// Ring explosion effect\nclass RingExplosionEffect implements IPoolableEffect {\n    type = EffectType.RING_EXPLOSION;\n    active = false;\n    gameObject: Phaser.GameObjects.Graphics;\n    private scene: Scene;\n    private tween?: Phaser.Tweens.Tween;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.gameObject = scene.add.graphics();\n        this.gameObject.setDepth(1049);\n        this.deactivate();\n    }\n    \n    reset(): void {\n        if (this.tween) {\n            this.tween.stop();\n            this.tween = undefined;\n        }\n        this.gameObject.clear();\n        this.gameObject.setScale(1);\n        this.gameObject.setAlpha(1);\n    }\n    \n    activate(x: number, y: number, color: number, size: number = 30): void {\n        this.reset();\n        this.active = true;\n        this.gameObject.setVisible(true);\n        this.gameObject.setPosition(x, y);\n        \n        this.gameObject.lineStyle(2 * HD_SCALE, color, 1);\n        this.gameObject.strokeCircle(0, 0, size);\n        this.gameObject.setScale(0);\n        \n        this.tween = this.scene.tweens.add({\n            targets: this.gameObject,\n            scale: 3,\n            alpha: 0,\n            duration: 600,\n            ease: 'Cubic.easeOut',\n            onComplete: () => {\n                this.deactivate();\n            }\n        });\n    }\n    \n    deactivate(): void {\n        this.active = false;\n        this.gameObject.setVisible(false);\n        this.reset();\n    }\n}\n\n// Main Effect Pool Manager\nexport class EffectPool {\n    private scene: Scene;\n    private pools: Map<EffectType, IPoolableEffect[]> = new Map();\n    private activeEffects: IPoolableEffect[] = [];\n    \n    // Pool sizes\n    private readonly POOL_SIZES = {\n        [EffectType.FLOATING_TEXT]: 20,\n        [EffectType.PARTICLE_BURST]: 10,\n        [EffectType.RING_EXPLOSION]: 8,\n        [EffectType.STAR_BURST]: 6,\n        [EffectType.COMBO_DISPLAY]: 10\n    };\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.initializePools();\n    }\n    \n    private initializePools(): void {\n        // Initialize floating text pool\n        this.createPool(EffectType.FLOATING_TEXT, () => new FloatingTextEffect(this.scene));\n        \n        // Initialize particle burst pool\n        this.createPool(EffectType.PARTICLE_BURST, () => new ParticleBurstEffect(this.scene));\n        \n        // Initialize ring explosion pool\n        this.createPool(EffectType.RING_EXPLOSION, () => new RingExplosionEffect(this.scene));\n    }\n    \n    private createPool(type: EffectType, factory: () => IPoolableEffect): void {\n        const pool: IPoolableEffect[] = [];\n        const size = this.POOL_SIZES[type] || 10;\n        \n        for (let i = 0; i < size; i++) {\n            pool.push(factory());\n        }\n        \n        this.pools.set(type, pool);\n    }\n    \n    public getEffect(type: EffectType): IPoolableEffect | null {\n        const pool = this.pools.get(type);\n        if (!pool) return null;\n        \n        // Find inactive effect\n        for (const effect of pool) {\n            if (!effect.active) {\n                this.activeEffects.push(effect);\n                return effect;\n            }\n        }\n        \n        // All effects in use, reuse the oldest one\n        const oldest = pool[0];\n        oldest.deactivate();\n        this.activeEffects.push(oldest);\n        return oldest;\n    }\n    \n    public showFloatingText(x: number, y: number, text: string, color: number = 0xFFD700, duration: number = 1000): void {\n        const effect = this.getEffect(EffectType.FLOATING_TEXT) as FloatingTextEffect;\n        if (effect) {\n            effect.activate(x, y, text, color, duration);\n        }\n    }\n    \n    public showParticleBurst(x: number, y: number, color: number, particleCount: number = 20, intensity: number = 1): void {\n        const effect = this.getEffect(EffectType.PARTICLE_BURST) as ParticleBurstEffect;\n        if (effect) {\n            effect.activate(x, y, color, particleCount, intensity);\n        }\n    }\n    \n    public showRingExplosion(x: number, y: number, color: number, size: number = 30): void {\n        const effect = this.getEffect(EffectType.RING_EXPLOSION) as RingExplosionEffect;\n        if (effect) {\n            effect.activate(x, y, color, size);\n        }\n    }\n    \n    public showComboEffect(x: number, y: number, comboLevel: number, score: number, color: number): void {\n        // Show multiple effects based on combo level\n        this.showFloatingText(x, y - 20, `+${score}`, color);\n        \n        if (comboLevel >= 2) {\n            this.showParticleBurst(x, y, color, 10 * comboLevel, comboLevel * 0.5);\n        }\n        \n        if (comboLevel >= 4) {\n            this.showRingExplosion(x, y, color, 20 + comboLevel * 5);\n        }\n    }\n    \n    public update(delta: number): void {\n        // Update active effects that need per-frame updates\n        this.activeEffects = this.activeEffects.filter(effect => {\n            if (effect.active && effect.update) {\n                effect.update(delta);\n            }\n            return effect.active;\n        });\n    }\n    \n    public reset(): void {\n        // Deactivate all effects\n        this.pools.forEach(pool => {\n            pool.forEach(effect => effect.deactivate());\n        });\n        this.activeEffects = [];\n    }\n    \n    public destroy(): void {\n        this.reset();\n        \n        // Destroy all game objects\n        this.pools.forEach(pool => {\n            pool.forEach(effect => {\n                if (effect.gameObject) {\n                    effect.gameObject.destroy();\n                }\n            });\n        });\n        \n        this.pools.clear();\n    }\n}","import { Scene } from 'phaser';\nimport { EffectPool } from './EffectPool';\nimport { ScoreResult } from './ScoreEventManager';\n\ninterface FeedbackQueueItem {\n    result: ScoreResult;\n    position: { x: number; y: number };\n    timestamp: number;\n}\n\ninterface ActiveFeedback {\n    position: { x: number; y: number };\n    endTime: number;\n}\n\nexport class UnifiedFeedbackSystem {\n    private scene: Scene;\n    private effectPool: EffectPool;\n    private feedbackQueue: FeedbackQueueItem[] = [];\n    private activeFeedbacks: ActiveFeedback[] = [];\n    private processing: boolean = false;\n    \n    // Spacing configuration - tighter for mobile screens\n    private readonly MIN_VERTICAL_SPACING = 35;\n    private readonly MIN_HORIZONTAL_SPACING = 50;\n    private readonly FEEDBACK_DURATION = 1500;\n    private readonly MAX_QUEUE_SIZE = 30;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.effectPool = new EffectPool(scene);\n        \n        // Start processing queue\n        this.startProcessing();\n    }\n    \n    private startProcessing(): void {\n        this.scene.time.addEvent({\n            delay: 16, // ~60fps\n            callback: this.processQueue,\n            callbackScope: this,\n            loop: true\n        });\n    }\n    \n    public queueFeedback(result: ScoreResult, position: { x: number; y: number }): void {\n        // Add to queue\n        this.feedbackQueue.push({\n            result,\n            position,\n            timestamp: Date.now()\n        });\n        \n        // Limit queue size\n        if (this.feedbackQueue.length > this.MAX_QUEUE_SIZE) {\n            this.feedbackQueue.shift();\n        }\n    }\n    \n    private processQueue(): void {\n        if (this.processing || this.feedbackQueue.length === 0) return;\n        \n        this.processing = true;\n        \n        // Clean up expired active feedbacks\n        const now = Date.now();\n        this.activeFeedbacks = this.activeFeedbacks.filter(f => f.endTime > now);\n        \n        // Process up to 3 feedbacks per frame\n        const itemsToProcess = Math.min(3, this.feedbackQueue.length);\n        \n        for (let i = 0; i < itemsToProcess; i++) {\n            const item = this.feedbackQueue.shift();\n            if (!item) continue;\n            \n            this.showFeedback(item);\n        }\n        \n        this.processing = false;\n    }\n    \n    private showFeedback(item: FeedbackQueueItem): void {\n        const { result, position } = item;\n        \n        // Calculate offset to prevent overlapping\n        const offset = this.calculateOffset(position);\n        const finalPosition = {\n            x: position.x + offset.x,\n            y: position.y + offset.y\n        };\n        \n        // Add to active feedbacks\n        this.activeFeedbacks.push({\n            position: finalPosition,\n            endTime: Date.now() + this.FEEDBACK_DURATION\n        });\n        \n        // Show effects based on visual effect level\n        this.showEffectsForLevel(result, finalPosition);\n    }\n    \n    private calculateOffset(position: { x: number; y: number }): { x: number; y: number } {\n        let offsetX = 0;\n        let offsetY = 0;\n        let conflictCount = 0;\n        \n        // Check for nearby active feedbacks\n        for (const active of this.activeFeedbacks) {\n            const dx = Math.abs(position.x - active.position.x);\n            const dy = Math.abs(position.y - active.position.y);\n            \n            // If too close, calculate offset\n            if (dx < this.MIN_HORIZONTAL_SPACING && dy < this.MIN_VERTICAL_SPACING) {\n                conflictCount++;\n                \n                // Alternate between up and down offsets for better distribution\n                if (conflictCount % 2 === 0) {\n                    offsetY -= this.MIN_VERTICAL_SPACING;\n                } else {\n                    offsetY += this.MIN_VERTICAL_SPACING;\n                }\n                \n                // Add slight horizontal offset for visual variety\n                offsetX = (conflictCount % 3 - 1) * 20;\n            }\n        }\n        \n        return { x: offsetX, y: offsetY };\n    }\n    \n    private showEffectsForLevel(result: ScoreResult, position: { x: number; y: number }): void {\n        const { visualEffectLevel, displayText, color, finalScore } = result;\n        \n        // Always show score text - optimized duration for mobile\n        this.effectPool.showFloatingText(\n            position.x,\n            position.y,\n            displayText,\n            color,\n            800 + (visualEffectLevel * 150) // Shorter duration for mobile readability\n        );\n        \n        // Add effects based on level\n        switch (visualEffectLevel) {\n            case 1: // Basic match (3 bubbles)\n                // Enhanced subtle effect with small pop and sparkle\n                this.effectPool.showParticleBurst(position.x, position.y, color, 6, 0.4);\n                this.createSparkleEffect(position.x, position.y, color, 3);\n                this.createPopEffect(position.x, position.y, color, 0.8);\n                break;\n                \n            case 2: // Small combo (4 bubbles) - \"GOOD!\"\n                this.effectPool.showParticleBurst(position.x, position.y, color, 12, 0.6);\n                this.createSparkleEffect(position.x, position.y, color, 5);\n                this.createPopEffect(position.x, position.y, color, 1.0);\n                this.addScreenShake(30, 0.001);\n                break;\n                \n            case 3: // Medium combo (5 bubbles) - \"GREAT!\"\n                this.effectPool.showParticleBurst(position.x, position.y, color, 25, 0.9);\n                this.effectPool.showRingExplosion(position.x, position.y, color, 20);\n                this.createSparkleEffect(position.x, position.y, color, 8);\n                this.addScreenShake(80, 0.002);\n                break;\n                \n            case 4: // Large combo (6 bubbles) - \"AMAZING!\"\n                this.effectPool.showParticleBurst(position.x, position.y, color, 40, 1.2);\n                this.effectPool.showRingExplosion(position.x, position.y, color, 30);\n                this.createSparkleEffect(position.x, position.y, color, 12);\n                this.addScreenShake(120, 0.004);\n                this.addCameraFlash(40, color);\n                break;\n                \n            case 5: // Mega combo (7+ bubbles) - \"PERFECT!\"\n                // Epic effects\n                this.effectPool.showParticleBurst(position.x, position.y, color, 60, 1.4);\n                this.effectPool.showRingExplosion(position.x, position.y, color, 40);\n                this.createFireEffect(position.x, position.y, color);\n                this.createSparkleEffect(position.x, position.y, color, 20);\n                this.addScreenShake(180, 0.006);\n                this.addCameraFlash(80, color);\n                break;\n        }\n        \n        // Don't show multiplier text separately - it's now part of the main text\n    }\n    \n    private createSparkleEffect(x: number, y: number, color: number, count: number): void {\n        // Create sparkle/star effects for polish\n        for (let i = 0; i < count; i++) {\n            const star = this.scene.add.star(\n                x + Phaser.Math.Between(-20, 20),\n                y + Phaser.Math.Between(-20, 20),\n                4, 2, 4,\n                color\n            );\n            star.setDepth(1150);\n            star.setScale(0);\n            star.setAlpha(0.8);\n            \n            // Animate sparkle\n            this.scene.tweens.add({\n                targets: star,\n                scale: { from: 0, to: Phaser.Math.FloatBetween(0.3, 0.6) },\n                alpha: { from: 0.8, to: 0 },\n                angle: 360,\n                duration: Phaser.Math.Between(600, 900),\n                delay: i * 50,\n                ease: 'Sine.easeOut',\n                onComplete: () => {\n                    star.destroy();\n                }\n            });\n        }\n    }\n    \n    private createPopEffect(x: number, y: number, color: number, scale: number): void {\n        // Create a subtle pop effect\n        const pop = this.scene.add.circle(x, y, 15, color, 0.3);\n        pop.setDepth(1140);\n        pop.setScale(0);\n        pop.setBlendMode(Phaser.BlendModes.ADD);\n        \n        this.scene.tweens.add({\n            targets: pop,\n            scale: scale,\n            alpha: 0,\n            duration: 300,\n            ease: 'Back.easeOut',\n            onComplete: () => {\n                pop.destroy();\n            }\n        });\n    }\n    \n    private createFireEffect(x: number, y: number, color: number): void {\n        // Create dramatic fire effect for mega combos\n        const particleCount = 30;\n        \n        for (let i = 0; i < particleCount; i++) {\n            const angle = (Math.PI * 2 * i) / particleCount;\n            const speed = Phaser.Math.Between(50, 150);\n            \n            const flame = this.scene.add.circle(\n                x + Math.cos(angle) * 10,\n                y + Math.sin(angle) * 10,\n                Phaser.Math.Between(3, 6),\n                color\n            );\n            flame.setDepth(1051);\n            flame.setBlendMode(Phaser.BlendModes.ADD);\n            \n            const targetX = x + Math.cos(angle) * speed;\n            const targetY = y + Math.sin(angle) * speed - Phaser.Math.Between(20, 60);\n            \n            this.scene.tweens.add({\n                targets: flame,\n                x: targetX,\n                y: targetY,\n                alpha: { from: 1, to: 0 },\n                scale: { from: 1.5, to: 0 },\n                duration: Phaser.Math.Between(600, 1000),\n                delay: i * 10,\n                ease: 'Cubic.easeOut',\n                onComplete: () => {\n                    flame.destroy();\n                }\n            });\n        }\n    }\n    \n    private addScreenShake(duration: number, intensity: number): void {\n        this.scene.cameras.main.shake(duration, intensity);\n    }\n    \n    private addCameraFlash(duration: number, color: number): void {\n        // Convert color to RGB\n        const colorObj = Phaser.Display.Color.IntegerToColor(color);\n        this.scene.cameras.main.flash(\n            duration,\n            colorObj.red,\n            colorObj.green,\n            colorObj.blue,\n            false\n        );\n    }\n    \n    public update(delta: number): void {\n        this.effectPool.update(delta);\n    }\n    \n    public reset(): void {\n        this.feedbackQueue = [];\n        this.activeFeedbacks = [];\n        this.effectPool.reset();\n    }\n    \n    public destroy(): void {\n        this.reset();\n        this.effectPool.destroy();\n    }\n}","import { Scene } from 'phaser';\nimport { PowerUpType } from './PowerUpManager';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\n\nexport enum AimingMode {\n    NORMAL = 'crosshair',\n    RAINBOW = 'rainbow_sphere',\n    LASER = 'extended_line',\n    BOMB_NORMAL = 'explosion_radius',\n    BOMB_BALLISTIC = 'ballistic_arc',\n    LIGHTNING = 'selection_cursor',\n    FREEZE = 'snowflake_area',\n    MULTI = 'triple_arrow'\n}\n\nexport interface TargetingInfo {\n    mode: AimingMode;\n    position: { x: number; y: number };\n    angle?: number;\n    radius?: number;\n    trajectory?: Phaser.Geom.Point[];\n}\n\n/**\n * Manages different aiming modes for power-ups\n */\nexport class AimingModeSystem {\n    private scene: Scene;\n    private currentMode: AimingMode = AimingMode.NORMAL;\n    private aimingGraphics: Phaser.GameObjects.Graphics;\n    private trajectoryLine?: Phaser.GameObjects.Graphics;\n    private cursorSprite?: Phaser.GameObjects.Image;\n    private modeIndicator?: Phaser.GameObjects.Container;\n    private activePowerUp?: PowerUpType;\n    \n    // Trajectory calculation\n    private trajectoryPoints: Phaser.Geom.Point[] = [];\n    private readonly MAX_BOUNCES = 3;\n    private readonly TRAJECTORY_STEPS = 50;\n    \n    constructor(scene: Scene) {\n        this.scene = scene;\n        \n        // Create graphics layers but keep them hidden by default\n        this.aimingGraphics = scene.add.graphics();\n        this.aimingGraphics.setDepth(Z_LAYERS.UI);\n        this.aimingGraphics.setVisible(false); // Hidden by default\n        \n        this.trajectoryLine = scene.add.graphics();\n        this.trajectoryLine.setDepth(Z_LAYERS.UI - 1);\n        this.trajectoryLine.setVisible(false); // Hidden by default\n    }\n    \n    /**\n     * Set the aiming mode based on power-up type\n     */\n    public setMode(mode: AimingMode, powerUp?: PowerUpType): void {\n        this.currentMode = mode;\n        this.activePowerUp = powerUp;\n        \n        // Clear previous graphics\n        this.clearGraphics();\n        \n        // Show/hide graphics based on mode\n        if (mode !== AimingMode.NORMAL) {\n            this.aimingGraphics.setVisible(true);\n            this.trajectoryLine?.setVisible(true);\n        } else {\n            this.aimingGraphics.setVisible(false);\n            this.trajectoryLine?.setVisible(false);\n        }\n        \n        // Create mode-specific indicator\n        this.createModeIndicator();\n        \n        // Update cursor style\n        this.updateCursorStyle();\n    }\n    \n    /**\n     * Update aiming graphics based on pointer position\n     */\n    public updateAiming(pointerX: number, pointerY: number, launcherX: number, launcherY: number): void {\n        this.clearGraphics();\n        \n        switch (this.currentMode) {\n            case AimingMode.NORMAL:\n                this.drawNormalCrosshair(pointerX, pointerY);\n                this.drawBasicTrajectory(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.RAINBOW:\n                this.drawRainbowCrosshair(pointerX, pointerY);\n                this.drawBasicTrajectory(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.LASER:\n                this.drawLaserSight(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.BOMB_NORMAL:\n                this.drawBombRadius(pointerX, pointerY);\n                this.drawBasicTrajectory(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.BOMB_BALLISTIC:\n                this.drawBallisticArc(launcherX, launcherY, pointerX, pointerY);\n                break;\n                \n            case AimingMode.LIGHTNING:\n                this.drawSelectionCursor(pointerX, pointerY);\n                break;\n                \n            case AimingMode.FREEZE:\n                this.drawFreezeArea(pointerX, pointerY);\n                break;\n                \n            case AimingMode.MULTI:\n                this.drawTripleArrow(launcherX, launcherY, pointerX, pointerY);\n                break;\n        }\n    }\n    \n    private drawNormalCrosshair(x: number, y: number): void {\n        this.aimingGraphics.lineStyle(2, 0xFFFFFF, 0.8);\n        \n        // Draw crosshair\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x - 10, y);\n        this.aimingGraphics.lineTo(x + 10, y);\n        this.aimingGraphics.moveTo(x, y - 10);\n        this.aimingGraphics.lineTo(x, y + 10);\n        this.aimingGraphics.strokePath();\n        \n        // Draw circle\n        this.aimingGraphics.strokeCircle(x, y, 15);\n    }\n    \n    private drawRainbowCrosshair(x: number, y: number): void {\n        // Draw rainbow-colored crosshair\n        const colors = [0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF];\n        const segments = 6;\n        \n        for (let i = 0; i < segments; i++) {\n            const angle = (i / segments) * Math.PI * 2;\n            const nextAngle = ((i + 1) / segments) * Math.PI * 2;\n            \n            this.aimingGraphics.lineStyle(3, colors[i], 0.8);\n            this.aimingGraphics.beginPath();\n            this.aimingGraphics.arc(x, y, 20, angle, nextAngle);\n            this.aimingGraphics.strokePath();\n        }\n        \n        // Center dot\n        this.aimingGraphics.fillStyle(0xFFFFFF, 1);\n        this.aimingGraphics.fillCircle(x, y, 3);\n    }\n    \n    private drawLaserSight(launcherX: number, launcherY: number, targetX: number, targetY: number): void {\n        // Calculate extended trajectory with bounces\n        this.calculateTrajectory(launcherX, launcherY, targetX, targetY, true);\n        \n        // Draw extended laser line\n        this.trajectoryLine!.lineStyle(3, 0xFF0000, 1);\n        this.trajectoryLine!.lineBetween(\n            this.trajectoryPoints[0].x,\n            this.trajectoryPoints[0].y,\n            this.trajectoryPoints[0].x,\n            this.trajectoryPoints[0].y\n        );\n        \n        // Animated laser effect\n        const time = Date.now() * 0.001;\n        \n        for (let i = 0; i < this.trajectoryPoints.length - 1; i++) {\n            const alpha = 1 - (i / this.trajectoryPoints.length) * 0.5;\n            const width = 3 - (i / this.trajectoryPoints.length) * 2;\n            \n            // Pulsing effect\n            const pulse = Math.sin(time * 3 + i * 0.2) * 0.3 + 0.7;\n            \n            this.trajectoryLine!.lineStyle(width, 0xFF0000, alpha * pulse);\n            this.trajectoryLine!.lineBetween(\n                this.trajectoryPoints[i].x,\n                this.trajectoryPoints[i].y,\n                this.trajectoryPoints[i + 1].x,\n                this.trajectoryPoints[i + 1].y\n            );\n        }\n        \n        // Draw laser dot at end\n        const lastPoint = this.trajectoryPoints[this.trajectoryPoints.length - 1];\n        this.aimingGraphics.fillStyle(0xFF0000, 1);\n        this.aimingGraphics.fillCircle(lastPoint.x, lastPoint.y, 5);\n    }\n    \n    private drawBombRadius(x: number, y: number): void {\n        // Draw explosion radius preview\n        const radius = 100; // 7-bubble radius approximation\n        \n        // Outer ring\n        this.aimingGraphics.lineStyle(2, 0xFF4500, 0.3);\n        this.aimingGraphics.fillStyle(0xFF4500, 0.1);\n        this.aimingGraphics.fillCircle(x, y, radius);\n        this.aimingGraphics.strokeCircle(x, y, radius);\n        \n        // Inner rings for impact visualization\n        this.aimingGraphics.lineStyle(1, 0xFF6347, 0.5);\n        this.aimingGraphics.strokeCircle(x, y, radius * 0.66);\n        this.aimingGraphics.strokeCircle(x, y, radius * 0.33);\n        \n        // Center explosion point\n        this.aimingGraphics.fillStyle(0xFF0000, 1);\n        this.aimingGraphics.fillCircle(x, y, 5);\n        \n        // Draw bomb icon\n        const bomb = '💣';\n        if (!this.cursorSprite) {\n            const text = this.scene.add.text(x, y - radius - 20, bomb, {\n                fontSize: '24px'\n            });\n            text.setOrigin(0.5);\n            text.setDepth(Z_LAYERS.UI + 1);\n            \n            // Clean up after frame\n            this.scene.time.delayedCall(50, () => text.destroy());\n        }\n    }\n    \n    private drawBallisticArc(launcherX: number, launcherY: number, targetX: number, targetY: number): void {\n        // Calculate parabolic trajectory to castle\n        const points: Phaser.Geom.Point[] = [];\n        const steps = 30;\n        const maxHeight = Math.min(launcherY, targetY) - 100; // Peak height\n        \n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            \n            // Parabolic interpolation\n            const x = Phaser.Math.Linear(launcherX, targetX, t);\n            const baseY = Phaser.Math.Linear(launcherY, targetY, t);\n            \n            // Add parabolic arc\n            const arc = Math.sin(t * Math.PI) * (launcherY - maxHeight);\n            const y = baseY - arc;\n            \n            points.push(new Phaser.Geom.Point(x, y));\n        }\n        \n        // Draw ballistic path\n        this.trajectoryLine!.lineStyle(3, 0xFF0000, 0.5);\n        \n        for (let i = 0; i < points.length - 1; i++) {\n            const alpha = 0.5 + (i / points.length) * 0.5;\n            this.trajectoryLine!.lineStyle(2, 0xFF4500, alpha);\n            this.trajectoryLine!.lineBetween(\n                points[i].x, points[i].y,\n                points[i + 1].x, points[i + 1].y\n            );\n        }\n        \n        // Draw impact zone at target\n        this.aimingGraphics.fillStyle(0xFF0000, 0.3);\n        this.aimingGraphics.fillCircle(targetX, targetY, 30);\n        \n        // Draw castle target indicator\n        this.aimingGraphics.lineStyle(3, 0xFF0000, 1);\n        this.aimingGraphics.strokeCircle(targetX, targetY, 30);\n    }\n    \n    private drawSelectionCursor(x: number, y: number): void {\n        // Draw selection cursor for lightning\n        const size = 20;\n        \n        // Animated rotation\n        const angle = Date.now() * 0.002;\n        \n        // Draw rotating brackets\n        this.aimingGraphics.lineStyle(3, 0xFFFF00, 1);\n        \n        // Top-left bracket\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x - size, y - size + 5);\n        this.aimingGraphics.lineTo(x - size, y - size);\n        this.aimingGraphics.lineTo(x - size + 5, y - size);\n        this.aimingGraphics.strokePath();\n        \n        // Top-right bracket\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x + size - 5, y - size);\n        this.aimingGraphics.lineTo(x + size, y - size);\n        this.aimingGraphics.lineTo(x + size, y - size + 5);\n        this.aimingGraphics.strokePath();\n        \n        // Bottom-left bracket\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x - size, y + size - 5);\n        this.aimingGraphics.lineTo(x - size, y + size);\n        this.aimingGraphics.lineTo(x - size + 5, y + size);\n        this.aimingGraphics.strokePath();\n        \n        // Bottom-right bracket\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x + size - 5, y + size);\n        this.aimingGraphics.lineTo(x + size, y + size);\n        this.aimingGraphics.lineTo(x + size, y + size - 5);\n        this.aimingGraphics.strokePath();\n        \n        // Center lightning bolt\n        this.aimingGraphics.lineStyle(2, 0xFFFF00, 1);\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x - 5, y - 10);\n        this.aimingGraphics.lineTo(x + 2, y);\n        this.aimingGraphics.lineTo(x - 2, y);\n        this.aimingGraphics.lineTo(x + 5, y + 10);\n        this.aimingGraphics.strokePath();\n    }\n    \n    private drawFreezeArea(x: number, y: number): void {\n        // Draw freeze area indicator\n        const radius = 150;\n        \n        // Frost effect\n        this.aimingGraphics.fillStyle(0x87CEEB, 0.2);\n        this.aimingGraphics.fillCircle(x, y, radius);\n        \n        // Snowflake patterns\n        const snowflakeCount = 6;\n        for (let i = 0; i < snowflakeCount; i++) {\n            const angle = (i / snowflakeCount) * Math.PI * 2;\n            const sx = x + Math.cos(angle) * radius * 0.7;\n            const sy = y + Math.sin(angle) * radius * 0.7;\n            \n            // Draw simple snowflake\n            this.aimingGraphics.lineStyle(2, 0xFFFFFF, 0.8);\n            this.aimingGraphics.beginPath();\n            \n            // Six-pointed snowflake\n            for (let j = 0; j < 6; j++) {\n                const a = (j / 6) * Math.PI * 2;\n                this.aimingGraphics.moveTo(sx, sy);\n                this.aimingGraphics.lineTo(\n                    sx + Math.cos(a) * 10,\n                    sy + Math.sin(a) * 10\n                );\n            }\n            this.aimingGraphics.strokePath();\n        }\n    }\n    \n    private drawTripleArrow(launcherX: number, launcherY: number, targetX: number, targetY: number): void {\n        // Draw three trajectory lines for multi-shot\n        const baseAngle = Math.atan2(targetY - launcherY, targetX - launcherX);\n        const angles = [-15, 0, 15]; // Degrees\n        \n        angles.forEach((angleDiff, index) => {\n            const angle = baseAngle + Phaser.Math.DegToRad(angleDiff);\n            const distance = 200;\n            const endX = launcherX + Math.cos(angle) * distance;\n            const endY = launcherY + Math.sin(angle) * distance;\n            \n            // Different colors for each trajectory\n            const colors = [0xFF6B6B, 0xFFFFFF, 0x6B6BFF];\n            this.trajectoryLine!.lineStyle(2, colors[index], 0.6);\n            this.trajectoryLine!.lineBetween(launcherX, launcherY, endX, endY);\n            \n            // Arrow heads\n            this.drawArrowHead(endX, endY, angle, colors[index]);\n        });\n    }\n    \n    private drawArrowHead(x: number, y: number, angle: number, color: number): void {\n        const size = 10;\n        const angleLeft = angle - Phaser.Math.DegToRad(150);\n        const angleRight = angle + Phaser.Math.DegToRad(150);\n        \n        this.aimingGraphics.lineStyle(2, color, 0.8);\n        this.aimingGraphics.beginPath();\n        this.aimingGraphics.moveTo(x, y);\n        this.aimingGraphics.lineTo(x + Math.cos(angleLeft) * size, y + Math.sin(angleLeft) * size);\n        this.aimingGraphics.moveTo(x, y);\n        this.aimingGraphics.lineTo(x + Math.cos(angleRight) * size, y + Math.sin(angleRight) * size);\n        this.aimingGraphics.strokePath();\n    }\n    \n    private drawBasicTrajectory(launcherX: number, launcherY: number, targetX: number, targetY: number): void {\n        // Basic dotted line trajectory\n        this.trajectoryLine!.lineStyle(1, 0xFFFFFF, 0.5);\n        \n        const distance = Phaser.Math.Distance.Between(launcherX, launcherY, targetX, targetY);\n        const steps = Math.floor(distance / 20);\n        \n        for (let i = 0; i < steps; i += 2) {\n            const t1 = i / steps;\n            const t2 = Math.min((i + 1) / steps, 1);\n            \n            const x1 = Phaser.Math.Linear(launcherX, targetX, t1);\n            const y1 = Phaser.Math.Linear(launcherY, targetY, t1);\n            const x2 = Phaser.Math.Linear(launcherX, targetX, t2);\n            const y2 = Phaser.Math.Linear(launcherY, targetY, t2);\n            \n            this.trajectoryLine!.lineBetween(x1, y1, x2, y2);\n        }\n    }\n    \n    private calculateTrajectory(startX: number, startY: number, targetX: number, targetY: number, extended: boolean = false): void {\n        this.trajectoryPoints = [];\n        \n        // Calculate initial direction\n        const angle = Math.atan2(targetY - startY, targetX - startX);\n        const speed = 10;\n        let x = startX;\n        let y = startY;\n        let vx = Math.cos(angle) * speed;\n        let vy = Math.sin(angle) * speed;\n        let bounces = 0;\n        \n        const maxSteps = extended ? 200 : 100;\n        const screenWidth = this.scene.cameras.main.width;\n        \n        for (let i = 0; i < maxSteps; i++) {\n            this.trajectoryPoints.push(new Phaser.Geom.Point(x, y));\n            \n            x += vx;\n            y += vy;\n            \n            // Check for wall bounces\n            if ((x <= 10 || x >= screenWidth - 10) && bounces < this.MAX_BOUNCES) {\n                vx = -vx;\n                bounces++;\n            }\n            \n            // Stop at screen boundaries\n            if (y <= 0 || y >= this.scene.cameras.main.height) {\n                break;\n            }\n        }\n    }\n    \n    private createModeIndicator(): void {\n        // Clean up previous indicator\n        if (this.modeIndicator) {\n            this.modeIndicator.destroy();\n        }\n        \n        // Create mode-specific visual indicator at top of screen\n        const x = this.scene.cameras.main.centerX;\n        const y = 50;\n        \n        this.modeIndicator = this.scene.add.container(x, y);\n        this.modeIndicator.setDepth(Z_LAYERS.UI + 10);\n        \n        // Background\n        const bg = this.scene.add.graphics();\n        bg.fillStyle(0x000000, 0.7);\n        bg.fillRoundedRect(-60, -20, 120, 40, 10);\n        this.modeIndicator.add(bg);\n        \n        // Mode text\n        const modeNames: Record<AimingMode, string> = {\n            [AimingMode.NORMAL]: 'NORMAL',\n            [AimingMode.RAINBOW]: '🌈 RAINBOW',\n            [AimingMode.LASER]: '🎯 LASER',\n            [AimingMode.BOMB_NORMAL]: '💣 BOMB',\n            [AimingMode.BOMB_BALLISTIC]: '💣 BALLISTIC',\n            [AimingMode.LIGHTNING]: '⚡ LIGHTNING',\n            [AimingMode.FREEZE]: '❄️ FREEZE',\n            [AimingMode.MULTI]: '🎱 MULTI'\n        };\n        \n        const text = this.scene.add.text(0, 0, modeNames[this.currentMode], {\n            fontSize: '16px',\n            fontFamily: 'Arial Black',\n            color: '#FFFFFF'\n        });\n        text.setOrigin(0.5);\n        this.modeIndicator.add(text);\n        \n        // Fade in animation\n        this.modeIndicator.setAlpha(0);\n        this.scene.tweens.add({\n            targets: this.modeIndicator,\n            alpha: 1,\n            duration: 300,\n            ease: 'Cubic.easeOut'\n        });\n    }\n    \n    private updateCursorStyle(): void {\n        // Update HTML cursor style based on mode\n        const canvas = this.scene.game.canvas;\n        \n        switch (this.currentMode) {\n            case AimingMode.LIGHTNING:\n                canvas.style.cursor = 'crosshair';\n                break;\n            case AimingMode.BOMB_BALLISTIC:\n                canvas.style.cursor = 'crosshair';\n                break;\n            default:\n                canvas.style.cursor = 'default';\n                break;\n        }\n    }\n    \n    private clearGraphics(): void {\n        this.aimingGraphics.clear();\n        if (this.trajectoryLine) {\n            this.trajectoryLine.clear();\n        }\n    }\n    \n    public getTargetingInfo(): TargetingInfo {\n        return {\n            mode: this.currentMode,\n            position: { x: 0, y: 0 }, // Will be updated with actual pointer position\n            trajectory: this.trajectoryPoints\n        };\n    }\n    \n    public reset(): void {\n        this.setMode(AimingMode.NORMAL);\n        this.clearGraphics();\n        \n        if (this.modeIndicator) {\n            this.modeIndicator.destroy();\n            this.modeIndicator = undefined;\n        }\n    }\n    \n    public destroy(): void {\n        this.reset();\n        this.aimingGraphics.destroy();\n        \n        if (this.trajectoryLine) {\n            this.trajectoryLine.destroy();\n        }\n        \n        if (this.cursorSprite) {\n            this.cursorSprite.destroy();\n        }\n    }\n}","/*! Capacitor: https://capacitorjs.com/ - MIT License */\nvar ExceptionCode;\n(function (ExceptionCode) {\n    /**\n     * API is not implemented.\n     *\n     * This usually means the API can't be used because it is not implemented for\n     * the current platform.\n     */\n    ExceptionCode[\"Unimplemented\"] = \"UNIMPLEMENTED\";\n    /**\n     * API is not available.\n     *\n     * This means the API can't be used right now because:\n     *   - it is currently missing a prerequisite, such as network connectivity\n     *   - it requires a particular platform or browser version\n     */\n    ExceptionCode[\"Unavailable\"] = \"UNAVAILABLE\";\n})(ExceptionCode || (ExceptionCode = {}));\nclass CapacitorException extends Error {\n    constructor(message, code, data) {\n        super(message);\n        this.message = message;\n        this.code = code;\n        this.data = data;\n    }\n}\nconst getPlatformId = (win) => {\n    var _a, _b;\n    if (win === null || win === void 0 ? void 0 : win.androidBridge) {\n        return 'android';\n    }\n    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {\n        return 'ios';\n    }\n    else {\n        return 'web';\n    }\n};\n\nconst createCapacitor = (win) => {\n    const capCustomPlatform = win.CapacitorCustomPlatform || null;\n    const cap = win.Capacitor || {};\n    const Plugins = (cap.Plugins = cap.Plugins || {});\n    const getPlatform = () => {\n        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);\n    };\n    const isNativePlatform = () => getPlatform() !== 'web';\n    const isPluginAvailable = (pluginName) => {\n        const plugin = registeredPlugins.get(pluginName);\n        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {\n            // JS implementation available for the current platform.\n            return true;\n        }\n        if (getPluginHeader(pluginName)) {\n            // Native implementation available.\n            return true;\n        }\n        return false;\n    };\n    const getPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName); };\n    const handleError = (err) => win.console.error(err);\n    const registeredPlugins = new Map();\n    const registerPlugin = (pluginName, jsImplementations = {}) => {\n        const registeredPlugin = registeredPlugins.get(pluginName);\n        if (registeredPlugin) {\n            console.warn(`Capacitor plugin \"${pluginName}\" already registered. Cannot register plugins twice.`);\n            return registeredPlugin.proxy;\n        }\n        const platform = getPlatform();\n        const pluginHeader = getPluginHeader(pluginName);\n        let jsImplementation;\n        const loadPluginImplementation = async () => {\n            if (!jsImplementation && platform in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations[platform] === 'function'\n                        ? (jsImplementation = await jsImplementations[platform]())\n                        : (jsImplementation = jsImplementations[platform]);\n            }\n            else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations['web'] === 'function'\n                        ? (jsImplementation = await jsImplementations['web']())\n                        : (jsImplementation = jsImplementations['web']);\n            }\n            return jsImplementation;\n        };\n        const createPluginMethod = (impl, prop) => {\n            var _a, _b;\n            if (pluginHeader) {\n                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);\n                if (methodHeader) {\n                    if (methodHeader.rtype === 'promise') {\n                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);\n                    }\n                    else {\n                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);\n                    }\n                }\n                else if (impl) {\n                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);\n                }\n            }\n            else if (impl) {\n                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);\n            }\n            else {\n                throw new CapacitorException(`\"${pluginName}\" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n            }\n        };\n        const createPluginMethodWrapper = (prop) => {\n            let remove;\n            const wrapper = (...args) => {\n                const p = loadPluginImplementation().then((impl) => {\n                    const fn = createPluginMethod(impl, prop);\n                    if (fn) {\n                        const p = fn(...args);\n                        remove = p === null || p === void 0 ? void 0 : p.remove;\n                        return p;\n                    }\n                    else {\n                        throw new CapacitorException(`\"${pluginName}.${prop}()\" is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n                    }\n                });\n                if (prop === 'addListener') {\n                    p.remove = async () => remove();\n                }\n                return p;\n            };\n            // Some flair ✨\n            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;\n            Object.defineProperty(wrapper, 'name', {\n                value: prop,\n                writable: false,\n                configurable: false,\n            });\n            return wrapper;\n        };\n        const addListener = createPluginMethodWrapper('addListener');\n        const removeListener = createPluginMethodWrapper('removeListener');\n        const addListenerNative = (eventName, callback) => {\n            const call = addListener({ eventName }, callback);\n            const remove = async () => {\n                const callbackId = await call;\n                removeListener({\n                    eventName,\n                    callbackId,\n                }, callback);\n            };\n            const p = new Promise((resolve) => call.then(() => resolve({ remove })));\n            p.remove = async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            };\n            return p;\n        };\n        const proxy = new Proxy({}, {\n            get(_, prop) {\n                switch (prop) {\n                    // https://github.com/facebook/react/issues/20030\n                    case '$$typeof':\n                        return undefined;\n                    case 'toJSON':\n                        return () => ({});\n                    case 'addListener':\n                        return pluginHeader ? addListenerNative : addListener;\n                    case 'removeListener':\n                        return removeListener;\n                    default:\n                        return createPluginMethodWrapper(prop);\n                }\n            },\n        });\n        Plugins[pluginName] = proxy;\n        registeredPlugins.set(pluginName, {\n            name: pluginName,\n            proxy,\n            platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),\n        });\n        return proxy;\n    };\n    // Add in convertFileSrc for web, it will already be available in native context\n    if (!cap.convertFileSrc) {\n        cap.convertFileSrc = (filePath) => filePath;\n    }\n    cap.getPlatform = getPlatform;\n    cap.handleError = handleError;\n    cap.isNativePlatform = isNativePlatform;\n    cap.isPluginAvailable = isPluginAvailable;\n    cap.registerPlugin = registerPlugin;\n    cap.Exception = CapacitorException;\n    cap.DEBUG = !!cap.DEBUG;\n    cap.isLoggingEnabled = !!cap.isLoggingEnabled;\n    return cap;\n};\nconst initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));\n\nconst Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof global !== 'undefined'\n                ? global\n                : {});\nconst registerPlugin = Capacitor.registerPlugin;\n\n/**\n * Base class web plugins should extend.\n */\nclass WebPlugin {\n    constructor() {\n        this.listeners = {};\n        this.retainedEventArguments = {};\n        this.windowListeners = {};\n    }\n    addListener(eventName, listenerFunc) {\n        let firstListener = false;\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n            firstListener = true;\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        const windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        if (firstListener) {\n            this.sendRetainedArgumentsForEvent(eventName);\n        }\n        const remove = async () => this.removeListener(eventName, listenerFunc);\n        const p = Promise.resolve({ remove });\n        return p;\n    }\n    async removeAllListeners() {\n        this.listeners = {};\n        for (const listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    }\n    notifyListeners(eventName, data, retainUntilConsumed) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            if (retainUntilConsumed) {\n                let args = this.retainedEventArguments[eventName];\n                if (!args) {\n                    args = [];\n                }\n                args.push(data);\n                this.retainedEventArguments[eventName] = args;\n            }\n            return;\n        }\n        listeners.forEach((listener) => listener(data));\n    }\n    hasListeners(eventName) {\n        var _a;\n        return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);\n    }\n    registerWindowListener(windowEventName, pluginEventName) {\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName,\n            pluginEventName,\n            handler: (event) => {\n                this.notifyListeners(pluginEventName, event);\n            },\n        };\n    }\n    unimplemented(msg = 'not implemented') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);\n    }\n    unavailable(msg = 'not available') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);\n    }\n    async removeListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    }\n    addWindowListener(handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    }\n    removeWindowListener(handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    }\n    sendRetainedArgumentsForEvent(eventName) {\n        const args = this.retainedEventArguments[eventName];\n        if (!args) {\n            return;\n        }\n        delete this.retainedEventArguments[eventName];\n        args.forEach((arg) => {\n            this.notifyListeners(eventName, arg);\n        });\n    }\n}\n\nconst WebView = /*#__PURE__*/ registerPlugin('WebView');\n/******** END WEB VIEW PLUGIN ********/\n/******** COOKIES PLUGIN ********/\n/**\n * Safely web encode a string value (inspired by js-cookie)\n * @param str The string value to encode\n */\nconst encode = (str) => encodeURIComponent(str)\n    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n    .replace(/[()]/g, escape);\n/**\n * Safely web decode a string value (inspired by js-cookie)\n * @param str The string value to decode\n */\nconst decode = (str) => str.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\nclass CapacitorCookiesPluginWeb extends WebPlugin {\n    async getCookies() {\n        const cookies = document.cookie;\n        const cookieMap = {};\n        cookies.split(';').forEach((cookie) => {\n            if (cookie.length <= 0)\n                return;\n            // Replace first \"=\" with CAP_COOKIE to prevent splitting on additional \"=\"\n            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');\n            key = decode(key).trim();\n            value = decode(value).trim();\n            cookieMap[key] = value;\n        });\n        return cookieMap;\n    }\n    async setCookie(options) {\n        try {\n            // Safely Encoded Key/Value\n            const encodedKey = encode(options.key);\n            const encodedValue = encode(options.value);\n            // Clean & sanitize options\n            const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is \"; expires=\"\n            const path = (options.path || '/').replace('path=', ''); // Default is \"path=/\"\n            const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : '';\n            document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}; ${domain};`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async deleteCookie(options) {\n        try {\n            document.cookie = `${options.key}=; Max-Age=0`;\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearCookies() {\n        try {\n            const cookies = document.cookie.split(';') || [];\n            for (const cookie of cookies) {\n                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);\n            }\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    async clearAllCookies() {\n        try {\n            await this.clearCookies();\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n}\nconst CapacitorCookies = registerPlugin('CapacitorCookies', {\n    web: () => new CapacitorCookiesPluginWeb(),\n});\n// UTILITY FUNCTIONS\n/**\n * Read in a Blob value and return it as a base64 string\n * @param blob The blob value to convert to a base64 string\n */\nconst readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n        const base64String = reader.result;\n        // remove prefix \"data:application/pdf;base64,\"\n        resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(blob);\n});\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach((str) => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nconst buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // If body is already a string, then pass it through as-is.\n    if (typeof options.data === 'string') {\n        output.body = options.data;\n    }\n    // Build request initializers based off of content-type\n    else if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data') || options.data instanceof FormData) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (const key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') || typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n// WEB IMPLEMENTATION\nclass CapacitorHttpPluginWeb extends WebPlugin {\n    /**\n     * Perform an Http request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async request(options) {\n        const requestInit = buildRequestInit(options, options.webFetchExtra);\n        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n        const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n        const response = await fetch(url, requestInit);\n        const contentType = response.headers.get('content-type') || '';\n        // Default to 'text' responseType so no parsing happens\n        let { responseType = 'text' } = response.ok ? options : {};\n        // If the response content-type is json, force the response to be json\n        if (contentType.includes('application/json')) {\n            responseType = 'json';\n        }\n        let data;\n        let blob;\n        switch (responseType) {\n            case 'arraybuffer':\n            case 'blob':\n                blob = await response.blob();\n                data = await readBlobAsBase64(blob);\n                break;\n            case 'json':\n                data = await response.json();\n                break;\n            case 'document':\n            case 'text':\n            default:\n                data = await response.text();\n        }\n        // Convert fetch headers to Capacitor HttpHeaders\n        const headers = {};\n        response.headers.forEach((value, key) => {\n            headers[key] = value;\n        });\n        return {\n            data,\n            headers,\n            status: response.status,\n            url: response.url,\n        };\n    }\n    /**\n     * Perform an Http GET request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async get(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n    }\n    /**\n     * Perform an Http POST request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async post(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n    }\n    /**\n     * Perform an Http PUT request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async put(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n    }\n    /**\n     * Perform an Http PATCH request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async patch(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n    }\n    /**\n     * Perform an Http DELETE request given a set of options\n     * @param options Options to build the HTTP request\n     */\n    async delete(options) {\n        return this.request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n    }\n}\nconst CapacitorHttp = registerPlugin('CapacitorHttp', {\n    web: () => new CapacitorHttpPluginWeb(),\n});\n/******** END HTTP PLUGIN ********/\n\nexport { Capacitor, CapacitorCookies, CapacitorException, CapacitorHttp, ExceptionCode, WebPlugin, WebView, buildRequestInit, registerPlugin };\n//# sourceMappingURL=index.js.map\n","import { Scene } from 'phaser';\nimport { PowerUpType } from './PowerUpManager';\nimport { AimingMode, AimingModeSystem } from './AimingModeSystem';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { BubbleGrid } from '@/systems/gameplay/BubbleGrid';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\n\nexport interface PowerUpContext {\n    scene: Scene;\n    launcher: Launcher;\n    opponentLauncher?: Launcher;\n    aimingMode: AimingModeSystem;\n    bubbleGrid: BubbleGrid;\n    targetMode?: 'bubbles' | 'castle';\n    shotsRemaining?: number;\n}\n\nexport interface IPowerUpEffect {\n    type: PowerUpType;\n    activate(context: PowerUpContext): void;\n    deactivate?(context: PowerUpContext): void;\n    update?(context: PowerUpContext, delta: number): void;\n}\n\n/**\n * Rainbow Power-Up: Next bubble matches any color\n */\nexport class RainbowEffect implements IPowerUpEffect {\n    type = PowerUpType.RAINBOW;\n    private rainbowBubble?: Bubble;\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set aiming mode to rainbow\n        context.aimingMode.setMode(AimingMode.RAINBOW, this.type);\n        \n        // Visual feedback\n        const rainbowText = context.scene.add.text(\n            context.scene.cameras.main.centerX,\n            context.scene.cameras.main.centerY,\n            '🌈 RAINBOW BUBBLE!',\n            {\n                fontSize: '28px',\n                fontFamily: 'Arial Black',\n                color: '#FF69B4',\n                stroke: '#000000',\n                strokeThickness: 3\n            }\n        );\n        rainbowText.setOrigin(0.5);\n        rainbowText.setDepth(1000);\n        \n        // Animate text\n        context.scene.tweens.add({\n            targets: rainbowText,\n            scale: { from: 0, to: 1.2 },\n            alpha: { from: 1, to: 0 },\n            y: rainbowText.y - 50,\n            duration: 1500,\n            ease: 'Power2',\n            onComplete: () => rainbowText.destroy()\n        });\n        \n        // Single shot power-up\n        context.shotsRemaining = 1;\n    }\n    \n    private applyRainbowEffect(bubble: Bubble): void {\n        // Create rainbow shimmer\n        const shimmer = bubble.scene.add.graphics();\n        shimmer.setDepth(bubble.depth + 1);\n        \n        // Animated rainbow effect\n        bubble.scene.time.addEvent({\n            delay: 100,\n            callback: () => {\n                if (!bubble || !bubble.scene) return;\n                \n                shimmer.clear();\n                const time = Date.now() * 0.001;\n                const colors = [0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF];\n                const segments = 6;\n                \n                for (let i = 0; i < segments; i++) {\n                    const angle = (i / segments) * Math.PI * 2;\n                    const nextAngle = ((i + 1) / segments) * Math.PI * 2;\n                    const colorIndex = Math.floor((time + i) % colors.length);\n                    \n                    shimmer.lineStyle(2, colors[colorIndex], 0.8);\n                    shimmer.beginPath();\n                    shimmer.arc(bubble.x, bubble.y, 18, angle, nextAngle);\n                    shimmer.strokePath();\n                }\n            },\n            loop: true\n        });\n        \n        // Store shimmer reference for cleanup\n        // bubble.setData('rainbowShimmer', shimmer);\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        // Clean up rainbow effect\n        if (this.rainbowBubble) {\n            const shimmer = this.rainbowBubble.getData('rainbowShimmer');\n            if (shimmer) {\n                shimmer.destroy();\n            }\n            // this.rainbowBubble.setData('isRainbow', false);\n        }\n        \n        // Reset aiming mode\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Laser Sight Power-Up: Extended trajectory preview\n */\nexport class LaserSightEffect implements IPowerUpEffect {\n    type = PowerUpType.LASER;\n    private remainingShots: number = 5;\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set laser aiming mode\n        context.aimingMode.setMode(AimingMode.LASER, this.type);\n        \n        // 5 shots with enhanced aiming\n        this.remainingShots = 5;\n        context.shotsRemaining = 5;\n        \n        // Add UI indicator for remaining shots\n        this.createShotCounter(context);\n    }\n    \n    private createShotCounter(context: PowerUpContext): void {\n        const counter = context.scene.add.container(100, 100);\n        counter.setDepth(Z_LAYERS.UI + 10);\n        \n        // Background\n        const bg = context.scene.add.graphics();\n        bg.fillStyle(0x000000, 0.7);\n        bg.fillRoundedRect(-40, -20, 80, 40, 10);\n        counter.add(bg);\n        \n        // Text\n        const text = context.scene.add.text(0, 0, `🎯 ${this.remainingShots}`, {\n            fontSize: '20px',\n            fontFamily: 'Arial Black',\n            color: '#FF0000'\n        });\n        text.setOrigin(0.5);\n        counter.add(text);\n        \n        // Store reference\n        // context.launcher.setData('laserCounter', counter);\n        // context.launcher.setData('laserCounterText', text);\n    }\n    \n    update(context: PowerUpContext, delta: number): void {\n        // Update shot counter\n        const text = context.launcher.getData('laserCounterText') as Phaser.GameObjects.Text;\n        if (text && context.shotsRemaining !== undefined) {\n            text.setText(`🎯 ${context.shotsRemaining}`);\n        }\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        // Clean up UI\n        const counter = context.launcher.getData('laserCounter');\n        if (counter) {\n            counter.destroy();\n        }\n        \n        // Reset aiming\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Bomb Power-Up: Explosion or castle attack\n */\nexport class BombEffect implements IPowerUpEffect {\n    type = PowerUpType.BOMB;\n    private targetMode: 'bubbles' | 'castle' = 'bubbles';\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Check target mode\n        this.targetMode = context.targetMode || 'bubbles';\n        \n        if (this.targetMode === 'castle' && context.opponentLauncher) {\n            // Ballistic mode for castle attack\n            context.aimingMode.setMode(AimingMode.BOMB_BALLISTIC, this.type);\n            this.prepareBallistic(context);\n        } else {\n            // Normal bomb mode\n            context.aimingMode.setMode(AimingMode.BOMB_NORMAL, this.type);\n            this.prepareNormalBomb(context);\n        }\n        \n        context.shotsRemaining = 1;\n    }\n    \n    private prepareNormalBomb(context: PowerUpContext): void {\n        // Create AAA bomb ready effect with particles\n        const x = context.launcher.x;\n        const y = context.launcher.y;\n        \n        // Create glowing orb effect\n        const bombGlow = context.scene.add.graphics();\n        bombGlow.setDepth(999);\n        this.visualElements.push(bombGlow);\n        \n        // Animated glow rings\n        let glowRadius = 0;\n        const glowTimer = context.scene.time.addEvent({\n            delay: 50,\n            callback: () => {\n                bombGlow.clear();\n                \n                // Multiple rings for depth\n                for (let i = 0; i < 3; i++) {\n                    const radius = (glowRadius + i * 15) % 60;\n                    const alpha = Math.max(0, 1 - radius / 60);\n                    bombGlow.lineStyle(3, 0xFF4500, alpha * 0.5);\n                    bombGlow.strokeCircle(x, y - 30, radius);\n                }\n                \n                glowRadius = (glowRadius + 2) % 60;\n            },\n            loop: true\n        });\n        \n        // Create spark particles using circles instead of textures\n        const sparkContainer = context.scene.add.container(x, y - 30);\n        sparkContainer.setDepth(1000);\n        this.visualElements.push(sparkContainer);\n        \n        // Animated sparks\n        const sparkTimer = context.scene.time.addEvent({\n            delay: 100,\n            callback: () => {\n                for (let i = 0; i < 2; i++) {\n                    const spark = context.scene.add.circle(\n                        0, 0, \n                        Phaser.Math.Between(2, 4),\n                        Phaser.Math.RND.pick([0xFF4500, 0xFF6500, 0xFFAA00])\n                    );\n                    spark.setBlendMode(Phaser.BlendModes.ADD);\n                    sparkContainer.add(spark);\n                    \n                    const angle = Phaser.Math.Between(-110, -70) * Math.PI / 180;\n                    const speed = Phaser.Math.Between(100, 200);\n                    const vx = Math.cos(angle) * speed;\n                    const vy = Math.sin(angle) * speed;\n                    \n                    context.scene.tweens.add({\n                        targets: spark,\n                        x: spark.x + vx * 0.6,\n                        y: spark.y + vy * 0.6,\n                        scale: { from: 1, to: 0 },\n                        alpha: { from: 1, to: 0 },\n                        duration: 600,\n                        ease: 'Sine.easeOut',\n                        onComplete: () => spark.destroy()\n                    });\n                }\n            },\n            loop: true\n        });\n        (this as any).sparkTimer = sparkTimer;\n        \n        // Explosive core visualization\n        const bombCore = context.scene.add.circle(x, y - 30, 8, 0xFF4500);\n        bombCore.setDepth(1001);\n        this.visualElements.push(bombCore);\n        \n        // Pulsing core\n        context.scene.tweens.add({\n            targets: bombCore,\n            scale: { from: 0.8, to: 1.3 },\n            alpha: { from: 1, to: 0.6 },\n            duration: 400,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Text with better styling\n        const bombText = context.scene.add.text(x, y - 60, 'BOMB ARMED', {\n            fontSize: '14px',\n            fontFamily: 'Arial Black',\n            color: '#FFFFFF',\n            stroke: '#FF4500',\n            strokeThickness: 4,\n            shadow: {\n                offsetX: 2,\n                offsetY: 2,\n                color: '#000000',\n                blur: 4,\n                fill: true\n            }\n        });\n        bombText.setOrigin(0.5);\n        bombText.setDepth(1002);\n        this.visualElements.push(bombText);\n        \n        // Flash effect\n        context.scene.tweens.add({\n            targets: bombText,\n            alpha: { from: 0, to: 1 },\n            scale: { from: 1.5, to: 1 },\n            duration: 300,\n            ease: 'Back.easeOut'\n        });\n        \n        // Store timer for cleanup\n        (this as any).glowTimer = glowTimer;\n    }\n    \n    private prepareBallistic(context: PowerUpContext): void {\n        // Set launcher to ballistic mode\n        // context.launcher.setData('ballisticMode', true);\n        \n        if (context.opponentLauncher) {\n            // context.launcher.setData('ballisticTarget', {\n            //     x: context.opponentLauncher.x,\n            //     y: context.opponentLauncher.y\n            // });\n        }\n    }\n    \n    // Removed unused method - visual feedback handled differently\n    \n    private explodeAt(x: number, y: number, context: PowerUpContext): void {\n        const radius = 120;\n        \n        // AAA Explosion Effects\n        // 1. Shockwave ring\n        const shockwave = context.scene.add.graphics();\n        shockwave.setDepth(Z_LAYERS.BUBBLES_FRONT - 1);\n        \n        let shockRadius = 0;\n        const shockTimer = context.scene.time.addEvent({\n            delay: 20,\n            callback: () => {\n                shockwave.clear();\n                if (shockRadius < radius * 2) {\n                    const alpha = Math.max(0, 1 - shockRadius / (radius * 2));\n                    shockwave.lineStyle(4, 0xFFFFFF, alpha);\n                    shockwave.strokeCircle(x, y, shockRadius);\n                    shockwave.lineStyle(8, 0xFF4500, alpha * 0.5);\n                    shockwave.strokeCircle(x, y, shockRadius * 0.9);\n                    shockRadius += 8;\n                } else {\n                    shockTimer.destroy();\n                    shockwave.destroy();\n                }\n            },\n            loop: true\n        });\n        \n        // 2. Core flash\n        const flash = context.scene.add.circle(x, y, radius * 0.3, 0xFFFFFF, 1);\n        flash.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        flash.setBlendMode(Phaser.BlendModes.ADD);\n        \n        context.scene.tweens.add({\n            targets: flash,\n            scale: { from: 0, to: 4 },\n            alpha: { from: 1, to: 0 },\n            duration: 300,\n            ease: 'Expo.easeOut',\n            onComplete: () => flash.destroy()\n        });\n        \n        // 3. Fire burst effect with circles\n        const explosionContainer = context.scene.add.container(x, y);\n        explosionContainer.setDepth(Z_LAYERS.BUBBLES_FRONT + 1);\n        \n        // Create explosion particles\n        for (let i = 0; i < 30; i++) {\n            const particle = context.scene.add.circle(\n                0, 0,\n                Phaser.Math.Between(3, 6),\n                Phaser.Math.RND.pick([0xFFFFFF, 0xFF4500, 0xFF6500, 0xFFAA00])\n            );\n            particle.setBlendMode(Phaser.BlendModes.ADD);\n            explosionContainer.add(particle);\n            \n            const angle = Phaser.Math.Between(0, 360) * Math.PI / 180;\n            const speed = Phaser.Math.Between(200, 400);\n            const vx = Math.cos(angle) * speed;\n            const vy = Math.sin(angle) * speed;\n            \n            context.scene.tweens.add({\n                targets: particle,\n                x: vx * 0.8,\n                y: vy * 0.8,\n                scale: { from: 1, to: 0 },\n                alpha: { from: 1, to: 0 },\n                duration: 800,\n                ease: 'Power3',\n                onComplete: () => particle.destroy()\n            });\n        }\n        \n        // 4. Debris effect\n        const debrisContainer = context.scene.add.container(x, y);\n        debrisContainer.setDepth(Z_LAYERS.BUBBLES_FRONT);\n        \n        for (let i = 0; i < 15; i++) {\n            const debris = context.scene.add.rectangle(\n                0, 0,\n                Phaser.Math.Between(4, 8),\n                Phaser.Math.Between(4, 8),\n                Phaser.Math.RND.pick([0xFF4500, 0xFF6500, 0xFFAA00])\n            );\n            debrisContainer.add(debris);\n            \n            const angle = Phaser.Math.Between(-120, -60) * Math.PI / 180;\n            const speed = Phaser.Math.Between(100, 300);\n            const vx = Math.cos(angle) * speed;\n            const vy = Math.sin(angle) * speed;\n            \n            context.scene.tweens.add({\n                targets: debris,\n                x: debris.x + vx,\n                y: debris.y + vy + 400, // Gravity effect\n                scale: { from: 0.3, to: 0.1 },\n                angle: Phaser.Math.Between(0, 360),\n                duration: 1200,\n                ease: 'Quad.easeIn',\n                onComplete: () => debris.destroy()\n            });\n        }\n        \n        // 5. Smoke effect\n        const smokeContainer = context.scene.add.container(x, y);\n        smokeContainer.setDepth(Z_LAYERS.BUBBLES_FRONT - 2);\n        \n        for (let i = 0; i < 8; i++) {\n            const smoke = context.scene.add.circle(\n                Phaser.Math.Between(-10, 10),\n                Phaser.Math.Between(-10, 10),\n                Phaser.Math.Between(20, 30),\n                0x666666\n            );\n            smoke.setAlpha(0.4);\n            smokeContainer.add(smoke);\n            \n            context.scene.tweens.add({\n                targets: smoke,\n                scale: { from: 1, to: 2 },\n                alpha: 0,\n                y: smoke.y - Phaser.Math.Between(20, 50),\n                duration: 1500,\n                ease: 'Sine.easeOut',\n                onComplete: () => smoke.destroy()\n            });\n        }\n        \n        // Enhanced camera effects\n        context.scene.cameras.main.shake(300, 0.02);\n        context.scene.cameras.main.flash(100, 255, 100, 0, true);\n        \n        // Clean up containers\n        context.scene.time.delayedCall(2000, () => {\n            explosionContainer.destroy();\n            debrisContainer.destroy();\n            smokeContainer.destroy();\n        });\n        \n        // Destroy bubbles with chain reaction\n        const bubbles = context.bubbleGrid.getBubblesInRadius(x, y, radius);\n        bubbles.forEach((bubble, index) => {\n            const dist = Phaser.Math.Distance.Between(x, y, bubble.x, bubble.y);\n            const delay = (dist / radius) * 200;\n            \n            context.scene.time.delayedCall(delay, () => {\n                if (bubble && bubble.visible) {\n                    // Mini explosion per bubble\n                    const miniFlash = context.scene.add.circle(bubble.x, bubble.y, 15, 0xFF6500, 0.8);\n                    miniFlash.setDepth(Z_LAYERS.BUBBLES_FRONT);\n                    context.scene.tweens.add({\n                        targets: miniFlash,\n                        scale: { from: 0, to: 1.5 },\n                        alpha: 0,\n                        duration: 200,\n                        ease: 'Cubic.easeOut',\n                        onComplete: () => miniFlash.destroy()\n                    });\n                    \n                    bubble.destroy();\n                }\n            });\n        });\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        // Clean up timers if they exist\n        if ((this as any).glowTimer) {\n            (this as any).glowTimer.destroy();\n            (this as any).glowTimer = null;\n        }\n        if ((this as any).sparkTimer) {\n            (this as any).sparkTimer.destroy();\n            (this as any).sparkTimer = null;\n        }\n        \n        // Clean up visual elements\n        this.visualElements.forEach(element => {\n            if (element && element.destroy) {\n                element.destroy();\n            }\n        });\n        this.visualElements = [];\n        \n        // Reset aiming mode\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Lightning Power-Up: Click to destroy bubble\n */\nexport class LightningEffect implements IPowerUpEffect {\n    type = PowerUpType.LIGHTNING;\n    private selectionHandler?: Function;\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set selection cursor mode\n        context.aimingMode.setMode(AimingMode.LIGHTNING, this.type);\n        \n        // Visual feedback\n        const lightningText = context.scene.add.text(\n            context.scene.cameras.main.centerX,\n            context.scene.cameras.main.centerY,\n            '⚡ LIGHTNING STRIKE!',\n            {\n                fontSize: '28px',\n                fontFamily: 'Arial Black',\n                color: '#FFFF00',\n                stroke: '#000000',\n                strokeThickness: 3\n            }\n        );\n        lightningText.setOrigin(0.5);\n        lightningText.setDepth(1000);\n        \n        // Animate text\n        context.scene.tweens.add({\n            targets: lightningText,\n            scale: { from: 0, to: 1.2 },\n            alpha: { from: 1, to: 0 },\n            y: lightningText.y - 50,\n            duration: 1500,\n            ease: 'Power2',\n            onComplete: () => lightningText.destroy()\n        });\n        \n        // For now, just show the effect, actual bubble selection will be implemented later\n        context.shotsRemaining = 1;\n    }\n    \n    private destroyWithLightning(bubble: Bubble, context: PowerUpContext): void {\n        // Lightning strike visual\n        const lightning = context.scene.add.graphics();\n        lightning.setDepth(Z_LAYERS.BUBBLES_FRONT + 10);\n        \n        // Draw lightning bolt from top\n        lightning.lineStyle(4, 0xFFFF00, 1);\n        lightning.beginPath();\n        \n        const startY = 0;\n        const segments = 5;\n        let currentX = bubble.x;\n        let currentY = startY;\n        \n        for (let i = 0; i < segments; i++) {\n            const nextX = bubble.x + Phaser.Math.Between(-30, 30);\n            const nextY = startY + ((bubble.y - startY) / segments) * (i + 1);\n            \n            lightning.moveTo(currentX, currentY);\n            lightning.lineTo(nextX, nextY);\n            \n            currentX = nextX;\n            currentY = nextY;\n        }\n        \n        lightning.lineTo(bubble.x, bubble.y);\n        lightning.strokePath();\n        \n        // Flash effect\n        context.scene.cameras.main.flash(100, 255, 255, 0);\n        \n        // Destroy bubble\n        bubble.destroy();\n        \n        // Clean up lightning after animation\n        context.scene.tweens.add({\n            targets: lightning,\n            alpha: 0,\n            duration: 200,\n            onComplete: () => lightning.destroy()\n        });\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        if (this.selectionHandler) {\n            context.scene.input.off('pointerdown', this.selectionHandler as any);\n        }\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Freeze Power-Up: Stop bubble physics\n */\nexport class FreezeEffect implements IPowerUpEffect {\n    type = PowerUpType.FREEZE;\n    private frozenBubbles: Bubble[] = [];\n    private frostOverlay?: Phaser.GameObjects.Graphics;\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set freeze aiming mode\n        context.aimingMode.setMode(AimingMode.FREEZE, this.type);\n        \n        // Freeze all physics (if physics exists)\n        if (context.scene.physics && context.scene.physics.pause) {\n            context.scene.physics.pause();\n        }\n        \n        // Create frost overlay\n        this.createFrostOverlay(context);\n        \n        // Store frozen bubbles (empty for now, will be implemented later)\n        this.frozenBubbles = [];\n        \n        // Visual feedback for freeze effect\n        const freezeText = context.scene.add.text(\n            context.scene.cameras.main.centerX,\n            context.scene.cameras.main.centerY,\n            'TIME FROZEN!',\n            {\n                fontSize: '32px',\n                fontFamily: 'Arial Black',\n                color: '#00FFFF',\n                stroke: '#003366',\n                strokeThickness: 4\n            }\n        );\n        freezeText.setOrigin(0.5);\n        freezeText.setDepth(1000);\n        \n        // Animate and remove text\n        context.scene.tweens.add({\n            targets: freezeText,\n            scale: { from: 0, to: 1.5 },\n            alpha: { from: 1, to: 0 },\n            duration: 2000,\n            ease: 'Power2',\n            onComplete: () => freezeText.destroy()\n        });\n        \n        // Auto-deactivate after 5 seconds\n        context.scene.time.delayedCall(5000, () => {\n            this.deactivate(context);\n        });\n    }\n    \n    private createFrostOverlay(context: PowerUpContext): void {\n        this.frostOverlay = context.scene.add.graphics();\n        this.frostOverlay.setDepth(Z_LAYERS.UI - 1);\n        \n        // Semi-transparent blue overlay\n        this.frostOverlay.fillStyle(0x87CEEB, 0.2);\n        this.frostOverlay.fillRect(\n            0, 0,\n            context.scene.cameras.main.width,\n            context.scene.cameras.main.height\n        );\n        \n        // Add snowflake particles\n        for (let i = 0; i < 20; i++) {\n            const snowflake = context.scene.add.text(\n                Phaser.Math.Between(0, context.scene.cameras.main.width),\n                Phaser.Math.Between(0, context.scene.cameras.main.height),\n                '❄️',\n                { fontSize: '20px' }\n            );\n            snowflake.setDepth(Z_LAYERS.UI);\n            \n            context.scene.tweens.add({\n                targets: snowflake,\n                y: snowflake.y + 100,\n                alpha: { from: 1, to: 0 },\n                duration: 3000,\n                repeat: -1,\n                delay: i * 150\n            });\n            \n            // Store for cleanup\n            // this.frostOverlay.setData(`snowflake_${i}`, snowflake);\n        }\n    }\n    \n    deactivate(context: PowerUpContext): void {\n        // Resume physics\n        if (context.scene.physics && context.scene.physics.resume) {\n            context.scene.physics.resume();\n        }\n        \n        // Remove tint from bubbles\n        this.frozenBubbles.forEach(bubble => {\n            if (bubble && bubble.scene) {\n                bubble.clearTint();\n            }\n        });\n        \n        // Clean up overlay\n        if (this.frostOverlay) {\n            // Clean up snowflakes\n            for (let i = 0; i < 20; i++) {\n                const snowflake = this.frostOverlay.getData(`snowflake_${i}`);\n                if (snowflake) {\n                    snowflake.destroy();\n                }\n            }\n            this.frostOverlay.destroy();\n        }\n        \n        // Reset aiming\n        context.aimingMode.setMode(AimingMode.NORMAL);\n    }\n}\n\n/**\n * Multi-Shot Power-Up: Shoot 3 bubbles in spread\n */\nexport class MultiShotEffect implements IPowerUpEffect {\n    type = PowerUpType.MULTIPLIER; // Using as placeholder for MULTI_SHOT\n    private visualElements: any[] = [];\n    \n    activate(context: PowerUpContext): void {\n        // Set multi-shot aiming mode\n        context.aimingMode.setMode(AimingMode.MULTI, this.type);\n        \n        // Visual feedback\n        const multiText = context.scene.add.text(\n            context.scene.cameras.main.centerX,\n            context.scene.cameras.main.centerY,\n            '✨ MULTI-SHOT!',\n            {\n                fontSize: '28px',\n                fontFamily: 'Arial Black',\n                color: '#FFD700',\n                stroke: '#000000',\n                strokeThickness: 3\n            }\n        );\n        multiText.setOrigin(0.5);\n        multiText.setDepth(1000);\n        \n        // Animate text\n        context.scene.tweens.add({\n            targets: multiText,\n            scale: { from: 0, to: 1.2 },\n            alpha: { from: 1, to: 0 },\n            y: multiText.y - 50,\n            duration: 1500,\n            ease: 'Power2',\n            onComplete: () => multiText.destroy()\n        });\n        \n        context.shotsRemaining = 1;\n    }\n    \n    deactivate?(context: PowerUpContext): void {\n        // Reset aiming mode\n        if (context.aimingMode) {\n            context.aimingMode.setMode(AimingMode.NORMAL);\n        }\n    }\n}\n\n/**\n * Factory for creating power-up effects\n */\nexport class PowerUpEffectFactory {\n    private effects: Map<PowerUpType, IPowerUpEffect> = new Map();\n    \n    constructor() {\n        // Register all effects\n        this.registerEffect(new RainbowEffect());\n        this.registerEffect(new LaserSightEffect());\n        this.registerEffect(new BombEffect());\n        this.registerEffect(new LightningEffect());\n        this.registerEffect(new FreezeEffect());\n        this.registerEffect(new MultiShotEffect());\n    }\n    \n    private registerEffect(effect: IPowerUpEffect): void {\n        this.effects.set(effect.type, effect);\n    }\n    \n    public getEffect(type: PowerUpType): IPowerUpEffect | undefined {\n        return this.effects.get(type);\n    }\n    \n    public getAllEffects(): IPowerUpEffect[] {\n        return Array.from(this.effects.values());\n    }\n}","import { Scene } from 'phaser';\nimport { PowerUpType } from './PowerUpManager';\nimport { \n    PowerUpContext, \n    RainbowEffect, \n    LaserSightEffect, \n    BombEffect, \n    LightningEffect, \n    FreezeEffect, \n    MultiShotEffect,\n    IPowerUpEffect \n} from './PowerUpEffectsLibrary';\nimport { AimingModeSystem, AimingMode } from './AimingModeSystem';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { BubbleGrid } from '@/systems/gameplay/BubbleGrid';\n\nexport class PowerUpActivationSystem {\n    private scene: Scene;\n    private effects: Map<PowerUpType, IPowerUpEffect>;\n    private activeEffect?: IPowerUpEffect;\n    private context: PowerUpContext;\n    \n    constructor(\n        scene: Scene, \n        launcher: Launcher, \n        bubbleGrid: BubbleGrid,\n        aimingModeSystem: AimingModeSystem\n    ) {\n        this.scene = scene;\n        \n        // Initialize context\n        this.context = {\n            scene,\n            launcher,\n            aimingMode: aimingModeSystem,\n            bubbleGrid\n        };\n        \n        // Initialize effects\n        this.effects = new Map([\n            [PowerUpType.RAINBOW, new RainbowEffect()],\n            [PowerUpType.LASER, new LaserSightEffect()],\n            [PowerUpType.BOMB, new BombEffect()],\n            [PowerUpType.LIGHTNING, new LightningEffect()],\n            [PowerUpType.FREEZE, new FreezeEffect()],\n            [PowerUpType.MULTIPLIER, new MultiShotEffect()]\n        ]);\n        \n        this.setupEventListeners();\n    }\n    \n    private setupEventListeners(): void {\n        // Listen for power-up activation from inventory\n        this.scene.events.on('activate-power-up', (data: { type: PowerUpType }) => {\n            this.activatePowerUp(data.type);\n        });\n    }\n    \n    public activatePowerUp(type: PowerUpType): void {\n        // Deactivate current effect if any\n        if (this.activeEffect && this.activeEffect.deactivate) {\n            this.activeEffect.deactivate(this.context);\n        }\n        \n        // Reset aiming mode to normal first\n        this.context.aimingMode.setMode(AimingMode.NORMAL);\n        \n        // Get the effect\n        const effect = this.effects.get(type);\n        if (!effect) {\n            console.warn(`Power-up effect not found for type: ${type}`);\n            return;\n        }\n        \n        // Activate the new effect\n        console.log(`Activating power-up effect: ${type}`);\n        this.activeEffect = effect;\n        effect.activate(this.context);\n        \n        // Emit power-up activation event for sound system\n        this.scene.events.emit('power-up-activated', { type });\n        \n        // Visual feedback\n        this.showActivationFeedback(type);\n    }\n    \n    private showActivationFeedback(type: PowerUpType): void {\n        // Create activation text\n        const powerUpNames: Record<PowerUpType, string> = {\n            [PowerUpType.RAINBOW]: 'RAINBOW MODE!',\n            [PowerUpType.LASER]: 'LASER SIGHT!',\n            [PowerUpType.BOMB]: 'BOMB READY!',\n            [PowerUpType.LIGHTNING]: 'LIGHTNING STRIKE!',\n            [PowerUpType.FREEZE]: 'FREEZE TIME!',\n            [PowerUpType.MULTIPLIER]: 'MULTI-SHOT!',\n            [PowerUpType.SHIELD]: 'SHIELD UP!',\n            [PowerUpType.MAGNET]: 'MAGNET ON!'\n        };\n        \n        const text = this.scene.add.text(\n            this.scene.cameras.main.centerX,\n            this.scene.cameras.main.centerY - 100,\n            powerUpNames[type] || 'POWER-UP!',\n            {\n                fontSize: '32px',\n                fontFamily: 'Arial Black',\n                color: '#FFD700',\n                stroke: '#000000',\n                strokeThickness: 4\n            }\n        );\n        text.setOrigin(0.5);\n        text.setDepth(1000);\n        \n        // Animate\n        this.scene.tweens.add({\n            targets: text,\n            scale: { from: 0, to: 1.2 },\n            alpha: { from: 1, to: 0 },\n            y: text.y - 50,\n            duration: 1500,\n            ease: 'Power2',\n            onComplete: () => {\n                text.destroy();\n            }\n        });\n        \n        // Screen flash effect\n        this.scene.cameras.main.flash(250, 255, 215, 0);\n    }\n    \n    public update(delta: number): void {\n        // Update active effect if it has an update method\n        if (this.activeEffect && this.activeEffect.update) {\n            this.activeEffect.update(this.context, delta);\n        }\n    }\n    \n    public destroy(): void {\n        // Clean up\n        if (this.activeEffect && this.activeEffect.deactivate) {\n            this.activeEffect.deactivate(this.context);\n        }\n        this.effects.clear();\n    }\n}","import { Scene } from 'phaser';\nimport { BubbleColor } from '@/types/ArenaTypes';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\n\n/**\n * Configuration interface for paint splatter system\n */\ninterface IPaintSplatterConfig {\n    // Droplet settings\n    minDropletSize: number;\n    maxDropletSize: number;\n    minDroplets: number;\n    maxDroplets: number;\n    minSpread: number;\n    maxSpread: number;\n    \n    // Timing\n    fadeStartDelay: number;\n    fadeDuration: number;\n    \n    // Visual\n    initialAlpha: number;\n    colorVariation: number;\n    \n    // Performance\n    maxSplatters: number;\n    cleanupBatchSize: number;\n    \n    // Scaling\n    scaleWithCombo: boolean;\n    comboScaleFactor: number;\n    maxComboScale: number;\n}\n\n/**\n * Professional paint splatter visual effect system\n * Creates realistic paint splatters when bubbles explode\n * Fully scalable and configurable\n */\nexport class PaintSplatterSystem {\n    private scene: Scene;\n    private splatters: Phaser.GameObjects.Graphics[] = [];\n    private config: IPaintSplatterConfig;\n    \n    // Default configuration - easily adjustable\n    private static readonly DEFAULT_CONFIG: IPaintSplatterConfig = {\n        // Balanced, natural splatters\n        minDropletSize: 1.5,\n        maxDropletSize: 4,\n        minDroplets: 3,\n        maxDroplets: 7,\n        minSpread: 10,\n        maxSpread: 28,\n        \n        // Quick persistence (1.5 seconds before fade, 1 second fade)\n        fadeStartDelay: 1500,\n        fadeDuration: 1000,\n        \n        // Balanced visual settings\n        initialAlpha: 0.45,  // Balanced transparency\n        colorVariation: 0.12,  // Slight color variation\n        \n        // Performance limits\n        maxSplatters: 120,\n        cleanupBatchSize: 20,\n        \n        // Balanced scaling with combo\n        scaleWithCombo: true,\n        comboScaleFactor: 0.2, // 20% more droplets per combo level\n        maxComboScale: 1.8 // Max 1.8x droplets at high combos\n    };\n    \n    constructor(scene: Scene, config?: Partial<IPaintSplatterConfig>) {\n        this.scene = scene;\n        this.config = { ...PaintSplatterSystem.DEFAULT_CONFIG, ...config };\n        this.setupEventListeners();\n    }\n    \n    /**\n     * Update configuration at runtime\n     */\n    public updateConfig(config: Partial<IPaintSplatterConfig>): void {\n        this.config = { ...this.config, ...config };\n    }\n    \n    /**\n     * Get current configuration\n     */\n    public getConfig(): IPaintSplatterConfig {\n        return { ...this.config };\n    }\n    \n    private setupEventListeners(): void {\n        // Listen for the actual bubble explosion event\n        this.scene.events.on('bubble-exploded', this.handleBubbleExplosion, this);\n    }\n    \n    private handleBubbleExplosion(data: {\n        x: number;\n        y: number;\n        positions?: { x: number, y: number }[];\n        color: BubbleColor;\n        comboMultiplier?: number;\n    }): void {\n        // If we have individual positions, create splatters at each bubble\n        if (data.positions && data.positions.length > 0) {\n            // Calculate droplets per bubble based on total match size\n            const dropletsPerBubble = this.calculateDropletsPerBubble(data.comboMultiplier || 1, data.positions.length);\n            \n            // Create splatters at each bubble position\n            data.positions.forEach(pos => {\n                this.createSplatterAtPosition(pos.x, pos.y, data.color, dropletsPerBubble);\n            });\n        } else {\n            // Fallback to center position for compatibility\n            this.createSplatter(data.x, data.y, data.color, data.comboMultiplier || 1);\n        }\n    }\n    \n    private calculateDropletsPerBubble(matchSize: number, bubbleCount: number): number {\n        // Calculate total droplets for the match size\n        let totalDroplets: number;\n        \n        if (matchSize <= 3) {\n            totalDroplets = Phaser.Math.Between(5, 6);\n        } else if (matchSize === 4) {\n            totalDroplets = Phaser.Math.Between(8, 10);\n        } else if (matchSize === 5) {\n            totalDroplets = Phaser.Math.Between(12, 14);\n        } else if (matchSize === 6) {\n            totalDroplets = Phaser.Math.Between(16, 18);\n        } else {\n            totalDroplets = Phaser.Math.Between(20, 24);\n        }\n        \n        // Distribute droplets across all bubbles\n        // Each bubble gets at least 1-2 droplets, with some getting more\n        const baseDroplets = Math.max(1, Math.floor(totalDroplets / bubbleCount));\n        const extraDroplets = totalDroplets % bubbleCount;\n        \n        // Return base amount plus possible extra\n        return baseDroplets + (Math.random() < extraDroplets / bubbleCount ? 1 : 0);\n    }\n    \n    private createSplatterAtPosition(x: number, y: number, color: BubbleColor, dropletCount: number): void {\n        // Validate position\n        if (!this.isValidPosition(x, y)) {\n            return;\n        }\n        \n        // Create specified number of droplets at this position\n        for (let i = 0; i < dropletCount; i++) {\n            this.createDroplet(x, y, color, 1);\n        }\n    }\n    \n    private createSplatter(x: number, y: number, color: BubbleColor, multiplier: number): void {\n        // Validate position\n        if (!this.isValidPosition(x, y)) {\n            return;\n        }\n        \n        // Clean up old splatters if we have too many\n        if (this.splatters.length > this.config.maxSplatters) {\n            const toRemove = this.splatters.splice(0, this.config.cleanupBatchSize);\n            toRemove.forEach(g => {\n                this.scene.tweens.killTweensOf(g);\n                g.destroy();\n            });\n        }\n        \n        // Calculate droplet count based on match size (multiplier)\n        // Ensure larger matches ALWAYS create more droplets\n        let dropletCount: number;\n        \n        if (multiplier <= 3) {\n            // Small match (3): 5-6 droplets\n            dropletCount = Phaser.Math.Between(5, 6);\n        } else if (multiplier === 4) {\n            // Medium match (4): 8-10 droplets\n            dropletCount = Phaser.Math.Between(8, 10);\n        } else if (multiplier === 5) {\n            // Large match (5): 12-14 droplets\n            dropletCount = Phaser.Math.Between(12, 14);\n        } else if (multiplier === 6) {\n            // Huge match (6): 16-18 droplets\n            dropletCount = Phaser.Math.Between(16, 18);\n        } else {\n            // Epic match (7+): 20-24 droplets\n            dropletCount = Phaser.Math.Between(20, 24);\n        }\n        \n        // Apply configuration limits (allow up to 3x the config for epic combos)\n        dropletCount = Math.min(dropletCount, this.config.maxDroplets * 3);\n        \n        // Create droplets\n        for (let i = 0; i < dropletCount; i++) {\n            this.createDroplet(x, y, color, multiplier);\n        }\n    }\n    \n    private createDroplet(centerX: number, centerY: number, color: BubbleColor, multiplier: number): void {\n        // Random position around center\n        const angle = Math.random() * Math.PI * 2;\n        \n        // Slightly larger spread for bigger combos\n        const spreadMultiplier = this.config.scaleWithCombo ? \n            Math.min(1 + (multiplier - 1) * 0.1, 1.5) : 1;\n            \n        const distance = Phaser.Math.Between(\n            this.config.minSpread * spreadMultiplier,\n            this.config.maxSpread * spreadMultiplier\n        );\n        \n        const dropletX = centerX + Math.cos(angle) * distance;\n        const dropletY = centerY + Math.sin(angle) * distance;\n        \n        // Validate droplet position\n        if (!this.isValidPosition(dropletX, dropletY)) {\n            return;\n        }\n        \n        // Create graphics object for this droplet\n        const graphics = this.scene.add.graphics();\n        \n        // Random droplet size (slightly larger for big combos)\n        const sizeMultiplier = this.config.scaleWithCombo && multiplier > 3 ? \n            1 + (multiplier - 3) * 0.05 : 1;\n            \n        const size = Phaser.Math.FloatBetween(\n            this.config.minDropletSize * sizeMultiplier,\n            this.config.maxDropletSize * sizeMultiplier\n        );\n        \n        // Apply color with slight variation\n        const variedColor = this.applyColorVariation(color);\n        \n        // Set depth behind bubbles\n        graphics.setDepth(Z_LAYERS.BACKGROUND + 1);\n        graphics.setAlpha(this.config.initialAlpha);\n        \n        // Draw the droplet at its position\n        graphics.fillStyle(variedColor, 1);\n        \n        // Random shape with weighted probabilities\n        const shapeType = Math.random();\n        if (shapeType < 0.4) {\n            // 40% - Simple circle (most common)\n            graphics.fillCircle(dropletX, dropletY, size);\n        } else if (shapeType < 0.7) {\n            // 30% - Ellipse (stretched droplet)\n            const rotation = Math.random() * Math.PI;\n            graphics.save();\n            graphics.translateCanvas(dropletX, dropletY);\n            graphics.rotateCanvas(rotation);\n            graphics.fillEllipse(0, 0, size * 1.5, size * 0.6);\n            graphics.restore();\n        } else if (shapeType < 0.9) {\n            // 20% - Teardrop shape\n            graphics.save();\n            graphics.translateCanvas(dropletX, dropletY);\n            graphics.rotateCanvas(angle); // Point away from center\n            graphics.beginPath();\n            graphics.arc(0, 0, size, 0, Math.PI * 2);\n            graphics.lineTo(size * 1.5, 0);\n            graphics.closePath();\n            graphics.fillPath();\n            graphics.restore();\n        } else {\n            // 10% - Irregular splat (rare, more complex)\n            graphics.beginPath();\n            graphics.moveTo(dropletX, dropletY);\n            const points = Phaser.Math.Between(4, 7);\n            for (let j = 0; j < points; j++) {\n                const pointAngle = (j / points) * Math.PI * 2;\n                const pointDist = size * (0.6 + Math.random() * 0.8);\n                const px = dropletX + Math.cos(pointAngle) * pointDist;\n                const py = dropletY + Math.sin(pointAngle) * pointDist;\n                if (j === 0) {\n                    graphics.moveTo(px, py);\n                } else {\n                    graphics.lineTo(px, py);\n                }\n            }\n            graphics.closePath();\n            graphics.fillPath();\n        }\n        \n        // Remove animation for subtlety - splatters just appear naturally\n        \n        // Add to tracking array\n        this.splatters.push(graphics);\n        \n        // PERFORMANCE: Aggressive cleanup to prevent memory issues\n        // Start cleanup earlier when approaching limit\n        if (this.splatters.length > this.config.maxSplatters * 0.7) {\n            // Remove oldest splatters more aggressively\n            const toRemove = Math.min(5, this.splatters.length - this.config.maxSplatters * 0.5);\n            for (let i = 0; i < toRemove; i++) {\n                const oldSplatter = this.splatters.shift();\n                if (oldSplatter) {\n                    this.scene.tweens.killTweensOf(oldSplatter);\n                    oldSplatter.destroy();\n                }\n            }\n        }\n        \n        // Schedule fade out with configured timing\n        this.scene.time.delayedCall(\n            this.config.fadeStartDelay,\n            () => {\n                this.scene.tweens.add({\n                    targets: graphics,\n                    alpha: 0,\n                    duration: this.config.fadeDuration,\n                    ease: 'Power2',\n                    onComplete: () => {\n                        const index = this.splatters.indexOf(graphics);\n                        if (index > -1) {\n                            this.splatters.splice(index, 1);\n                        }\n                        graphics.destroy();\n                    }\n                });\n            }\n        );\n    }\n    \n    private applyColorVariation(color: BubbleColor): number {\n        const r = (color >> 16) & 0xff;\n        const g = (color >> 8) & 0xff;\n        const b = color & 0xff;\n        \n        const variation = this.config.colorVariation;\n        \n        // Apply subtle darker variation (paint tends to be darker when splattered)\n        const darkness = 0.8 + Math.random() * 0.2; // 80-100% brightness for subtlety\n        \n        const newR = Math.min(255, Math.max(0, r * darkness + (Math.random() - 0.5) * 255 * variation));\n        const newG = Math.min(255, Math.max(0, g * darkness + (Math.random() - 0.5) * 255 * variation));\n        const newB = Math.min(255, Math.max(0, b * darkness + (Math.random() - 0.5) * 255 * variation));\n        \n        return (Math.floor(newR) << 16) | (Math.floor(newG) << 8) | Math.floor(newB);\n    }\n    \n    private isValidPosition(x: number, y: number): boolean {\n        const cam = this.scene.cameras.main;\n        const buffer = 50;\n        return x >= -buffer && \n               x <= cam.width + buffer && \n               y >= -buffer && \n               y <= cam.height + buffer &&\n               !isNaN(x) && !isNaN(y) &&\n               isFinite(x) && isFinite(y);\n    }\n    \n    /**\n     * Get current splatter count\n     */\n    public getSplatterCount(): number {\n        return this.splatters.length;\n    }\n    \n    /**\n     * Clear all splatters immediately\n     */\n    public clear(): void {\n        this.splatters.forEach(graphics => {\n            this.scene.tweens.killTweensOf(graphics);\n            graphics.destroy();\n        });\n        this.splatters = [];\n    }\n    \n    /**\n     * Set quality preset for performance optimization\n     */\n    public setQualityPreset(preset: 'low' | 'medium' | 'high' | 'ultra'): void {\n        switch (preset) {\n            case 'low':\n                this.updateConfig({\n                    minDroplets: 1,\n                    maxDroplets: 2,\n                    minDropletSize: 1,\n                    maxDropletSize: 2,\n                    maxSplatters: 30,\n                    fadeStartDelay: 800,\n                    fadeDuration: 500,\n                    initialAlpha: 0.25\n                });\n                break;\n            case 'medium':\n                this.updateConfig({\n                    minDroplets: 2,\n                    maxDroplets: 4,\n                    minDropletSize: 1,\n                    maxDropletSize: 3,\n                    maxSplatters: 60,\n                    fadeStartDelay: 1200,\n                    fadeDuration: 800,\n                    initialAlpha: 0.3\n                });\n                break;\n            case 'high':\n                this.updateConfig({\n                    minDroplets: 3,\n                    maxDroplets: 8,\n                    minDropletSize: 1.5,\n                    maxDropletSize: 5,\n                    maxSplatters: 120,\n                    fadeStartDelay: 1500,\n                    fadeDuration: 1000,\n                    initialAlpha: 0.45\n                });\n                break;\n            case 'ultra':\n                this.updateConfig({\n                    minDroplets: 3,\n                    maxDroplets: 8,\n                    minDropletSize: 1,\n                    maxDropletSize: 5,\n                    maxSplatters: 150,\n                    fadeStartDelay: 2000,\n                    fadeDuration: 1200,\n                    initialAlpha: 0.4,\n                    scaleWithCombo: true,\n                    maxComboScale: 2\n                });\n                break;\n        }\n    }\n    \n    /**\n     * Destroy system and clean up resources\n     */\n    public destroy(): void {\n        this.scene.events.off('bubble-exploded', this.handleBubbleExplosion, this);\n        this.clear();\n    }\n}","import { Scene } from 'phaser';\nimport { IArenaConfig, IZoneBounds, ArenaZone, IHexPosition } from '@/types/ArenaTypes';\nimport { ARENA_CONFIG, BUBBLE_CONFIG, GRID_CONFIG, ZONE_COLORS, Z_LAYERS, DANGER_ZONE_CONFIG } from '@/config/ArenaConfig';\nimport { BubbleGrid } from './BubbleGrid';\nimport { Bubble } from '@/gameObjects/Bubble';\nimport { MysteryBubble } from '@/gameObjects/MysteryBubble';\nimport { Launcher } from '@/gameObjects/Launcher';\nimport { Objective } from '@/gameObjects/Objective';\nimport { InputManager } from '@/systems/input/InputManager';\nimport { ShootingSystem } from './ShootingSystem';\nimport { GridAttachmentSystem } from './GridAttachmentSystem';\nimport { MatchDetectionSystem } from './MatchDetectionSystem';\nimport { AIOpponentSystem, AIDifficulty } from './AIOpponentSystem';\nimport { EnhancedScoreDisplay } from '@/ui/EnhancedScoreDisplay';\nimport { ComboManager } from './ComboManager';\nimport { VictoryScreen } from '@/ui/VictoryScreen';\nimport { DefeatScreen } from '@/ui/DefeatScreen';\nimport { ScoreEventManager, ScoreEventType, ScoreContext } from '@/systems/scoring/ScoreEventManager';\nimport { UnifiedFeedbackSystem } from '@/systems/scoring/UnifiedFeedbackSystem';\nimport { PowerUpInventoryUI } from '@/ui/PowerUpInventoryUI';\nimport { PowerUpActivationSystem } from '@/systems/powerups/PowerUpActivationSystem';\nimport { AimingModeSystem } from '@/systems/powerups/AimingModeSystem';\nimport { PaintSplatterSystem } from '@/systems/visual/PaintSplatterSystem';\n\nexport { AIDifficulty };\n\nexport class ArenaSystem {\n    // Static variable to persist difficulty between restarts\n    private static currentDifficulty: AIDifficulty = AIDifficulty.HARD;\n    \n    private scene: Scene;\n    private config: IArenaConfig;\n    private bubbleGrid: BubbleGrid;\n    private objective!: Objective;\n    private playerLauncher!: Launcher;\n    private opponentLauncher!: Launcher;\n    private bubbles: Bubble[] = [];\n    private bubblePool: Bubble[] = [];\n    private zones: Map<ArenaZone, IZoneBounds> = new Map();\n    private debugGraphics?: Phaser.GameObjects.Graphics;\n    private debugEnabled: boolean = false;\n    private inputManager: InputManager;\n    private shootingSystem?: ShootingSystem;\n    private gridAttachmentSystem: GridAttachmentSystem;\n    private matchDetectionSystem: MatchDetectionSystem;\n    private aiOpponent?: AIOpponentSystem;\n    private isSinglePlayer: boolean = true;\n    private enhancedScoreDisplay?: EnhancedScoreDisplay;\n    private comboManager?: ComboManager;\n    private scoreEventManager?: ScoreEventManager;\n    private unifiedFeedbackSystem?: UnifiedFeedbackSystem;\n    private playerPowerUpInventory?: PowerUpInventoryUI;\n    private opponentPowerUpInventory?: PowerUpInventoryUI;\n    private powerUpActivation?: PowerUpActivationSystem;\n    private aimingModeSystem?: AimingModeSystem;\n    private playerScore: number = 0;\n    private aiScore: number = 0;\n    private gameOver: boolean = false;\n    private victoryScreen?: VictoryScreen;\n    private defeatScreen?: DefeatScreen;\n    private isRestarting: boolean = false;\n    private playerDangerLine?: Phaser.GameObjects.Graphics;\n    private opponentDangerLine?: Phaser.GameObjects.Graphics;\n    private dangerWarningActive: boolean = false;\n    private paintSplatterSystem?: PaintSplatterSystem;\n    private dangerCheckCounter: number = 0;\n    private readonly DANGER_CHECK_INTERVAL: number = 10;\n    \n    // Performance optimization: Cache objective shield state\n    private shieldCheckCounter: number = 0;\n    private readonly SHIELD_CHECK_INTERVAL: number = 15; // Check every 15 frames (~4 times per second at 60fps)\n    private cachedShieldState: boolean = false;\n    \n    // Performance optimization: Throttle aiming updates\n    private aimingCheckCounter: number = 0;\n    private readonly AIMING_CHECK_INTERVAL: number = 2; // Check every 2 frames for responsive aiming // Check every 10 frames instead of every frame\n    private lastAimAngle: number = 0;\n\n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.config = ARENA_CONFIG;\n        \n        // Initialize input manager\n        this.inputManager = new InputManager(scene);\n        \n        // Initialize grid at center of objective zone\n        const centerX = scene.cameras.main.centerX;\n        const centerY = scene.cameras.main.centerY;\n        this.bubbleGrid = new BubbleGrid(centerX, centerY);\n        \n        // Initialize grid attachment system\n        this.gridAttachmentSystem = new GridAttachmentSystem(scene, this.bubbleGrid);\n        \n        // Initialize match detection system\n        this.matchDetectionSystem = new MatchDetectionSystem(\n            scene,\n            this.bubbleGrid,\n            this.gridAttachmentSystem\n        );\n        \n        // Connect systems\n        this.gridAttachmentSystem.setMatchDetectionSystem(this.matchDetectionSystem);\n        \n        this.initializeZones();\n        this.createBubblePool();\n    }\n\n    private initializeZones(): void {\n        const width = this.scene.cameras.main.width;\n        const height = this.scene.cameras.main.height;\n        \n        // Player zone (bottom 40%)\n        this.zones.set(ArenaZone.PLAYER, {\n            x: 0,\n            y: height - this.config.playerZoneHeight,\n            width: width,\n            height: this.config.playerZoneHeight,\n            zone: ArenaZone.PLAYER\n        });\n        \n        // Opponent zone (top 40%)\n        this.zones.set(ArenaZone.OPPONENT, {\n            x: 0,\n            y: 0,\n            width: width,\n            height: this.config.opponentZoneHeight,\n            zone: ArenaZone.OPPONENT\n        });\n        \n        // Objective zone (middle 20%)\n        this.zones.set(ArenaZone.OBJECTIVE, {\n            x: 0,\n            y: this.config.opponentZoneHeight,\n            width: width,\n            height: this.config.objectiveZoneHeight,\n            zone: ArenaZone.OBJECTIVE\n        });\n    }\n\n    private createBubblePool(): void {\n        for (let i = 0; i < BUBBLE_CONFIG.POOL_SIZE; i++) {\n            const bubble = new Bubble(\n                this.scene,\n                -1000,\n                -1000,\n                Bubble.getRandomColor()\n            );\n            bubble.setVisible(false);\n            this.bubblePool.push(bubble);\n        }\n    }\n\n    public setupArena(singlePlayer: boolean = true, difficulty?: AIDifficulty): void {\n        this.isSinglePlayer = singlePlayer;\n        \n        // Use persisted difficulty if not specified\n        if (difficulty !== undefined) {\n            ArenaSystem.currentDifficulty = difficulty;\n        }\n        const actualDifficulty = ArenaSystem.currentDifficulty;\n        \n        this.createLaunchers();\n        this.createObjective();\n        this.createInitialBubbles();\n        this.createZoneVisuals();\n        \n        // Initialize enhanced scoring systems\n        this.enhancedScoreDisplay = new EnhancedScoreDisplay(this.scene);\n        this.comboManager = new ComboManager(this.scene);\n        \n        // Initialize new unified scoring system\n        this.scoreEventManager = new ScoreEventManager(this.scene);\n        this.unifiedFeedbackSystem = new UnifiedFeedbackSystem(this.scene);\n        \n        // Initialize visual effects systems with custom config\n        this.paintSplatterSystem = new PaintSplatterSystem(this.scene, {\n            // Quick persistence - splatters stay for 1.5 seconds, fade over 1 second\n            fadeStartDelay: 1500,\n            fadeDuration: 1000,\n            \n            // Balanced splatters - not too much, not too little\n            initialAlpha: 0.5,  // Slightly more visible\n            minDropletSize: 1.5,  // Slightly bigger minimum\n            maxDropletSize: 5,  // Slightly bigger maximum\n            \n            // Balanced droplet count\n            minDroplets: 3,\n            maxDroplets: 8,\n            \n            // Balanced spread area\n            minSpread: 10,\n            maxSpread: 30,\n            \n            // Performance tuning\n            maxSplatters: 150,\n            \n            // Balanced scaling with combos\n            scaleWithCombo: true,\n            comboScaleFactor: 0.25,  // 25% increase per combo\n            maxComboScale: 2.0  // Max 2x for huge combos\n        });\n        console.log('ArenaSystem: Paint splatter system initialized with enhanced settings');\n        \n        // Initialize power-up systems\n        // Arsenal is now integrated directly into the Launcher for both players\n        // The Launcher class handles the arsenal display internally\n        // this.playerPowerUpInventory = new PowerUpInventoryUI(this.scene, false);\n        // this.opponentPowerUpInventory = new PowerUpInventoryUI(this.scene, true);\n        this.aimingModeSystem = new AimingModeSystem(this.scene);\n        \n        // Initialize power-up activation after launcher is created\n        if (this.playerLauncher) {\n            this.powerUpActivation = new PowerUpActivationSystem(\n                this.scene,\n                this.playerLauncher,\n                this.bubbleGrid,\n                this.aimingModeSystem\n            );\n        }\n        \n        // Connect scoring systems\n        this.scoreEventManager.onScoreUpdate((score, isPlayer) => {\n            if (isPlayer) {\n                this.playerScore = score;\n                this.enhancedScoreDisplay?.updatePlayerScore(score);\n            } else {\n                this.aiScore = score;\n                this.enhancedScoreDisplay?.updateOpponentScore(score);\n            }\n        });\n        \n        this.scoreEventManager.onVisualEffect((result, position) => {\n            this.unifiedFeedbackSystem?.queueFeedback(result, position);\n        });\n        \n        this.playerScore = 0;\n        this.aiScore = 0;\n        \n        // Initialize shooting system with grid attachment\n        this.shootingSystem = new ShootingSystem(\n            this.scene,\n            this.inputManager,\n            this.playerLauncher,\n            this.gridAttachmentSystem,\n            this.bubbleGrid\n        );\n        \n        // Set opponent launcher for shooting system\n        this.shootingSystem.setOpponentLauncher(this.opponentLauncher);\n        \n        // Initialize AI opponent if single player\n        if (this.isSinglePlayer) {\n            this.aiOpponent = new AIOpponentSystem(\n                this.scene,\n                this.opponentLauncher\n            );\n            this.aiOpponent.setDifficulty(actualDifficulty);\n            \n            console.log(`ArenaSystem: AI opponent initialized with ${actualDifficulty} difficulty`);\n            \n            // Start AI after a short delay\n            this.scene.time.delayedCall(2000, () => {\n                this.aiOpponent?.start();\n                console.log('ArenaSystem: AI opponent started');\n            });\n        }\n        \n        // Listen for scoring events\n        this.scene.events.on('score-update', this.onScoreUpdate, this);\n        this.scene.events.on('bubble-attached', this.checkVictoryCondition, this);\n        this.scene.events.on('bubble-position-update', this.checkChestHit, this);\n        \n        // Enable debug with 'D' key\n        this.scene.input.keyboard?.on('keydown-D', () => {\n            this.toggleDebug();\n        });\n        \n        // Change AI difficulty with number keys\n        if (this.isSinglePlayer && this.aiOpponent) {\n            this.scene.input.keyboard?.on('keydown-ONE', () => {\n                this.changeAIDifficulty(AIDifficulty.EASY);\n            });\n            \n            this.scene.input.keyboard?.on('keydown-TWO', () => {\n                this.changeAIDifficulty(AIDifficulty.MEDIUM);\n            });\n            \n            this.scene.input.keyboard?.on('keydown-THREE', () => {\n                this.changeAIDifficulty(AIDifficulty.HARD);\n            });\n        }\n    }\n\n    private createLaunchers(): void {\n        const centerX = this.scene.cameras.main.centerX;\n        \n        // Player launcher at bottom\n        const playerZone = this.zones.get(ArenaZone.PLAYER)!;\n        this.playerLauncher = new Launcher(\n            this.scene,\n            centerX,\n            playerZone.y + playerZone.height - this.config.launcherOffset,\n            ArenaZone.PLAYER\n        );\n        \n        // Opponent launcher at top\n        const opponentZone = this.zones.get(ArenaZone.OPPONENT)!;\n        this.opponentLauncher = new Launcher(\n            this.scene,\n            centerX,\n            opponentZone.y + this.config.launcherOffset,\n            ArenaZone.OPPONENT\n        );\n    }\n\n    private createObjective(): void {\n        const centerX = this.scene.cameras.main.centerX;\n        const centerY = this.scene.cameras.main.centerY;\n        \n        this.objective = new Objective(this.scene, {\n            x: centerX,\n            y: centerY,\n            size: this.config.objectiveSize,\n            health: 1\n        });\n    }\n\n    private createInitialBubbles(): void {\n        const center: IHexPosition = { q: 0, r: 0, s: 0 };\n        \n        // Track Mystery Bubbles per side to ensure fair distribution\n        let playerSideMysteryCount = 0;\n        let opponentSideMysteryCount = 0;\n        const screenHeight = this.scene.cameras.main.height;\n        const midPoint = screenHeight / 2;\n        \n        // Collect all positions first\n        const allPositions: { hexPos: IHexPosition, pixelPos: { x: number, y: number } }[] = [];\n        \n        // Create 3 rings of bubbles around the objective\n        for (let ring = 1; ring <= GRID_CONFIG.OBJECTIVE_RADIUS; ring++) {\n            const positions = this.bubbleGrid.getRing(center, ring);\n            positions.forEach(hexPos => {\n                const pixelPos = this.bubbleGrid.hexToPixel(hexPos);\n                allPositions.push({ hexPos, pixelPos });\n            });\n        }\n        \n        // Calculate how many Mystery Bubbles we want (12.5% of total)\n        const totalBubbles = allPositions.length;\n        const targetMysteryCount = Math.floor(totalBubbles * 0.125);\n        const mysteryPerSide = Math.floor(targetMysteryCount / 2);\n        \n        // Randomly select positions for Mystery Bubbles, ensuring balance\n        const mysteryPositions = new Set<number>();\n        \n        // First, ensure each side gets its fair share\n        for (const side of ['player', 'opponent']) {\n            let sideCount = 0;\n            const maxAttempts = 100; // Prevent infinite loop\n            let attempts = 0;\n            \n            while (sideCount < mysteryPerSide && attempts < maxAttempts) {\n                const index = Math.floor(Math.random() * allPositions.length);\n                if (!mysteryPositions.has(index)) {\n                    const pos = allPositions[index];\n                    const isPlayerSide = pos.pixelPos.y > midPoint;\n                    \n                    if ((side === 'player' && isPlayerSide) || (side === 'opponent' && !isPlayerSide)) {\n                        mysteryPositions.add(index);\n                        sideCount++;\n                    }\n                }\n                attempts++;\n            }\n        }\n        \n        // Create bubbles with balanced Mystery Bubble distribution\n        allPositions.forEach((pos, index) => {\n            if (mysteryPositions.has(index)) {\n                // Create Mystery Bubble\n                const mysteryBubble = new MysteryBubble(this.scene, pos.pixelPos.x, pos.pixelPos.y);\n                mysteryBubble.setGridPosition(pos.hexPos);\n                this.bubbles.push(mysteryBubble);\n                this.gridAttachmentSystem.addGridBubble(mysteryBubble);\n                \n                // Track distribution\n                if (pos.pixelPos.y > midPoint) {\n                    playerSideMysteryCount++;\n                } else {\n                    opponentSideMysteryCount++;\n                }\n            } else {\n                // Create normal bubble\n                const bubble = this.getBubbleFromPool();\n                if (bubble) {\n                    bubble.reset(pos.pixelPos.x, pos.pixelPos.y, Bubble.getRandomColor());\n                    bubble.setGridPosition(pos.hexPos);\n                    this.bubbles.push(bubble);\n                    this.gridAttachmentSystem.addGridBubble(bubble);\n                }\n            }\n        });\n        \n        console.log(`Mystery Bubbles distributed - Player side: ${playerSideMysteryCount}, Opponent side: ${opponentSideMysteryCount}`);\n        \n        // Update objective shield status based on bubbles\n        this.updateObjectiveShield();\n    }\n\n    private getBubbleFromPool(): Bubble | null {\n        const bubble = this.bubblePool.find(b => b.isPooled() || !b.visible);\n        if (bubble) {\n            const index = this.bubblePool.indexOf(bubble);\n            if (index > -1) {\n                this.bubblePool.splice(index, 1);\n            }\n        }\n        return bubble || null;\n    }\n\n    private returnBubbleToPool(bubble: Bubble): void {\n        bubble.returnToPool();\n        this.bubblePool.push(bubble);\n        \n        const index = this.bubbles.indexOf(bubble);\n        if (index > -1) {\n            this.bubbles.splice(index, 1);\n        }\n    }\n\n    private createZoneVisuals(): void {\n        // All zone visuals removed for cleaner UI\n        // Danger zones are now only used for game logic, not visual display\n    }\n\n    private toggleDebug(): void {\n        this.debugEnabled = !this.debugEnabled;\n        \n        if (this.debugEnabled) {\n            this.showDebugOverlay();\n        } else {\n            this.hideDebugOverlay();\n        }\n    }\n\n    private showDebugOverlay(): void {\n        if (!this.debugGraphics) {\n            this.debugGraphics = this.scene.add.graphics();\n            this.debugGraphics.setDepth(Z_LAYERS.DEBUG_OVERLAY);\n        }\n        \n        this.debugGraphics.clear();\n        \n        // Draw zones with transparent colors\n        this.zones.forEach((bounds, zone) => {\n            let color = ZONE_COLORS.NEUTRAL;\n            switch (zone) {\n                case ArenaZone.PLAYER:\n                    color = ZONE_COLORS.PLAYER;\n                    break;\n                case ArenaZone.OPPONENT:\n                    color = ZONE_COLORS.OPPONENT;\n                    break;\n                case ArenaZone.OBJECTIVE:\n                    color = ZONE_COLORS.OBJECTIVE;\n                    break;\n            }\n            \n            this.debugGraphics!.fillStyle(color, ZONE_COLORS.DEBUG_ALPHA);\n            this.debugGraphics!.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);\n            \n            // Add zone labels\n            const text = this.scene.add.text(\n                bounds.x + 10,\n                bounds.y + 10,\n                zone.toUpperCase(),\n                {\n                    fontSize: '14px',\n                    color: '#ffffff',\n                    backgroundColor: '#000000'\n                }\n            );\n            text.setDepth(Z_LAYERS.DEBUG_OVERLAY + 1);\n        });\n        \n        // Draw hexagonal grid\n        this.drawHexGrid();\n        \n        // Draw bubble connections\n        if (this.gridAttachmentSystem && this.debugGraphics) {\n            this.gridAttachmentSystem.debugDrawConnections(this.debugGraphics);\n        }\n    }\n\n    private drawHexGrid(): void {\n        if (!this.debugGraphics) return;\n        \n        this.debugGraphics.lineStyle(1, 0xffffff, 0.3);\n        \n        const bounds = this.bubbleGrid.getGridBounds();\n        for (let q = bounds.minQ; q <= bounds.maxQ; q++) {\n            for (let r = bounds.minR; r <= bounds.maxR; r++) {\n                const hex: IHexPosition = { q, r, s: -q - r };\n                const pixel = this.bubbleGrid.hexToPixel(hex);\n                \n                // Draw hexagon\n                const size = BUBBLE_CONFIG.SIZE / 2;\n                const points: number[] = [];\n                for (let i = 0; i < 6; i++) {\n                    const angle = Math.PI / 3 * i;\n                    points.push(pixel.x + size * Math.cos(angle));\n                    points.push(pixel.y + size * Math.sin(angle));\n                }\n                \n                this.debugGraphics.strokePoints(points, true);\n            }\n        }\n    }\n\n    private hideDebugOverlay(): void {\n        if (this.debugGraphics) {\n            this.debugGraphics.clear();\n        }\n        \n        // Remove zone labels\n        this.scene.children.list.forEach(child => {\n            if (child instanceof Phaser.GameObjects.Text && \n                child.getData('isDebugLabel')) {\n                child.destroy();\n            }\n        });\n    }\n\n    private updateObjectiveShield(): void {\n        // Check if objective still exists (might be null after victory)\n        if (!this.objective) return;\n        \n        // OPTIMIZATION: Use spatial grid for faster neighbor checks\n        const center: IHexPosition = { q: 0, r: 0, s: 0 };\n        const neighbors = this.bubbleGrid.getNeighbors(center);\n        \n        let hasAdjacentBubbles = false;\n        \n        // Use the grid attachment system's spatial grid for O(1) lookups\n        for (const neighbor of neighbors) {\n            // Check if grid position has a bubble (much faster than iterating all bubbles)\n            const gridKey = `${neighbor.q},${neighbor.r}`;\n            if (this.gridAttachmentSystem.hasGridPosition(gridKey)) {\n                hasAdjacentBubbles = true;\n                break;\n            }\n        }\n        \n        // Only update shield if state changed (reduces unnecessary updates)\n        if (hasAdjacentBubbles !== this.cachedShieldState) {\n            this.cachedShieldState = hasAdjacentBubbles;\n            this.objective.setShielded(hasAdjacentBubbles);\n        }\n    }\n\n    public getZoneBounds(zone: ArenaZone): IZoneBounds | undefined {\n        return this.zones.get(zone);\n    }\n\n    public getBubbles(): Bubble[] {\n        return this.bubbles;\n    }\n\n    public getObjective(): Objective {\n        return this.objective;\n    }\n\n    public getPlayerLauncher(): Launcher {\n        return this.playerLauncher;\n    }\n\n    public getOpponentLauncher(): Launcher {\n        return this.opponentLauncher;\n    }\n\n    public update(time: number, delta: number): void {\n        // OPTIMIZATION: Only update input every frame if pointer is active\n        const isPointerActive = this.inputManager.isPointerActive();\n        if (isPointerActive) {\n            this.inputManager.update();\n        } else {\n            // Check input less frequently when not actively aiming\n            this.aimingCheckCounter++;\n            if (this.aimingCheckCounter >= this.AIMING_CHECK_INTERVAL * 2) {\n                this.aimingCheckCounter = 0;\n                this.inputManager.update();\n            }\n        }\n        \n        // OPTIMIZATION: Throttle launcher aiming updates\n        if (isPointerActive) {\n            // Update aiming more frequently when actively aiming\n            this.updateLauncherAiming();\n        } else {\n            // Update less frequently when idle\n            if (this.aimingCheckCounter === 0) {\n                this.updateLauncherAiming();\n            }\n        }\n        \n        // Update shooting system (already optimized internally)\n        this.shootingSystem?.update(delta);\n        \n        // Update power-up systems (only when active)\n        this.powerUpActivation?.update(delta);\n        \n        // OPTIMIZATION: Throttle objective shield checks\n        this.shieldCheckCounter++;\n        if (this.shieldCheckCounter >= this.SHIELD_CHECK_INTERVAL) {\n            this.shieldCheckCounter = 0;\n            this.updateObjectiveShield();\n        }\n        \n        // Check danger zone proximity only every N frames for performance\n        this.dangerCheckCounter++;\n        if (this.dangerCheckCounter >= this.DANGER_CHECK_INTERVAL) {\n            this.dangerCheckCounter = 0;\n            this.checkDangerZoneProximity();\n        }\n        \n        // Update unified feedback system\n        this.unifiedFeedbackSystem?.update(delta);\n    }\n    \n    private updateLauncherAiming(): void {\n        // Get angle from launcher to pointer with constraints\n        const launcherPos = {\n            x: this.playerLauncher.x,\n            y: this.playerLauncher.y\n        };\n        \n        const angle = this.inputManager.getAngleFromWithConstraints(\n            launcherPos.x,\n            launcherPos.y,\n            15,  // Min angle from vertical\n            165  // Max angle from vertical\n        );\n        \n        // Only update launcher rotation if angle has changed significantly (reduces unnecessary updates)\n        const angleDiff = Math.abs(angle - this.lastAimAngle);\n        if (angleDiff > 0.5) { // Only update if angle changed by more than 0.5 degrees\n            this.playerLauncher.setAimAngle(angle);\n            this.lastAimAngle = angle;\n        }\n        \n        // Show aiming feedback when pointer is active\n        const isAiming = this.inputManager.isPointerActive();\n        this.playerLauncher.showAiming(isAiming);\n        \n        // DEBUG: Show aim line when debug is enabled\n        if (this.debugEnabled && this.debugGraphics) {\n            this.debugGraphics.clear();\n            this.showDebugOverlay(); // Redraw grid\n            \n            // Draw aim line\n            this.debugGraphics.lineStyle(2, 0x00ff00, 0.8);\n            this.debugGraphics.beginPath();\n            this.debugGraphics.moveTo(launcherPos.x, launcherPos.y);\n            \n            // Calculate end point based on angle\n            const distance = 200;\n            const radians = Phaser.Math.DegToRad(angle - 90);\n            const endX = launcherPos.x + Math.cos(radians) * distance;\n            const endY = launcherPos.y + Math.sin(radians) * distance;\n            \n            this.debugGraphics.lineTo(endX, endY);\n            this.debugGraphics.strokePath();\n        }\n    }\n    \n    private changeAIDifficulty(difficulty: AIDifficulty): void {\n        if (!this.aiOpponent) return;\n        \n        // console.log(`=== Changing AI Difficulty to ${difficulty} ===`);\n        \n        // Update the static variable to persist difficulty\n        ArenaSystem.currentDifficulty = difficulty;\n        \n        // Stop current AI\n        this.aiOpponent.stop();\n        \n        // Change difficulty  \n        this.aiOpponent.setDifficulty(difficulty);\n        \n        // Restart AI\n        this.scene.time.delayedCall(500, () => {\n            // console.log(`=== Restarting AI with ${difficulty} ===`);\n            this.aiOpponent?.start();\n        });\n        \n        // Show minimal notification\n        this.showDifficultyNotification(difficulty);\n    }\n    \n    private showDifficultyNotification(difficulty: AIDifficulty): void {\n        // Colors for each difficulty\n        const colors = {\n            [AIDifficulty.EASY]: '#4CAF50',\n            [AIDifficulty.MEDIUM]: '#FFA726', \n            [AIDifficulty.HARD]: '#F44336'\n        };\n        \n        // Create small notification\n        const notification = this.scene.add.text(\n            this.scene.cameras.main.centerX,\n            160,\n            `AI: ${difficulty}`,\n            {\n                fontSize: '18px',\n                color: colors[difficulty],\n                fontFamily: 'Arial',\n                fontStyle: 'bold',\n                stroke: '#000000',\n                strokeThickness: 3\n            }\n        );\n        notification.setOrigin(0.5);\n        notification.setDepth(1500);\n        notification.setScale(0);\n        \n        // Animate in\n        this.scene.tweens.add({\n            targets: notification,\n            scale: 1,\n            duration: 200,\n            ease: 'Back.easeOut'\n        });\n        \n        // Fade out after short delay\n        this.scene.time.delayedCall(1200, () => {\n            this.scene.tweens.add({\n                targets: notification,\n                alpha: 0,\n                scale: 0.8,\n                duration: 300,\n                ease: 'Power2',\n                onComplete: () => {\n                    notification.destroy();\n                }\n            });\n        });\n    }\n    \n    private onScoreUpdate = (data: { score: number; delta: number; combo?: number; isAI?: boolean; matchSize?: number; x?: number; y?: number; isOrphanBonus?: boolean; bubbleColor?: number }): void => {\n        if (this.gameOver) return;\n        \n        // Use new ScoreEventManager for all scoring\n        if (this.scoreEventManager) {\n            let context: ScoreContext;\n            \n            if (data.isOrphanBonus) {\n                // Orphan drop event\n                context = {\n                    type: ScoreEventType.ORPHAN_DROP,\n                    baseValue: data.delta,\n                    position: { x: data.x || 0, y: data.y || 0 },\n                    isPlayer: !data.isAI,\n                    bubbleColor: data.bubbleColor,\n                    metadata: {\n                        dropCount: Math.floor(data.delta / 5) // Assuming 5 points per drop\n                    }\n                };\n            } else if (data.matchSize) {\n                // Bubble match event\n                context = {\n                    type: ScoreEventType.BUBBLE_MATCH,\n                    baseValue: data.delta,\n                    position: { x: data.x || 0, y: data.y || 0 },\n                    matchSize: data.matchSize,\n                    isPlayer: !data.isAI,\n                    bubbleColor: data.bubbleColor\n                };\n            } else {\n                // Generic score event\n                context = {\n                    type: ScoreEventType.SPECIAL_BONUS,\n                    baseValue: data.delta,\n                    position: { x: data.x || 0, y: data.y || 0 },\n                    isPlayer: !data.isAI,\n                    bubbleColor: data.bubbleColor\n                };\n            }\n            \n            this.scoreEventManager.queueEvent(context);\n        } else {\n            // Fallback to old system if new system not initialized\n            let finalScore = data.delta;\n            \n            if (data.isOrphanBonus) {\n                finalScore = data.delta;\n            } else if (data.matchSize && this.comboManager) {\n                finalScore = this.comboManager.calculateScore(data.matchSize, data.x, data.y, data.bubbleColor);\n            }\n            \n            if (data.isAI) {\n                this.aiScore += finalScore;\n                this.enhancedScoreDisplay?.updateOpponentScore(this.aiScore);\n            } else {\n                this.playerScore += finalScore;\n                this.enhancedScoreDisplay?.updatePlayerScore(this.playerScore);\n            }\n        }\n    }\n    \n    private checkChestHit = (bubble: Bubble): void => {\n        if (this.gameOver || !this.objective || !bubble.visible) return;\n        \n        // Check if bubble hit the chest during flight\n        const distance = Phaser.Math.Distance.Between(\n            bubble.x, bubble.y,\n            this.objective.x, this.objective.y\n        );\n        \n        // Direct hit detection - bubble must overlap with chest\n        // The chest size is this.config.objectiveSize (60) and bubble is BUBBLE_CONFIG.SIZE (30)\n        // So combined radius is (60/2 + 30/2) = 45\n        const hitRadius = (this.config.objectiveSize / 2) + (BUBBLE_CONFIG.SIZE / 2);\n        \n        if (distance < hitRadius) {\n            const shooter = bubble.getShooter();\n            const playerWins = shooter === 'player';\n            \n            // console.log(`🎯 TREASURE CHEST DIRECT HIT by ${shooter}! Distance: ${distance.toFixed(1)} < ${hitRadius}`);\n            // console.log(`INSTANT VICTORY for ${playerWins ? 'PLAYER' : 'AI'}!`);\n            \n            // Call the hit method on the objective to trigger sound and animation\n            this.objective.hit();\n            \n            // Mark game as over immediately to prevent multiple triggers\n            this.gameOver = true;\n            \n            // Stop the bubble\n            bubble.setVisible(false);\n            \n            // Store objective reference before nulling\n            const obj = this.objective;\n            this.objective = null as any;\n            \n            // Play victory animation\n            obj.playVictoryAnimation(() => {\n                this.triggerGameOver(playerWins);\n            });\n        }\n    }\n    \n    private checkVictoryCondition = (data: { bubble: Bubble; position: IHexPosition }): void => {\n        if (this.gameOver) return;\n        \n        const bubble = data.bubble;\n        \n        // Only check bubbles that are actually attached and visible\n        if (!bubble.visible || !bubble.getGridPosition()) {\n            return;\n        }\n        \n        // Check for defeat conditions (bubbles reaching danger zones)\n        const screenHeight = this.scene.cameras.main.height;\n        const playerDangerY = screenHeight - DANGER_ZONE_CONFIG.PLAYER_OFFSET;\n        const opponentDangerY = DANGER_ZONE_CONFIG.OPPONENT_OFFSET;\n        \n        // Check if any bubble crossed player's danger line (player loses)\n        if (bubble.y > playerDangerY) {\n            // console.log('💀 Bubble crossed PLAYER danger line! Player loses!');\n            // console.log(`Bubble Y: ${bubble.y}, Danger Line: ${playerDangerY}`);\n            this.triggerGameOver(false); // Player loses\n            return;\n        }\n        \n        // Check if any bubble crossed opponent's danger line (opponent loses, player wins)\n        // Only check for real grid positions, not falling bubbles\n        if (bubble.y < opponentDangerY) {\n            // Verify this bubble is actually in the grid at this position\n            const hexPos = bubble.getGridPosition();\n            if (hexPos) {\n                const expectedPos = this.bubbleGrid.hexToPixel(hexPos);\n                // Check if bubble is actually at its grid position (not falling)\n                const distance = Phaser.Math.Distance.Between(bubble.x, bubble.y, expectedPos.x, expectedPos.y);\n                \n                if (distance < 5) {\n                    // Bubble is truly at grid position and in danger zone\n                    console.log('💀 Bubble crossed OPPONENT danger line! Opponent loses!');\n                    console.log(`Bubble Y: ${bubble.y}, Danger Line: ${opponentDangerY}`);\n                    this.triggerGameOver(true); // Player wins\n                    return;\n                }\n            }\n        }\n    }\n    \n    private wasAIShot(bubble: Bubble): boolean {\n        // Track the last shooter - for now we can check the last shot event\n        // This is a simple heuristic: if the bubble was attached high, it likely came from below (player)\n        // If attached low, it came from above (AI)\n        // Better would be to track shooter in bubble data\n        \n        // Simple check: was the bubble's initial trajectory downward (AI) or upward (Player)?\n        // We'll check based on the position where it attached\n        const centerY = this.scene.cameras.main.centerY;\n        \n        // If bubble is in upper half and moving toward center, likely from AI\n        // This is simplified - ideally we'd track the shooter\n        return bubble.y < centerY - 100;\n    }\n    \n    private triggerGameOver(playerWins: boolean): void {\n        // Already set to true in checkChestHit, but double-check\n        if (this.gameOver && (this.victoryScreen || this.defeatScreen)) return;\n        \n        this.gameOver = true;\n        \n        // Stop all game systems\n        this.scene.physics.pause();\n        this.aiOpponent?.stop();\n        this.shootingSystem?.destroy();\n        \n        // Emit game over events for sound system\n        if (playerWins) {\n            this.scene.events.emit('victory');\n        } else {\n            this.scene.events.emit('defeat');\n        }\n        \n        // Show appropriate screen\n        if (playerWins) {\n            console.log('🎉 VICTORY! Player wins!');\n            \n            // Debug callback functions\n            console.log('Creating VictoryScreen with callbacks:');\n            console.log('restartGame type:', typeof this.restartGame);\n            console.log('returnToMenu type:', typeof this.returnToMenu);\n            \n            this.victoryScreen = new VictoryScreen(\n                this.scene,\n                this.playerScore,\n                this.restartGame,\n                this.returnToMenu\n            );\n            \n            // Camera celebration effect\n            this.scene.cameras.main.flash(500, 255, 215, 0);\n        } else {\n            console.log('💀 DEFEAT! AI wins!');\n            \n            // Debug callback functions\n            console.log('Creating DefeatScreen with callbacks:');\n            console.log('restartGame type:', typeof this.restartGame);\n            console.log('returnToMenu type:', typeof this.returnToMenu);\n            \n            this.defeatScreen = new DefeatScreen(\n                this.scene,\n                this.playerScore,\n                this.restartGame,\n                this.returnToMenu\n            );\n            \n            // Camera fade effect\n            this.scene.cameras.main.fade(500, 0, 0, 0, false);\n            this.scene.cameras.main.once('camerafadeoutcomplete', () => {\n                this.scene.cameras.main.fadeIn(500);\n            });\n        }\n        \n        // Fire game over event\n        this.scene.events.emit('game-over', { \n            winner: playerWins ? 'player' : 'ai', \n            playerScore: this.playerScore,\n            aiScore: this.aiScore\n        });\n    }\n    \n    private restartGame = (): void => {\n        console.log('🔄 RESTART BUTTON CLICKED!');\n        \n        try {\n            // Prevent multiple clicks\n            if (this.isRestarting) {\n                console.log('Already restarting, ignoring click');\n                return;\n            }\n            this.isRestarting = true;\n            \n            console.log('IMMEDIATE RESTART - No fade, direct action');\n            \n            // Clean up UI elements immediately\n            if (this.victoryScreen) {\n                this.victoryScreen.destroy();\n                this.victoryScreen = undefined;\n            }\n            if (this.defeatScreen) {\n                this.defeatScreen.destroy();\n                this.defeatScreen = undefined;\n            }\n            \n            console.log('UI cleaned up, attempting restart methods...');\n            \n            // Try Phaser method first (immediate)\n            console.log('Method 0: Phaser scene destruction and recreation');\n            try {\n                // Destroy all game objects\n                this.scene.children.removeAll(true);\n                \n                // Reset game state completely\n                this.gameOver = false;\n                this.playerScore = 0;\n                this.aiScore = 0;\n                this.isRestarting = false;\n                \n                // Restart the scene using scene manager\n                const sceneKey = this.scene.scene.key;\n                console.log('Restarting scene with key:', sceneKey);\n                \n                this.scene.scene.restart();\n                \n                console.log('✅ Phaser restart method attempted');\n                \n            } catch (phaserError) {\n                console.error('Phaser restart failed:', phaserError);\n                \n                // Fallback to page reload methods\n                console.log('Fallback: Attempting page reload methods...');\n                \n                // Method 1: Force reload with timestamp\n                console.log('Method 1: Force reload with timestamp');\n                window.location.href = window.location.href.split('?')[0] + '?t=' + Date.now();\n                \n                // Method 2: Backup - traditional reload after delay\n                setTimeout(() => {\n                    console.log('Method 2: Traditional reload backup');\n                    window.location.reload(true);\n                }, 100);\n            }\n            \n        } catch (error) {\n            console.error('❌ Error in restartGame, trying alternative methods:', error);\n            \n            // Try alternative reload methods\n            try {\n                console.log('Emergency reload attempt 1: document.location.reload()');\n                (document.location as any).reload(true);\n            } catch (e2) {\n                console.log('Emergency reload attempt 2: history manipulation');\n                window.history.go(0);\n            }\n        }\n    }\n    \n    private returnToMenu = (): void => {\n        console.log('🏠 MENU BUTTON CLICKED!');\n        \n        try {\n            // Prevent multiple clicks\n            if (this.isRestarting) {\n                console.log('Already transitioning, ignoring click');\n                return;\n            }\n            this.isRestarting = true;\n            \n            console.log('MENU - Using same method as Try Again (works!)');\n            \n            // Clean up UI elements immediately\n            if (this.victoryScreen) {\n                this.victoryScreen.destroy();\n                this.victoryScreen = undefined;\n            }\n            if (this.defeatScreen) {\n                this.defeatScreen.destroy();\n                this.defeatScreen = undefined;\n            }\n            \n            console.log('UI cleaned up for menu, using restart method...');\n            \n            // Use the EXACT same method that works for Try Again\n            try {\n                // Destroy all game objects\n                this.scene.children.removeAll(true);\n                \n                // Reset game state completely\n                this.gameOver = false;\n                this.playerScore = 0;\n                this.aiScore = 0;\n                this.isRestarting = false;\n                \n                // Restart the scene using scene manager\n                const sceneKey = this.scene.scene.key;\n                console.log('Menu: Restarting scene with key:', sceneKey);\n                \n                this.scene.scene.restart();\n                \n                console.log('✅ Menu using restart method (same as Try Again)');\n                \n            } catch (phaserError) {\n                console.error('Menu restart failed:', phaserError);\n                \n                // Same fallback as Try Again\n                console.log('Menu Fallback: Force reload...');\n                window.location.href = window.location.href.split('?')[0] + '?t=' + Date.now();\n            }\n            \n        } catch (error) {\n            console.error('❌ Error in returnToMenu:', error);\n            // Force restart as last resort\n            window.location.reload();\n        }\n    }\n    \n    private checkDangerZoneProximity(): void {\n        if (this.gameOver) return;\n        \n        const screenHeight = this.scene.cameras.main.height;\n        const playerDangerY = screenHeight - DANGER_ZONE_CONFIG.PLAYER_OFFSET;\n        const opponentDangerY = DANGER_ZONE_CONFIG.OPPONENT_OFFSET;\n        \n        let nearDanger = false;\n        const warningDistance = 40; // Start warning when bubbles are within 40 pixels\n        \n        // Check all grid bubbles\n        const gridBubbles = this.gridAttachmentSystem.getGridBubbles();\n        \n        // Use more efficient iteration with early exit\n        for (let i = 0; i < gridBubbles.length; i++) {\n            const bubble = gridBubbles[i];\n            if (!bubble.visible) continue;\n            \n            // Check proximity to player danger zone\n            const playerDistance = playerDangerY - bubble.y;\n            if (playerDistance < warningDistance && playerDistance > 0) {\n                nearDanger = true;\n                this.activateDangerWarning(this.playerDangerLine, true);\n                break; // Exit early once we find danger\n            }\n            \n            // Check proximity to opponent danger zone\n            const opponentDistance = bubble.y - opponentDangerY;\n            if (opponentDistance < warningDistance && opponentDistance > 0) {\n                nearDanger = true;\n                this.activateDangerWarning(this.opponentDangerLine, false);\n                break; // Exit early once we find danger\n            }\n        }\n        \n        // Deactivate warning if no bubbles are near danger\n        if (!nearDanger && this.dangerWarningActive) {\n            this.deactivateDangerWarning();\n        }\n    }\n    \n    private activateDangerWarning(dangerLine: Phaser.GameObjects.Graphics | undefined, isPlayer: boolean): void {\n        if (!dangerLine || this.dangerWarningActive) return;\n        \n        this.dangerWarningActive = true;\n        \n        // Emit danger warning event for sound system\n        this.scene.events.emit('danger-warning', { isPlayer });\n        \n        // Pulse animation for danger line\n        this.scene.tweens.add({\n            targets: dangerLine,\n            alpha: { from: 0.6, to: 1 },\n            duration: DANGER_ZONE_CONFIG.PULSE_DURATION / 2,\n            yoyo: true,\n            repeat: -1,\n            ease: 'Sine.easeInOut'\n        });\n        \n        // Flash effect for player only\n        if (isPlayer) {\n            this.scene.cameras.main.flash(200, 255, 0, 0, false);\n        }\n    }\n    \n    private deactivateDangerWarning(): void {\n        this.dangerWarningActive = false;\n        \n        // Stop animations\n        if (this.playerDangerLine) {\n            this.scene.tweens.killTweensOf(this.playerDangerLine);\n            this.playerDangerLine.setAlpha(1);\n        }\n        \n        if (this.opponentDangerLine) {\n            this.scene.tweens.killTweensOf(this.opponentDangerLine);\n            this.opponentDangerLine.setAlpha(1);\n        }\n    }\n    \n    public destroy(): void {\n        this.inputManager?.destroy();\n        this.shootingSystem?.destroy();\n        this.gridAttachmentSystem?.clearGrid();\n        this.matchDetectionSystem?.reset();\n        this.aiOpponent?.destroy();\n        this.bubbles.forEach(bubble => bubble.destroy());\n        this.bubblePool.forEach(bubble => bubble.destroy());\n        this.objective?.destroy();\n        this.playerLauncher?.destroy();\n        this.opponentLauncher?.destroy();\n        this.debugGraphics?.destroy();\n        this.enhancedScoreDisplay?.destroy();\n        this.comboManager?.reset();\n        this.scoreEventManager?.destroy();\n        this.unifiedFeedbackSystem?.destroy();\n        this.paintSplatterSystem?.destroy();\n        this.victoryScreen?.destroy();\n        this.defeatScreen?.destroy();\n        // this.playerPowerUpInventory?.destroy(); // Arsenal now integrated in Launcher\n        // this.opponentPowerUpInventory?.destroy(); // No longer created\n        \n        // Remove event listeners\n        this.scene.events.off('score-update', this.onScoreUpdate, this);\n        this.scene.events.off('bubble-attached', this.checkVictoryCondition, this);\n        this.scene.events.off('bubble-position-update', this.checkChestHit, this);\n    }\n    \n    /**\n     * Get paint splatter system for configuration or monitoring\n     */\n    public getPaintSplatterSystem(): PaintSplatterSystem | undefined {\n        return this.paintSplatterSystem;\n    }\n    \n    /**\n     * Set graphics quality preset (affects paint splatters and other visual effects)\n     */\n    public setGraphicsQuality(quality: 'low' | 'medium' | 'high' | 'ultra'): void {\n        // Update paint splatter quality\n        this.paintSplatterSystem?.setQualityPreset(quality);\n        \n        // Could update other visual systems here in the future\n        console.log(`Graphics quality set to: ${quality}`);\n    }\n}","/**\n * RealSoundSystem - Simple MP3 sound playback system\n * Uses Phaser's built-in audio system to play real sound files\n */\n\nimport { Scene } from 'phaser';\nimport { ASSET_KEYS } from '@/config/AssetManifest';\n\nexport class RealSoundSystem {\n    private scene: Scene;\n    private sounds: Map<string, Phaser.Sound.BaseSound> = new Map();\n    private muted: boolean = false;\n    private masterVolume: number = 0.5;\n    \n    // Volume settings for different sound types\n    private volumes = {\n        shoot: 0.3,\n        attach: 0.4,\n        combo: 0.6,\n        celebration: 1.0,  // Maximum volume for celebration\n        arsenal: 0.5,\n        victory: 0.9,\n        background: 0.2\n    };\n\n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.initializeSounds();\n    }\n\n    private initializeSounds(): void {\n        console.log('RealSoundSystem: Initializing sounds...');\n        \n        // Check if sounds are loaded\n        const audioCache = this.scene.cache.audio;\n        \n        Object.values(ASSET_KEYS.AUDIO).forEach(key => {\n            if (audioCache.exists(key)) {\n                console.log(`RealSoundSystem: Sound ${key} is available`);\n            } else {\n                console.warn(`RealSoundSystem: Sound ${key} not found in cache`);\n            }\n        });\n    }\n\n    /**\n     * Play bubble shoot sound\n     */\n    public playShootSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.BUBBLE_SHOOT, this.volumes.shoot);\n    }\n\n    /**\n     * Play bubble attach sound\n     */\n    public playAttachSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.BUBBLE_ATTACH, this.volumes.attach);\n    }\n\n    /**\n     * Play bubbles drop sound (slower playback, lower volume)\n     */\n    public playBubblesDropSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.BUBBLES_DROP, this.volumes.combo * 0.6, 0.85); // 40% quieter, 15% slower\n    }\n\n    /**\n     * Play combo sound based on size\n     */\n    public playComboSound(size: number): void {\n        if (this.muted) return;\n        \n        let soundKey: string;\n        let volume = this.volumes.combo;\n        \n        if (size === 3) {\n            soundKey = ASSET_KEYS.AUDIO.COMBO_3;\n            this.playSound(soundKey, volume);\n        } else if (size === 4) {\n            soundKey = ASSET_KEYS.AUDIO.COMBO_4;\n            this.playSound(soundKey, volume);\n        } else if (size >= 5) {\n            soundKey = ASSET_KEYS.AUDIO.COMBO_5_PLUS;\n            volume = this.volumes.combo * 0.7; // Quieter, more subtle\n            \n            // Play combo 5+ slower and quieter for more dramatic effect\n            this.playSound(soundKey, volume, 0.85); // 30% quieter, 15% slower\n            \n            // ALWAYS play celebration for 5+ combos (not just 7+)\n            setTimeout(() => {\n                this.playSound(ASSET_KEYS.AUDIO.COMBO_CELEBRATION, this.volumes.celebration); // Full celebration volume\n            }, 200);\n        } else {\n            return; // No sound for less than 3\n        }\n    }\n\n    /**\n     * Play match sound (alias for combo sound)\n     */\n    public playMatchSound(matchSize: number): void {\n        this.playComboSound(matchSize);\n    }\n\n    /**\n     * Play arsenal pickup sound\n     */\n    public playArsenalPickupSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.ARSENAL_PICKUP, this.volumes.arsenal);\n    }\n\n    /**\n     * Play success objective sound (for mystery box/treasure chest)\n     */\n    public playSuccessObjectiveSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.SUCCESS_OBJECTIVE, this.volumes.arsenal * 1.2); // Slightly louder for impact\n    }\n\n    /**\n     * Play victory sound\n     */\n    public playVictorySound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.VICTORY, this.volumes.victory);\n    }\n\n    /**\n     * Play defeat sound\n     */\n    public playDefeatSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.DEFEAT, this.volumes.victory * 0.7);\n    }\n\n    /**\n     * Play power-up sound (using arsenal pickup)\n     */\n    public playPowerUpSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.ARSENAL_PICKUP, this.volumes.arsenal);\n    }\n\n    /**\n     * Play UI click sound (using attach sound at lower volume)\n     */\n    public playClickSound(): void {\n        if (this.muted) return;\n        this.playSound(ASSET_KEYS.AUDIO.BUBBLE_ATTACH, this.volumes.attach * 0.5);\n    }\n\n    /**\n     * Play background music\n     */\n    public playBackgroundMusic(): Phaser.Sound.BaseSound | undefined {\n        if (this.muted) return undefined;\n        \n        const key = ASSET_KEYS.AUDIO.BACKGROUND_MUSIC;\n        \n        // Check if we have background music file\n        if (!this.scene.cache.audio.exists(key)) {\n            console.log('RealSoundSystem: No background music file found');\n            return undefined;\n        }\n        \n        // Stop any existing background music\n        const existingMusic = this.sounds.get('background-music');\n        if (existingMusic) {\n            existingMusic.stop();\n        }\n        \n        const music = this.scene.sound.add(key, {\n            volume: this.volumes.background * this.masterVolume,\n            loop: true\n        });\n        \n        this.sounds.set('background-music', music);\n        music.play();\n        \n        return music;\n    }\n\n    /**\n     * Helper to play a sound\n     * @param key Sound key\n     * @param volume Volume level (0-1)\n     * @param rate Playback rate (1 = normal, 0.5 = half speed, 2 = double speed)\n     */\n    private playSound(key: string, volume: number = 0.5, rate: number = 1): void {\n        try {\n            if (!this.scene.cache.audio.exists(key)) {\n                console.warn(`RealSoundSystem: Sound ${key} not loaded`);\n                return;\n            }\n            \n            const sound = this.scene.sound.add(key, {\n                volume: volume * this.masterVolume,\n                rate: rate // Playback speed\n            });\n            \n            sound.play();\n            \n            // Clean up after playing\n            sound.once('complete', () => {\n                sound.destroy();\n            });\n        } catch (error) {\n            console.error(`RealSoundSystem: Error playing sound ${key}:`, error);\n        }\n    }\n\n    /**\n     * Toggle mute\n     */\n    public toggleMute(): boolean {\n        this.muted = !this.muted;\n        \n        // Mute/unmute all playing sounds\n        this.scene.sound.mute = this.muted;\n        \n        return this.muted;\n    }\n\n    /**\n     * Set master volume\n     */\n    public setMasterVolume(volume: number): void {\n        this.masterVolume = Math.max(0, Math.min(1, volume));\n        this.scene.sound.volume = this.masterVolume;\n    }\n\n    /**\n     * Test all sounds\n     */\n    public testAllSounds(): void {\n        console.log('RealSoundSystem: Testing all sounds...');\n        \n        const sounds = [\n            { key: ASSET_KEYS.AUDIO.BUBBLE_SHOOT, name: 'Shoot' },\n            { key: ASSET_KEYS.AUDIO.BUBBLE_ATTACH, name: 'Attach' },\n            { key: ASSET_KEYS.AUDIO.COMBO_3, name: 'Combo 3' },\n            { key: ASSET_KEYS.AUDIO.COMBO_4, name: 'Combo 4' },\n            { key: ASSET_KEYS.AUDIO.COMBO_5_PLUS, name: 'Combo 5+' },\n            { key: ASSET_KEYS.AUDIO.VICTORY, name: 'Victory' }\n        ];\n        \n        let delay = 0;\n        sounds.forEach(({ key, name }) => {\n            setTimeout(() => {\n                console.log(`Playing: ${name}`);\n                this.playSound(key, 0.5);\n            }, delay);\n            delay += 1000;\n        });\n    }\n\n    /**\n     * Get system info\n     */\n    public getInfo(): any {\n        return {\n            muted: this.muted,\n            masterVolume: this.masterVolume,\n            soundsLoaded: Object.values(ASSET_KEYS.AUDIO).filter(key => \n                this.scene.cache.audio.exists(key)\n            ).length,\n            totalSounds: Object.values(ASSET_KEYS.AUDIO).length\n        };\n    }\n\n    /**\n     * Cleanup\n     */\n    public destroy(): void {\n        // Stop all sounds\n        this.sounds.forEach(sound => {\n            sound.stop();\n            sound.destroy();\n        });\n        this.sounds.clear();\n    }\n}","/**\n * TweenOptimizer - Manages and optimizes tweens for better performance\n * Keeps all visual effects but makes them more efficient\n */\nexport class TweenOptimizer {\n    private static instance: TweenOptimizer | null = null;\n    private scene: Phaser.Scene;\n    private activeTweens: Map<string, Phaser.Tweens.Tween> = new Map();\n    private tweenGroups: Map<string, Set<string>> = new Map();\n    private frameCounter: number = 0;\n    \n    constructor(scene: Phaser.Scene) {\n        this.scene = scene;\n        TweenOptimizer.instance = this;\n    }\n    \n    public static getInstance(scene?: Phaser.Scene): TweenOptimizer | null {\n        if (!TweenOptimizer.instance && scene) {\n            TweenOptimizer.instance = new TweenOptimizer(scene);\n        }\n        return TweenOptimizer.instance;\n    }\n    \n    /**\n     * Create an optimized infinite tween that can be shared between similar objects\n     * This keeps ALL animations but reduces overhead\n     */\n    public createOptimizedTween(\n        id: string,\n        targets: any,\n        props: any,\n        duration: number,\n        options: {\n            yoyo?: boolean;\n            repeat?: number;\n            ease?: string;\n            delay?: number;\n            group?: string; // Group similar tweens together\n            stagger?: number; // Stagger start times for visual variety\n        } = {}\n    ): Phaser.Tweens.Tween | null {\n        // If this is an infinite tween for a group, try to reuse existing\n        if (options.repeat === -1 && options.group) {\n            const existingTween = this.getGroupTween(options.group);\n            if (existingTween && this.canShareTween(existingTween, props)) {\n                // Add target to existing tween instead of creating new one\n                this.addTargetToTween(existingTween, targets, options.stagger);\n                return existingTween;\n            }\n        }\n        \n        // Create new optimized tween\n        const tweenConfig: any = {\n            targets,\n            ...props,\n            duration,\n            yoyo: options.yoyo || false,\n            repeat: options.repeat || 0,\n            ease: options.ease || 'Linear',\n            delay: options.delay || 0\n        };\n        \n        // For infinite tweens, add optimization\n        if (options.repeat === -1) {\n            // Reduce update frequency for less critical animations\n            tweenConfig.callbackScope = this;\n            tweenConfig.onUpdate = this.throttleUpdate.bind(this, id);\n        }\n        \n        const tween = this.scene.tweens.add(tweenConfig);\n        \n        this.activeTweens.set(id, tween);\n        \n        if (options.group) {\n            if (!this.tweenGroups.has(options.group)) {\n                this.tweenGroups.set(options.group, new Set());\n            }\n            this.tweenGroups.get(options.group)!.add(id);\n        }\n        \n        return tween;\n    }\n    \n    /**\n     * Throttle tween updates for better performance\n     */\n    private throttleUpdate(id: string): void {\n        // Only update visual every few frames for non-critical animations\n        this.frameCounter++;\n        if (this.frameCounter % 2 === 0) {\n            // Update happens naturally, just skip some frames\n            return;\n        }\n    }\n    \n    /**\n     * Check if a tween can be shared with new targets\n     */\n    private canShareTween(tween: Phaser.Tweens.Tween, props: any): boolean {\n        // Check if properties match (simplified check)\n        const tweenData = tween.data[0];\n        if (!tweenData) return false;\n        \n        for (const key in props) {\n            if (tweenData.key === key) {\n                return true; // Can share if at least one property matches\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Add a target to an existing tween\n     */\n    private addTargetToTween(tween: Phaser.Tweens.Tween, target: any, stagger?: number): void {\n        // In Phaser, we can't directly add targets to running tweens\n        // Instead, we'll create a linked tween with slight offset for variety\n        const tweenData = tween.data[0];\n        if (!tweenData) return;\n        \n        const linkedConfig: any = {\n            targets: target,\n            duration: tweenData.duration,\n            yoyo: tween.yoyo,\n            repeat: tween.repeat,\n            ease: tweenData.ease,\n            delay: stagger || 0\n        };\n        \n        // Copy properties\n        tween.data.forEach((data: any) => {\n            linkedConfig[data.key] = {\n                from: data.start,\n                to: data.end\n            };\n        });\n        \n        this.scene.tweens.add(linkedConfig);\n    }\n    \n    /**\n     * Get a tween from a group\n     */\n    private getGroupTween(group: string): Phaser.Tweens.Tween | null {\n        const groupIds = this.tweenGroups.get(group);\n        if (!groupIds || groupIds.size === 0) return null;\n        \n        const firstId = groupIds.values().next().value;\n        return this.activeTweens.get(firstId) || null;\n    }\n    \n    /**\n     * Remove a tween\n     */\n    public removeTween(id: string): void {\n        const tween = this.activeTweens.get(id);\n        if (tween) {\n            tween.destroy();\n            this.activeTweens.delete(id);\n            \n            // Remove from groups\n            this.tweenGroups.forEach((ids, group) => {\n                ids.delete(id);\n                if (ids.size === 0) {\n                    this.tweenGroups.delete(group);\n                }\n            });\n        }\n    }\n    \n    /**\n     * Pause all tweens in a group\n     */\n    public pauseGroup(group: string): void {\n        const groupIds = this.tweenGroups.get(group);\n        if (!groupIds) return;\n        \n        groupIds.forEach(id => {\n            const tween = this.activeTweens.get(id);\n            if (tween) {\n                tween.pause();\n            }\n        });\n    }\n    \n    /**\n     * Resume all tweens in a group\n     */\n    public resumeGroup(group: string): void {\n        const groupIds = this.tweenGroups.get(group);\n        if (!groupIds) return;\n        \n        groupIds.forEach(id => {\n            const tween = this.activeTweens.get(id);\n            if (tween) {\n                tween.resume();\n            }\n        });\n    }\n    \n    /**\n     * Clean up\n     */\n    public destroy(): void {\n        this.activeTweens.forEach(tween => tween.destroy());\n        this.activeTweens.clear();\n        this.tweenGroups.clear();\n        TweenOptimizer.instance = null;\n    }\n    \n    /**\n     * Get stats for debugging\n     */\n    public getStats(): { totalTweens: number; groups: number; tweensPerGroup: Map<string, number> } {\n        const tweensPerGroup = new Map<string, number>();\n        this.tweenGroups.forEach((ids, group) => {\n            tweensPerGroup.set(group, ids.size);\n        });\n        \n        return {\n            totalTweens: this.activeTweens.size,\n            groups: this.tweenGroups.size,\n            tweensPerGroup\n        };\n    }\n}","import { Scene } from 'phaser';\nimport { SceneKeys, ISceneData, GameEvents } from '@/types/GameTypes';\nimport { SceneManager } from '@/systems/core/SceneManager';\nimport { ArenaSystem, AIDifficulty } from '@/systems/gameplay/ArenaSystem';\nimport { PerformanceMonitor } from '@/utils/PerformanceMonitor';\nimport { RealSoundSystem } from '@/systems/audio/RealSoundSystem';\nimport { Z_LAYERS } from '@/config/ArenaConfig';\nimport { TweenOptimizer } from '@/systems/visual/TweenOptimizer';\nimport { BackgroundSystem } from '@/systems/visual/BackgroundSystem';\n\nexport class GameScene extends Scene {\n    private sceneManager!: SceneManager;\n    private performanceMonitor!: PerformanceMonitor;\n    private arenaSystem!: ArenaSystem;\n    private soundSystem!: RealSoundSystem;\n    private backgroundSystem!: BackgroundSystem;\n    private backgroundMusic: Phaser.Sound.BaseSound | undefined;\n    private fpsText!: Phaser.GameObjects.Text;\n    private frameCount: number = 0;\n    private lastFPSUpdate: number = 0;\n    // debugText removed for clean production UI\n    // scoreText removed - using player-specific scores\n    private isPaused: boolean = false;\n    private tweenOptimizer!: TweenOptimizer;\n\n    constructor() {\n        super({ key: SceneKeys.GAME });\n    }\n\n    public preload(): void {\n        // No background image loading needed - using procedural graphics\n        \n        // Cannon sprite loading disabled - using procedural graphics\n        // this.load.image('cannon', 'assets/sprites/cannon2_transparent.png');\n        \n        // Load background music\n        // Note: Place background_music.mp3 in public/assets/audio/\n        this.load.audio('background-music', 'assets/audio/background_music.mp3');\n    }\n\n    public init(data: ISceneData): void {\n        console.log('GameScene: Initializing game arena...');\n        \n        // Clean up any existing background music before reinitializing\n        if (this.backgroundMusic) {\n            this.backgroundMusic.stop();\n            this.backgroundMusic.destroy();\n            this.backgroundMusic = undefined;\n        }\n        \n        // Store theme selection if provided\n        if (data && (data as any).theme) {\n            this.registry.set('gameTheme', (data as any).theme);\n        }\n        \n        // Set isCapacitor flag in registry for global access\n        const isCapacitor = !!(window as any).Capacitor;\n        this.game.registry.set('isCapacitor', isCapacitor);\n        \n        this.sceneManager = SceneManager.getInstance();\n        this.sceneManager.setCurrentScene(SceneKeys.GAME);\n        this.performanceMonitor = new PerformanceMonitor();\n        this.performanceMonitor.setEventEmitter(this.game.events);\n        this.isPaused = false;\n    }\n\n    public create(): void {\n        try {\n            // Set a visible background color first\n            this.cameras.main.setBackgroundColor('#3498db');\n            \n            // Initialize TweenOptimizer for performance\n            this.tweenOptimizer = new TweenOptimizer(this);\n            \n            console.log('GameScene: Creating background...');\n            this.createBackground();\n            \n            console.log('GameScene: Initializing sound system...');\n            this.createSoundSystem();\n            \n            console.log('GameScene: Starting background music...');\n            this.createBackgroundMusic();\n            \n            console.log('GameScene: Creating arena...');\n            this.createArena();\n            \n            console.log('GameScene: Creating UI...');\n            this.createUI();\n            \n            console.log('GameScene: Setting up input handlers...');\n            this.setupInputHandlers();\n            \n            // Emit arena ready event\n            this.game.events.emit(GameEvents.SCENE_READY, {\n                scene: SceneKeys.GAME\n            });\n            \n            console.log('GameScene: Arena setup complete');\n        } catch (error) {\n            console.error('GameScene: Error during creation:', error);\n        }\n    }\n\n    private createSoundSystem(): void {\n        try {\n            this.soundSystem = new RealSoundSystem(this);\n            console.log('GameScene: Sound system initialized successfully');\n        } catch (error) {\n            console.error('GameScene: Failed to initialize sound system:', error);\n            // Continue without sound system - game should still be playable\n        }\n    }\n    \n    private createBackgroundMusic(): void {\n        try {\n            // Stop any existing background music first to prevent overlapping\n            if (this.backgroundMusic) {\n                this.backgroundMusic.stop();\n                this.backgroundMusic.destroy();\n                this.backgroundMusic = undefined;\n            }\n            \n            // Use the sound system to play background music\n            if (this.soundSystem) {\n                this.backgroundMusic = this.soundSystem.playBackgroundMusic();\n                if (this.backgroundMusic) {\n                    console.log('GameScene: Background music started');\n                } else {\n                    console.log('GameScene: No background music available');\n                }\n            }\n        } catch (error) {\n            console.error('GameScene: Failed to create background music:', error);\n        }\n    }\n\n    private createBackground(): void {\n        // Detect device performance for quality settings\n        const isCapacitor = this.registry.get('isCapacitor');\n        const quality = isCapacitor ? 'medium' : 'high'; // Lower quality on mobile for performance\n        \n        // Get selected theme or default to ocean\n        const selectedTheme = this.registry.get('gameTheme') || this.registry.get('selectedTheme') || 'ocean';\n        \n        // Create the new advanced background system\n        this.backgroundSystem = new BackgroundSystem(this, {\n            theme: selectedTheme as any,\n            quality: quality,\n            enableParticles: true,\n            enableAnimation: true\n        });\n        \n        console.log(`GameScene: Created advanced background system with ${selectedTheme} theme and ${quality} quality`);\n    }\n    \n    // Old methods commented out - replaced by BackgroundSystem\n    /*\n    private createGeometricPattern(width: number, height: number): void {\n        const patternGraphics = this.add.graphics();\n        \n        // Create subtle hexagonal pattern\n        const hexSize = 40;\n        const hexColor = 0x1e3a5f;\n        const hexAlpha = 0.1;\n        \n        patternGraphics.lineStyle(1, hexColor, hexAlpha);\n        \n        // Draw hexagonal grid pattern\n        const hexWidth = hexSize * Math.sqrt(3);\n        const hexHeight = hexSize * 2;\n        const vertSpacing = hexHeight * 0.75;\n        \n        for (let row = 0; row < Math.ceil(height / vertSpacing) + 2; row++) {\n            for (let col = 0; col < Math.ceil(width / hexWidth) + 2; col++) {\n                const x = col * hexWidth + (row % 2) * (hexWidth / 2) - hexWidth;\n                const y = row * vertSpacing - vertSpacing;\n                \n                if (x < width + hexSize && y < height + hexSize) {\n                    this.drawHexagon(patternGraphics, x, y, hexSize);\n                }\n            }\n        }\n        \n        patternGraphics.setDepth(Z_LAYERS.BACKGROUND + 1);\n    }\n    \n    private drawHexagon(graphics: Phaser.GameObjects.Graphics, x: number, y: number, size: number): void {\n        const points: number[] = [];\n        \n        for (let i = 0; i < 6; i++) {\n            const angle = (i * 60) * Math.PI / 180;\n            points.push(x + size * Math.cos(angle));\n            points.push(y + size * Math.sin(angle));\n        }\n        \n        graphics.strokePoints(points, true);\n    }\n    \n    private createAmbientParticles(width: number, height: number): void {\n        // Create subtle floating particles for atmosphere\n        const particleCount = Math.min(25, Math.floor((width * height) / 15000));\n        \n        for (let i = 0; i < particleCount; i++) {\n            const particle = this.add.graphics();\n            const size = Phaser.Math.Between(1, 3);\n            const alpha = Phaser.Math.FloatBetween(0.1, 0.3);\n            const color = Phaser.Math.RND.pick([0x2a4d6b, 0x3e6b8a, 0x4a7ba7]);\n            \n            particle.fillStyle(color, alpha);\n            particle.fillCircle(0, 0, size);\n            \n            // Random starting position\n            const startX = Phaser.Math.Between(-50, width + 50);\n            const startY = Phaser.Math.Between(-50, height + 50);\n            particle.setPosition(startX, startY);\n            particle.setDepth(Z_LAYERS.BACKGROUND + 2);\n            \n            // Gentle floating animation\n            const duration = Phaser.Math.Between(8000, 15000);\n            const endX = startX + Phaser.Math.Between(-100, 100);\n            const endY = startY + Phaser.Math.Between(-100, 100);\n            \n            this.tweens.add({\n                targets: particle,\n                x: endX,\n                y: endY,\n                alpha: { from: alpha, to: 0 },\n                duration: duration,\n                ease: 'Sine.easeInOut',\n                repeat: -1,\n                yoyo: true,\n                onRepeat: () => {\n                    // Randomize position on repeat for variety\n                    particle.setPosition(\n                        Phaser.Math.Between(-50, width + 50),\n                        Phaser.Math.Between(-50, height + 50)\n                    );\n                }\n            });\n        }\n    }\n    */\n\n    private createArena(): void {\n        try {\n            console.log('GameScene: Instantiating ArenaSystem...');\n            this.arenaSystem = new ArenaSystem(this);\n            \n            console.log('GameScene: Setting up arena with AI opponent (HARD)...');\n            // Setup single player mode with AI difficulty - Always HARD\n            this.arenaSystem.setupArena(true, AIDifficulty.HARD);\n            \n            // Connect sound system to game events\n            this.setupSoundEvents();\n            \n            console.log('GameScene: Arena created successfully with AI opponent');\n        } catch (error) {\n            console.error('GameScene: Error creating arena:', error);\n            throw error;\n        }\n    }\n    \n    private setupSoundEvents(): void {\n        if (!this.soundSystem) return;\n        \n        // Bubble shoot event\n        this.events.on('bubble-shoot', () => {\n            this.soundSystem.playShootSound();\n        });\n        \n        // Bubble attach event (for game logic)\n        this.events.on('bubble-attached', () => {\n            // Game logic handled elsewhere\n        });\n        \n        // Bubble attach collision event (plays at exact collision moment)\n        this.events.on('bubble-attach-collision', () => {\n            this.soundSystem.playAttachSound();\n        });\n        \n        // Bubble attach sound event (backup for other attach cases)\n        this.events.on('bubble-attached-sound', () => {\n            // Already played on collision\n        });\n        \n        // Match found event - play combo sounds\n        this.events.on('match-found', (data: any) => {\n            // Play real MP3 combo sounds based on match size\n            if (data && data.matchSize) {\n                this.soundSystem.playMatchSound(data.matchSize);\n            }\n        });\n        \n        // Power-up activated event\n        this.events.on('power-up-activated', () => {\n            this.soundSystem.playPowerUpSound();\n        });\n        \n        // UI click event\n        this.events.on('ui-click', () => {\n            this.soundSystem.playClickSound();\n        });\n        \n        // Victory event\n        this.events.on('victory', () => {\n            this.soundSystem.playVictorySound();\n        });\n        \n        // Defeat event\n        this.events.on('defeat', () => {\n            this.soundSystem.playDefeatSound();\n        });\n        \n        // Floating bubbles drop event\n        this.events.on('floating-bubbles-drop', () => {\n            this.soundSystem.playBubblesDropSound();\n        });\n        \n        // Mystery box collected event\n        this.events.on('mystery-box-collected', () => {\n            this.soundSystem.playSuccessObjectiveSound();\n        });\n        \n        // Objective hit event (when hitting the treasure chest)\n        this.events.on('objective-hit', () => {\n            this.soundSystem.playSuccessObjectiveSound();\n        });\n        \n        console.log('GameScene: Sound events connected');\n    }\n\n    private createFPSDisplay(): void {\n        const width = this.cameras.main.width;\n        const height = this.cameras.main.height;\n        \n        // Create FPS text in bottom right corner - more visible on mobile\n        this.fpsText = this.add.text(width - 100, height - 100, 'FPS: 0', {\n            fontSize: '20px',\n            color: '#00FF00',\n            fontFamily: 'Arial, sans-serif',\n            fontStyle: 'bold',\n            backgroundColor: '#000000CC',\n            padding: { x: 10, y: 6 }\n        });\n        \n        this.fpsText.setDepth(Z_LAYERS.UI + 1000); // Make sure it's on top\n        this.fpsText.setScrollFactor(0);\n        this.fpsText.setOrigin(0.5, 0.5);\n        \n        // Initialize FPS tracking\n        this.frameCount = 0;\n        this.lastFPSUpdate = performance.now();\n    }\n\n    private createUI(): void {\n        // Add FPS counter in bottom right corner\n        this.createFPSDisplay();\n        \n        // Debug text removed for clean production UI\n        \n        // Pause button removed for cleaner UI\n        \n        // Central score display removed - using player-specific scores only\n        \n        // Score events are now handled by EnhancedScoreDisplay in ArenaSystem\n        \n        // Listen for score events (for combo indicator only)\n        this.game.events.on('match-completed', (data: any) => {\n            \n            // Combo indicator\n            if (data.combo > 0) {\n                const comboText = this.add.text(\n                    this.cameras.main.width / 2,\n                    90,\n                    `COMBO x${data.combo + 1}!`,\n                    {\n                        fontFamily: 'Arial',\n                        fontSize: '20px',\n                        fontStyle: 'bold',\n                        color: '#FF6B6B',\n                        stroke: '#000000',\n                        strokeThickness: 2\n                    }\n                ).setOrigin(0.5);\n                comboText.setDepth(Z_LAYERS.UI);\n                \n                // Animate combo text\n                this.tweens.add({\n                    targets: comboText,\n                    scale: 1.5,\n                    alpha: 0,\n                    duration: 1000,\n                    ease: 'Power2',\n                    onComplete: () => comboText.destroy()\n                });\n            }\n        });\n    }\n\n    private setupInputHandlers(): void {\n        // ESC key to return to menu\n        this.input.keyboard?.on('keydown-ESC', () => {\n            this.returnToMenu();\n        });\n        \n        // P key to pause\n        this.input.keyboard?.on('keydown-P', () => {\n            this.togglePause();\n        });\n        \n        // Space key for testing (placeholder for shooting)\n        this.input.keyboard?.on('keydown-SPACE', () => {\n            console.log('Space pressed - shooting not yet implemented');\n            this.testBubblePop();\n        });\n        \n        // T key to test audio system\n        this.input.keyboard?.on('keydown-T', () => {\n            console.log('Testing audio system...');\n            this.soundSystem?.testAllSounds();\n            \n            // Also log sound system state\n            const stats = this.soundSystem?.getInfo();\n            console.log('Sound System Stats:', stats);\n        });\n        \n        // M key to toggle mute\n        this.input.keyboard?.on('keydown-M', () => {\n            const muted = this.soundSystem?.toggleMute();\n            \n            // Also mute/unmute background music\n            if (this.backgroundMusic) {\n                if (muted) {\n                    this.backgroundMusic.pause();\n                } else {\n                    this.backgroundMusic.resume();\n                }\n            }\n            \n            console.log(`Audio ${muted ? 'muted' : 'unmuted'}`);\n        });\n        \n        // Number keys 5-9 to change background themes (for testing)\n        if (!this.registry.get('isCapacitor')) { // Only on desktop for testing\n            this.input.keyboard?.on('keydown-FIVE', () => {\n                this.backgroundSystem?.setTheme('ocean');\n                console.log('Background theme: Ocean');\n            });\n            \n            this.input.keyboard?.on('keydown-SIX', () => {\n                this.backgroundSystem?.setTheme('sunset');\n                console.log('Background theme: Sunset');\n            });\n            \n            this.input.keyboard?.on('keydown-SEVEN', () => {\n                this.backgroundSystem?.setTheme('forest');\n                console.log('Background theme: Forest');\n            });\n            \n            this.input.keyboard?.on('keydown-EIGHT', () => {\n                this.backgroundSystem?.setTheme('space');\n                console.log('Background theme: Space');\n            });\n            \n            this.input.keyboard?.on('keydown-NINE', () => {\n                this.backgroundSystem?.setTheme('aurora');\n                console.log('Background theme: Aurora');\n            });\n        }\n    }\n\n    private testBubblePop(): void {\n        // Test bubble popping animation\n        const bubbles = this.arenaSystem.getBubbles();\n        if (bubbles.length > 0) {\n            const randomBubble = bubbles[Math.floor(Math.random() * bubbles.length)];\n            if (randomBubble) {\n                randomBubble.pop();\n            }\n        }\n    }\n\n    private togglePause(): void {\n        this.isPaused = !this.isPaused;\n        \n        if (this.isPaused) {\n            this.physics.pause();\n            this.backgroundMusic?.pause();\n            this.showPauseOverlay();\n        } else {\n            this.physics.resume();\n            this.backgroundMusic?.resume();\n            this.hidePauseOverlay();\n        }\n    }\n\n    private showPauseOverlay(): void {\n        const overlay = this.add.rectangle(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            this.cameras.main.width,\n            this.cameras.main.height,\n            0x000000,\n            0.7\n        );\n        overlay.setDepth(Z_LAYERS.UI + 10);\n        overlay.setData('isPauseOverlay', true);\n        \n        const pauseText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            'PAUSED',\n            {\n                fontFamily: 'Arial',\n                fontSize: '48px',\n                color: '#ffffff'\n            }\n        ).setOrigin(0.5);\n        pauseText.setDepth(Z_LAYERS.UI + 11);\n        pauseText.setData('isPauseOverlay', true);\n        \n        const resumeText = this.add.text(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY + 60,\n            'Press P to Resume',\n            {\n                fontFamily: 'Arial',\n                fontSize: '20px',\n                color: '#ffffff'\n            }\n        ).setOrigin(0.5);\n        resumeText.setDepth(Z_LAYERS.UI + 11);\n        resumeText.setData('isPauseOverlay', true);\n    }\n\n    private hidePauseOverlay(): void {\n        this.children.list.forEach(child => {\n            if (child.getData('isPauseOverlay')) {\n                child.destroy();\n            }\n        });\n    }\n\n    private returnToMenu(): void {\n        // Properly cleanup background music\n        if (this.backgroundMusic) {\n            this.backgroundMusic.stop();\n            this.backgroundMusic.destroy();\n            this.backgroundMusic = undefined;\n        }\n        \n        this.arenaSystem?.destroy();\n        this.soundSystem?.destroy();\n        this.sceneManager.transitionTo(SceneKeys.MENU);\n    }\n\n    public override update(time: number, delta: number): void {\n        if (this.isPaused) return;\n        \n        // Update FPS counter\n        this.updateFPSDisplay();\n        \n        // Update arena system\n        this.arenaSystem?.update(time, delta);\n    }\n    \n    private updateFPSDisplay(): void {\n        if (!this.fpsText) return;\n        \n        this.frameCount++;\n        const now = performance.now();\n        const elapsed = now - this.lastFPSUpdate;\n        \n        // Update FPS every 1000ms to reduce overhead when targeting 120 FPS\n        if (elapsed >= 1000) {\n            const fps = Math.round((this.frameCount * 1000) / elapsed);\n            this.fpsText.setText(`FPS: ${fps}`);\n            \n            // Color code based on performance\n            if (fps >= 100) {\n                this.fpsText.setColor('#00FF00'); // Green for excellent\n            } else if (fps >= 60) {\n                this.fpsText.setColor('#FFFF00'); // Yellow for good  \n            } else if (fps >= 30) {\n                this.fpsText.setColor('#FFA500'); // Orange for okay\n            } else {\n                this.fpsText.setColor('#FF0000'); // Red for poor\n            }\n            \n            this.frameCount = 0;\n            this.lastFPSUpdate = now;\n        }\n    }\n    \n    public shutdown(): void {\n        // Properly cleanup background music\n        if (this.backgroundMusic) {\n            this.backgroundMusic.stop();\n            this.backgroundMusic.destroy();\n            this.backgroundMusic = undefined;\n        }\n        \n        this.arenaSystem?.destroy();\n        this.soundSystem?.destroy();\n        this.backgroundSystem?.destroy();\n        this.performanceMonitor?.reset();\n    }\n}","/// <reference types=\"@capacitor/cli\" />\nexport var Style;\n(function (Style) {\n    /**\n     * Light text for dark backgrounds.\n     *\n     * @since 1.0.0\n     */\n    Style[\"Dark\"] = \"DARK\";\n    /**\n     * Dark text for light backgrounds.\n     *\n     * @since 1.0.0\n     */\n    Style[\"Light\"] = \"LIGHT\";\n    /**\n     * The style is based on the device appearance.\n     * If the device is using Dark mode, the statusbar text will be light.\n     * If the device is using Light mode, the statusbar text will be dark.\n     *\n     * @since 1.0.0\n     */\n    Style[\"Default\"] = \"DEFAULT\";\n})(Style || (Style = {}));\nexport var Animation;\n(function (Animation) {\n    /**\n     * No animation during show/hide.\n     *\n     * @since 1.0.0\n     */\n    Animation[\"None\"] = \"NONE\";\n    /**\n     * Slide animation during show/hide.\n     * It doesn't work on iOS 15+.\n     *\n     * @deprecated Use Animation.Fade or Animation.None instead.\n     *\n     * @since 1.0.0\n     */\n    Animation[\"Slide\"] = \"SLIDE\";\n    /**\n     * Fade animation during show/hide.\n     *\n     * @since 1.0.0\n     */\n    Animation[\"Fade\"] = \"FADE\";\n})(Animation || (Animation = {}));\n/**\n * @deprecated Use `Animation`.\n * @since 1.0.0\n */\nexport const StatusBarAnimation = Animation;\n/**\n * @deprecated Use `Style`.\n * @since 1.0.0\n */\nexport const StatusBarStyle = Style;\n//# sourceMappingURL=definitions.js.map","import { registerPlugin } from '@capacitor/core';\nconst StatusBar = registerPlugin('StatusBar');\nexport * from './definitions';\nexport { StatusBar };\n//# sourceMappingURL=index.js.map","/// <reference types=\"@capacitor/cli\" />\nexport var KeyboardStyle;\n(function (KeyboardStyle) {\n    /**\n     * Dark keyboard.\n     *\n     * @since 1.0.0\n     */\n    KeyboardStyle[\"Dark\"] = \"DARK\";\n    /**\n     * Light keyboard.\n     *\n     * @since 1.0.0\n     */\n    KeyboardStyle[\"Light\"] = \"LIGHT\";\n    /**\n     * On iOS 13 and newer the keyboard style is based on the device appearance.\n     * If the device is using Dark mode, the keyboard will be dark.\n     * If the device is using Light mode, the keyboard will be light.\n     * On iOS 12 the keyboard will be light.\n     *\n     * @since 1.0.0\n     */\n    KeyboardStyle[\"Default\"] = \"DEFAULT\";\n})(KeyboardStyle || (KeyboardStyle = {}));\nexport var KeyboardResize;\n(function (KeyboardResize) {\n    /**\n     * Only the `body` HTML element will be resized.\n     * Relative units are not affected, because the viewport does not change.\n     *\n     * @since 1.0.0\n     */\n    KeyboardResize[\"Body\"] = \"body\";\n    /**\n     * Only the `ion-app` HTML element will be resized.\n     * Use it only for Ionic Framework apps.\n     *\n     * @since 1.0.0\n     */\n    KeyboardResize[\"Ionic\"] = \"ionic\";\n    /**\n     * The whole native Web View will be resized when the keyboard shows/hides.\n     * This affects the `vh` relative unit.\n     *\n     * @since 1.0.0\n     */\n    KeyboardResize[\"Native\"] = \"native\";\n    /**\n     * Neither the app nor the Web View are resized.\n     *\n     * @since 1.0.0\n     */\n    KeyboardResize[\"None\"] = \"none\";\n})(KeyboardResize || (KeyboardResize = {}));\n//# sourceMappingURL=definitions.js.map","import { registerPlugin } from '@capacitor/core';\nconst Keyboard = registerPlugin('Keyboard');\nexport * from './definitions';\nexport { Keyboard };\n//# sourceMappingURL=index.js.map","import { registerPlugin } from '@capacitor/core';\nconst App = registerPlugin('App', {\n    web: () => import('./web').then(m => new m.AppWeb()),\n});\nexport * from './definitions';\nexport { App };\n//# sourceMappingURL=index.js.map","import { registerPlugin } from '@capacitor/core';\n\nexport interface PerformancePlugin {\n    maximizePerformance(): Promise<{ success: boolean; message: string }>;\n    getDeviceCapabilities(): Promise<{\n        model: string;\n        systemVersion: string;\n        processorCount: number;\n        physicalMemory: number;\n        thermalState: number;\n        lowPowerMode: boolean;\n        batteryLevel: number;\n        supportsProMotion: boolean;\n    }>;\n}\n\nconst Performance = registerPlugin<PerformancePlugin>('PerformancePlugin', {\n    web: () => Promise.resolve({\n        maximizePerformance: async () => ({ success: true, message: 'Web platform - no optimization needed' }),\n        getDeviceCapabilities: async () => ({\n            model: 'Web Browser',\n            systemVersion: navigator.userAgent,\n            processorCount: navigator.hardwareConcurrency || 4,\n            physicalMemory: 0,\n            thermalState: 0,\n            lowPowerMode: false,\n            batteryLevel: 1,\n            supportsProMotion: false\n        })\n    })\n});\n\nexport default Performance;","/**\n * Capacitor-specific optimizations for iOS performance\n */\n\nimport { Capacitor } from '@capacitor/core';\nimport { StatusBar } from '@capacitor/status-bar';\nimport { Keyboard } from '@capacitor/keyboard';\nimport { App } from '@capacitor/app';\nimport Performance from './performancePlugin';\n\nexport class CapacitorOptimizations {\n    private static instance: CapacitorOptimizations;\n    \n    private constructor() {}\n    \n    public static getInstance(): CapacitorOptimizations {\n        if (!CapacitorOptimizations.instance) {\n            CapacitorOptimizations.instance = new CapacitorOptimizations();\n        }\n        return CapacitorOptimizations.instance;\n    }\n    \n    /**\n     * Initialize all iOS optimizations\n     */\n    public async initialize(): Promise<void> {\n        if (!Capacitor.isNativePlatform()) {\n            console.log('Not running on native platform, skipping optimizations');\n            return;\n        }\n        \n        console.log('Initializing Capacitor optimizations for iOS...');\n        \n        try {\n            // Performance optimizations disabled - let iOS handle naturally\n            // await this.maximizeDevicePerformance();\n            \n            // Hide status bar for full screen experience\n            await this.hideStatusBar();\n            \n            // Configure keyboard behavior\n            await this.configureKeyboard();\n            \n            // Handle app state changes\n            this.handleAppStateChanges();\n            \n            // Disable overscroll/bounce effect\n            this.disableOverscroll();\n            \n            // Optimize WebView settings\n            this.optimizeWebView();\n            \n            // Request high performance mode\n            this.requestHighPerformance();\n            \n            console.log('Capacitor optimizations initialized successfully');\n        } catch (error) {\n            console.error('Error initializing Capacitor optimizations:', error);\n        }\n    }\n    \n    /**\n     * Maximize device performance using native plugin\n     */\n    private async maximizeDevicePerformance(): Promise<void> {\n        try {\n            console.log('Attempting to maximize iOS performance...');\n            \n            // Get device capabilities first\n            const capabilities = await Performance.getDeviceCapabilities();\n            console.log('Device capabilities:', capabilities);\n            \n            // Request maximum performance mode\n            const result = await Performance.maximizePerformance();\n            console.log('Performance maximization result:', result);\n            \n            // Log performance status\n            if (capabilities.supportsProMotion) {\n                console.log('✅ ProMotion 120Hz display enabled');\n            }\n            if (!capabilities.lowPowerMode) {\n                console.log('✅ Low Power Mode is OFF - Full performance available');\n            }\n            console.log(`✅ CPU Cores: ${capabilities.processorCount}`);\n            console.log(`✅ RAM: ${(capabilities.physicalMemory / 1024 / 1024 / 1024).toFixed(1)} GB`);\n            \n        } catch (error) {\n            console.warn('Could not maximize performance:', error);\n        }\n    }\n    \n    /**\n     * Hide the status bar for immersive experience\n     */\n    private async hideStatusBar(): Promise<void> {\n        try {\n            await StatusBar.hide();\n            console.log('Status bar hidden');\n        } catch (error) {\n            console.warn('Could not hide status bar:', error);\n        }\n    }\n    \n    /**\n     * Configure keyboard behavior\n     */\n    private async configureKeyboard(): Promise<void> {\n        try {\n            // Set keyboard to not resize the WebView\n            await Keyboard.setResizeMode({ mode: 'none' });\n            \n            // Hide keyboard accessory bar\n            await Keyboard.setAccessoryBarVisible({ isVisible: false });\n            \n            console.log('Keyboard configured');\n        } catch (error) {\n            console.warn('Could not configure keyboard:', error);\n        }\n    }\n    \n    /**\n     * Handle app state changes for performance\n     */\n    private handleAppStateChanges(): void {\n        App.addListener('appStateChange', ({ isActive }) => {\n            if (isActive) {\n                console.log('App resumed - resuming game');\n                // Resume game logic\n                this.onAppResume();\n            } else {\n                console.log('App paused - pausing game');\n                // Pause game logic\n                this.onAppPause();\n            }\n        });\n    }\n    \n    /**\n     * Disable overscroll/bounce effect on iOS\n     */\n    private disableOverscroll(): void {\n        if (Capacitor.getPlatform() === 'ios') {\n            // Disable bounce effect\n            document.body.style.overflow = 'hidden';\n            document.body.style.position = 'fixed';\n            document.body.style.width = '100%';\n            document.body.style.height = '100%';\n            \n            // Prevent pull-to-refresh\n            document.body.addEventListener('touchmove', (e) => {\n                if (e.touches.length > 1) return; // Allow multi-touch\n                e.preventDefault();\n            }, { passive: false });\n            \n            console.log('Overscroll disabled');\n        }\n    }\n    \n    /**\n     * Optimize WebView settings\n     */\n    private optimizeWebView(): void {\n        // Disable text selection\n        document.body.style.userSelect = 'none';\n        document.body.style.webkitUserSelect = 'none';\n        \n        // Disable tap highlight\n        document.body.style.webkitTapHighlightColor = 'transparent';\n        \n        // Enable hardware acceleration\n        document.body.style.transform = 'translateZ(0)';\n        document.body.style.webkitTransform = 'translateZ(0)';\n        \n        // Disable touch callouts\n        document.body.style.webkitTouchCallout = 'none';\n        \n        // Set viewport for optimal rendering\n        const viewport = document.querySelector('meta[name=\"viewport\"]');\n        if (viewport) {\n            viewport.setAttribute('content', \n                'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover'\n            );\n        }\n        \n        console.log('WebView optimized');\n    }\n    \n    /**\n     * Request high performance mode\n     */\n    private requestHighPerformance(): void {\n        // Request wake lock to prevent screen dimming during gameplay\n        if ('wakeLock' in navigator) {\n            (navigator as any).wakeLock.request('screen').then(() => {\n                console.log('Wake lock activated');\n            }).catch((err: Error) => {\n                console.warn('Wake lock failed:', err);\n            });\n        }\n        \n        // REMOVED: Empty RAF loop was consuming resources\n        // Phaser already handles its own render loop efficiently\n        \n        console.log('High performance mode requested');\n    }\n    \n    /**\n     * Called when app resumes\n     */\n    private onAppResume(): void {\n        // Resume audio context if needed\n        const audioContext = (window as any).audioContext;\n        if (audioContext && audioContext.state === 'suspended') {\n            audioContext.resume();\n        }\n        \n        // Re-enable wake lock\n        if ('wakeLock' in navigator) {\n            (navigator as any).wakeLock.request('screen').catch(() => {});\n        }\n    }\n    \n    /**\n     * Called when app pauses\n     */\n    private onAppPause(): void {\n        // Pause audio context if needed\n        const audioContext = (window as any).audioContext;\n        if (audioContext && audioContext.state === 'running') {\n            audioContext.suspend();\n        }\n    }\n    \n    /**\n     * Clean up optimizations\n     */\n    public destroy(): void {\n        // Remove event listeners\n        App.removeAllListeners();\n        \n        // Release wake lock\n        if ('wakeLock' in navigator) {\n            (navigator as any).wakeLock.release().catch(() => {});\n        }\n    }\n}","import Phaser from 'phaser';\nimport { createGameConfig } from '@config/GameConfig';\nimport { BootScene } from '@scenes/BootScene';\nimport { PreloadScene } from '@scenes/PreloadScene';\nimport { MenuScene } from '@scenes/MenuScene';\nimport { ThemeSelectScene } from '@scenes/ThemeSelectScene';\nimport { GameScene } from '@scenes/GameScene';\nimport { CapacitorOptimizations } from '@utils/capacitorOptimizations';\nimport { Capacitor } from '@capacitor/core';\n\nclass BubbleBattleRoyale {\n    private game: Phaser.Game | null = null;\n\n    constructor() {\n        this.initialize();\n    }\n\n    private async initialize(): Promise<void> {\n        console.log('Bubble Battle Royale - Initializing...');\n        \n        // Apply iOS/Capacitor optimizations\n        if (Capacitor.isNativePlatform()) {\n            console.log('Running on native platform - applying optimizations');\n            const optimizer = CapacitorOptimizations.getInstance();\n            await optimizer.initialize();\n        }\n        \n        this.setupErrorHandling();\n        this.waitForDOM(() => {\n            this.createGame();\n            this.hideLoadingScreen();\n        });\n    }\n\n    private setupErrorHandling(): void {\n        window.addEventListener('error', (event) => {\n            console.error('Global error:', event.error);\n        });\n\n        window.addEventListener('unhandledrejection', (event) => {\n            console.error('Unhandled promise rejection:', event.reason);\n        });\n    }\n\n    private waitForDOM(callback: () => void): void {\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', callback);\n        } else {\n            callback();\n        }\n    }\n\n    private createGame(): void {\n        console.log('createGame called - preparing scenes');\n        const scenes = [\n            BootScene,\n            PreloadScene,\n            MenuScene,\n            ThemeSelectScene,\n            GameScene\n        ];\n        console.log('Scenes prepared:', scenes.map(s => s.name));\n\n        const config = createGameConfig(scenes);\n        console.log('Game config created:', config);\n        \n        try {\n            console.log('Creating Phaser.Game instance...');\n            this.game = new Phaser.Game(config as Phaser.Types.Core.GameConfig);\n            console.log('Game created successfully');\n            \n            this.setupGameEventListeners();\n            \n        } catch (error) {\n            console.error('Failed to create game:', error);\n            this.showErrorMessage('Failed to initialize game. Please refresh the page.');\n        }\n    }\n\n    private setupGameEventListeners(): void {\n        if (!this.game) return;\n\n        this.game.events.on('ready', () => {\n            console.log('Game is ready');\n        });\n\n        this.game.events.on('destroy', () => {\n            console.log('Game destroyed');\n        });\n\n        window.addEventListener('beforeunload', () => {\n            if (this.game) {\n                this.game.destroy(true, false);\n            }\n        });\n    }\n\n    private hideLoadingScreen(): void {\n        setTimeout(() => {\n            const loadingElement = document.getElementById('loading');\n            if (loadingElement) {\n                loadingElement.style.transition = 'opacity 0.5s';\n                loadingElement.style.opacity = '0';\n                setTimeout(() => {\n                    loadingElement.style.display = 'none';\n                }, 500);\n            }\n        }, 1000);\n    }\n\n    private showErrorMessage(message: string): void {\n        const loadingElement = document.getElementById('loading');\n        if (loadingElement) {\n            loadingElement.innerHTML = `\n                <div style=\"color: #e74c3c; font-size: 20px;\">${message}</div>\n                <div style=\"margin-top: 20px; font-size: 14px; opacity: 0.8;\">\n                    Check the console for more details\n                </div>\n            `;\n        }\n    }\n\n    public getGame(): Phaser.Game | null {\n        return this.game;\n    }\n}\n\nconsole.log('Creating BubbleBattleRoyale instance...');\nconst app = new BubbleBattleRoyale();\nconsole.log('BubbleBattleRoyale instance created');\n\nif (import.meta.hot) {\n    import.meta.hot.accept(() => {\n        console.log('HMR: Module updated');\n    });\n}\n\nexport default app;"],"file":"assets/index-B0aQ3y6f.js"}